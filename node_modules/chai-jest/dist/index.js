"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const expect_1 = __importDefault(require("expect"));
require("./chaiExtensions");
function getReturnCount(mock) {
    return mock.mock.results.filter((r) => r && r.type === 'return').length;
}
function getCallCount(mock) {
    return mock.mock.calls.length;
}
function wrapJestExpect(self, fn, failMessage, notFailMessage, expected, actual, showDiff) {
    let success = true;
    try {
        fn();
    }
    catch (err) {
        success = false;
    }
    self.assert(success, failMessage, notFailMessage, expected, actual, showDiff);
}
const chaiJest = (chai) => {
    function assertIsMock(mock) {
        const isMock = typeof mock === 'function' &&
            'mock' in mock &&
            typeof mock.mock === 'object' &&
            Array.isArray(mock.mock.calls) &&
            Array.isArray(mock.mock.results);
        new chai_1.Assertion(isMock, 'must pass in a mock').to.be.true;
        return true;
    }
    chai.Assertion.addProperty('beenCalled', function () {
        assertIsMock(this._obj);
        const mock = this._obj;
        const failMessage = `expected mock to have been called\n\n` +
            `Expected number of calls: >= 1\n` +
            `Received number of calls:    0`;
        const notFailMessage = `expected mock to not have been called\n\n` +
            `Expected number of calls: 0\n` +
            `Received number of calls: ${getCallCount(mock)}`;
        wrapJestExpect(this, () => (0, expect_1.default)(mock).toHaveBeenCalled(), failMessage, notFailMessage);
    });
    chai.Assertion.addMethod('beenCalledWith', function (expected_0, ...expected_1) {
        assertIsMock(this._obj);
        const mock = this._obj;
        const args = [expected_0, ...expected_1];
        wrapJestExpect(this, () => (0, expect_1.default)(mock).toHaveBeenCalledWith(expected_0, ...expected_1), `expected mock to have been called with arguments ${args.join(', ')}`, `expected mock to not have been called with arguments ${args.join(', ')}`, expected_1);
    });
    chai.Assertion.addMethod('beenLastCalledWith', function (expected_0, ...expected_1) {
        assertIsMock(this._obj);
        const mock = this._obj;
        const args = [expected_0, ...expected_1];
        wrapJestExpect(this, () => (0, expect_1.default)(mock).toHaveBeenLastCalledWith(expected_0, ...expected_1), `expected mock to have been last called with arguments ${args.join(', ')}`, `expected mock to not have been last called with arguments ${args.join(', ')}`, expected_1, mock.mock.calls[mock.mock.calls.length - 1]);
    });
    chai.Assertion.addMethod('beenNthCalledWith', function (nthCall, expected_0, ...expected_1) {
        assertIsMock(this._obj);
        const mock = this._obj;
        const args = [expected_0, ...expected_1];
        wrapJestExpect(this, () => (0, expect_1.default)(mock).toHaveBeenNthCalledWith(nthCall, expected_0, ...expected_1), `expected mock call #${nthCall} to have been called with arguments ${args.join(', ')}`, `expected mock call #${nthCall} to not have been called with arguments ${args.join(', ')}`, expected_1, mock.mock.calls[nthCall - 1]);
    });
    chai.Assertion.addMethod('beenCalledTimes', function (times) {
        assertIsMock(this._obj);
        const mock = this._obj;
        wrapJestExpect(this, () => (0, expect_1.default)(mock).toHaveBeenCalledTimes(times), `expected mock to have been called ${times} times`, `expected mock to not have been called ${times} times`, times, mock.mock.calls.length);
    });
    chai.Assertion.addProperty('returned', function () {
        assertIsMock(this._obj);
        const mock = this._obj;
        wrapJestExpect(this, () => (0, expect_1.default)(mock).toHaveReturned(), `expected mock to have returned`, `expected mock to not have returned`);
    });
    chai.Assertion.addMethod('returnedTimes', function (times) {
        assertIsMock(this._obj);
        const mock = this._obj;
        wrapJestExpect(this, () => (0, expect_1.default)(mock).toHaveReturnedTimes(times), `expected mock to have been return ${times} times`, `expected mock to not have been return ${times} times`, times, getReturnCount(mock));
    });
    chai.Assertion.addMethod('returnedWith', function (expected) {
        assertIsMock(this._obj);
        const mock = this._obj;
        wrapJestExpect(this, () => (0, expect_1.default)(mock).toHaveReturnedWith(expected), `expected mock to have returned with ${expected}`, `expected mock to not have returned with ${expected}`, expected);
    });
    chai.Assertion.addMethod('lastReturnedWith', function (expected) {
        assertIsMock(this._obj);
        const mock = this._obj;
        const { results } = mock.mock;
        const lastResult = results[results.length - 1];
        wrapJestExpect(this, () => (0, expect_1.default)(mock).toHaveLastReturnedWith(expected), `expected mock's last call to return ${expected}`, `expected mock's last call to not return ${expected}`, expected, lastResult.value);
    });
    chai.Assertion.addMethod('nthReturnedWith', function (nthCall, expected) {
        assertIsMock(this._obj);
        const mock = this._obj;
        const { results } = mock.mock;
        const result = results[nthCall - 1];
        wrapJestExpect(this, () => (0, expect_1.default)(mock).toHaveNthReturnedWith(nthCall, expected), `expected mock call #${nthCall} to return ${expected}`, `expected mock call #${nthCall} to not return ${expected}`, expected, result.value);
    });
};
exports.default = chaiJest;
//# sourceMappingURL=index.js.map
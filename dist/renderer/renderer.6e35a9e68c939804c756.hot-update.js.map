{"version":3,"file":"renderer.6e35a9e68c939804c756.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAmD;AACS;AACK;AACnB;AACmB;AACxB;AACsB;AACxD,yBAAyB,0JAA0J;AAC1L,yBAAyB,6CAAM;AAC/B,YAAY,2CAA2C,EAAE,6EAAkB;AAC3E,YAAY,kBAAkB,EAAE,6EAAkB;AAClD;AACA,4BAA4B,kDAAW;AACvC;AACA,KAAK;AACL,6BAA6B,kDAAW;AACxC;AACA;AACA;AACA,KAAK;AACL,4BAA4B,kDAAW;AACvC;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,2BAA2B,kDAAW;AACtC;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,4BAA4B,kDAAW;AACvC;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,uBAAuB,kDAAW;AAClC;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA;AACA;AACA;AACA,kCAAkC,uEAAiB;AACnD,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2DAAU;AACpD;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA,yBAAyB;AACzB,iCAAiC;AACjC;AACA;AACA;AACA,0CAA0C,2DAAU;AACpD;AACA;AACA;AACA;AACA,yBAAyB;AACzB,iCAAiC;AACjC;AACA;AACA;AACA,4CAA4C,2DAAU;AACtD;AACA;AACA;AACA,yBAAyB;AACzB,iCAAiC;AACjC;AACA;AACA;AACA,kEAAkE,UAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA,kCAAkC,wDAAW;AAC7C;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iDAAiD,WAAW,8BAA8B,UAAU;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,kDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,0DAAmB,UAAU,iFAAiF,8BAA8B,EAAE,YAAY,EAAE,oCAAoC,yFAAyF,YAAY;AACjT;AACA,WAAW;AACX,QAAQ,0DAAmB,UAAU,oGAAoG,WAAW;AACpJ;AACA;AACA;AACA,eAAe;AACf,oBAAoB,0DAAmB,CAAC,uDAAY,IAAI;AACxD;AACA,mBAAmB;AACnB,SAAS;AACT;;;;;;;;;UC5MA","sources":["webpack://remotion-editor/./src/renderer/components/TimelineTrack.tsx","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { useCallback, useRef } from 'react';\nimport { ActionTypes, createClip } from '../types/timeline';\nimport { useTimelineContext } from '../hooks/useTimelineContext';\nimport { TimelineClip } from './TimelineClip';\nimport { useLayerManagement } from '../hooks/useLayerManagement';\nimport { logger } from '../utils/logger';\nimport { TimelineConstants } from '../utils/timelineConstants';\nexport const TimelineTrack = ({ track, isSelected, zoom, fps, onSelectTrack, onSelectClip, onClipDragStart, onClipDragEnd, onToggleVisibility, onUpdateTrack, onDeleteTrack, onMoveTrack }) => {\n    const containerRef = useRef(null);\n    const { assignLayers, getTrackHeight, getClipTop } = useLayerManagement();\n    const { state, dispatch } = useTimelineContext();\n    // Get clips with optimized layer assignments\n    const clipsWithLayers = useCallback(() => {\n        return assignLayers(track.clips, track);\n    }, [track, assignLayers]);\n    const handleTrackClick = useCallback((e) => {\n        if (e.currentTarget === e.target) {\n            onSelectTrack(track.id);\n        }\n    }, [track.id, onSelectTrack]);\n    const handleDragEnter = useCallback((e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        logger.debug('Track drag enter:', {\n            target: e.target,\n            currentTarget: e.currentTarget,\n            className: e.currentTarget.className\n        });\n        e.currentTarget.classList.add('drag-over');\n    }, []);\n    const handleDragOver = useCallback((e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        logger.debug('Track drag over:', {\n            target: e.target,\n            currentTarget: e.currentTarget,\n            className: e.currentTarget.className\n        });\n        e.currentTarget.classList.add('drag-over');\n    }, []);\n    const handleDragLeave = useCallback((e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        logger.debug('Track drag leave:', {\n            target: e.target,\n            currentTarget: e.currentTarget,\n            className: e.currentTarget.className\n        });\n        e.currentTarget.classList.remove('drag-over');\n    }, []);\n    const handleDrop = useCallback((e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        e.currentTarget.classList.remove('drag-over');\n        try {\n            logger.debug('Drop event:', {\n                types: e.dataTransfer.types,\n                data: e.dataTransfer.getData('application/json'),\n                target: e.currentTarget.className,\n                currentTarget: e.currentTarget.className,\n                clientX: e.clientX,\n                clientY: e.clientY\n            });\n            const jsonData = e.dataTransfer.getData('application/json');\n            if (!jsonData) {\n                logger.error('No JSON data in drop event');\n                return;\n            }\n            const data = JSON.parse(jsonData);\n            logger.debug('Parsed drop data:', data);\n            if (data) {\n                // Calculate time position based on drop coordinates\n                const trackRect = e.currentTarget.getBoundingClientRect();\n                const dropX = e.clientX - trackRect.left;\n                const timeScale = TimelineConstants.Scale.getScale(state.zoom);\n                const startTime = Math.max(0, (dropX + state.scrollX) / timeScale); // Convert to time, accounting for scroll\n                // Create clip using helper\n                let clip;\n                // Create clip with proper duration properties\n                const initialDuration = data.duration;\n                const baseProps = {\n                    name: data.name,\n                    startTime,\n                    endTime: startTime + initialDuration,\n                    mediaOffset: 0,\n                    mediaDuration: initialDuration,\n                    originalDuration: initialDuration,\n                    initialDuration: initialDuration,\n                    effects: []\n                };\n                switch (data.type) {\n                    case 'video': {\n                        const videoClip = createClip('video', {\n                            ...baseProps,\n                            src: data.path,\n                            transform: {\n                                scale: 1,\n                                rotation: 0,\n                                position: { x: 0, y: 0 },\n                                opacity: 1\n                            }\n                        });\n                        clip = { ...videoClip, layer: 0 };\n                        break;\n                    }\n                    case 'audio': {\n                        const audioClip = createClip('audio', {\n                            ...baseProps,\n                            src: data.path,\n                            volume: 1,\n                            isMuted: false\n                        });\n                        clip = { ...audioClip, layer: 0 };\n                        break;\n                    }\n                    case 'caption': {\n                        const captionClip = createClip('caption', {\n                            ...baseProps,\n                            text: '',\n                            captions: []\n                        });\n                        clip = { ...captionClip, layer: 0 };\n                        break;\n                    }\n                    default:\n                        throw new Error(`Unsupported clip type: ${data.type}`);\n                }\n                // Ensure track type matches clip type\n                if ((track.type === 'video' && data.type === 'video') ||\n                    (track.type === 'audio' && data.type === 'audio') ||\n                    (track.type === 'caption' && data.type === 'caption')) {\n                    // Update track with new clip\n                    const updatedClips = [...(track.clips || []), clip];\n                    onUpdateTrack(track.id, { clips: updatedClips });\n                    // Update timeline duration if needed\n                    const maxEndTime = Math.max(...updatedClips.map(c => c.endTime));\n                    if (maxEndTime > state.duration) {\n                        dispatch({\n                            type: ActionTypes.SET_DURATION,\n                            payload: Math.max(maxEndTime, 10)\n                        });\n                    }\n                }\n                else {\n                    console.error(`Track type (${track.type}) does not match clip type (${data.type})`);\n                    return;\n                }\n            }\n        }\n        catch (error) {\n            console.error('Error handling drop:', error);\n        }\n    }, [track.id, track.clips, onUpdateTrack, state, dispatch, state.zoom]);\n    const handleKeyDown = useCallback((e) => {\n        switch (e.key) {\n            case 'Enter':\n            case ' ':\n                e.preventDefault();\n                onSelectTrack(track.id);\n                break;\n            case 'ArrowUp':\n                e.preventDefault();\n                // Focus previous track\n                const prevTrack = containerRef.current?.previousElementSibling;\n                if (prevTrack instanceof HTMLElement) {\n                    prevTrack.focus();\n                }\n                break;\n            case 'ArrowDown':\n                e.preventDefault();\n                // Focus next track\n                const nextTrack = containerRef.current?.nextElementSibling;\n                if (nextTrack instanceof HTMLElement) {\n                    nextTrack.focus();\n                }\n                break;\n            case 'Tab':\n                // Let default tab behavior work, but ensure clips are in tab order\n                if (e.shiftKey && isSelected) {\n                    // When shift+tab on selected track, focus last clip\n                    const clips = containerRef.current?.querySelectorAll('.timeline-clip');\n                    const lastClip = clips?.[clips.length - 1];\n                    if (lastClip instanceof HTMLElement) {\n                        e.preventDefault();\n                        lastClip.focus();\n                    }\n                }\n                break;\n        }\n    }, [track.id, onSelectTrack, isSelected]);\n    const layeredClips = clipsWithLayers();\n    const trackHeight = getTrackHeight(layeredClips);\n    return (React.createElement(\"div\", { ref: containerRef, \"data-testid\": \"timeline-track\", className: `timeline-track ${isSelected ? 'selected' : ''} ${track.type} ${!track.clips?.length ? 'empty' : ''}`, onClick: handleTrackClick, onKeyDown: handleKeyDown, role: \"region\", \"aria-label\": `${track.name} track`, \"aria-selected\": isSelected, tabIndex: 0, style: {\n            opacity: track.isVisible ? 1 : 0.5\n        } },\n        React.createElement(\"div\", { \"data-testid\": \"track-content\", className: \"track-content\", role: \"list\", \"aria-label\": `Clips in ${track.name}`, onDragEnter: handleDragEnter, onDragOver: handleDragOver, onDragLeave: handleDragLeave, onDrop: handleDrop, onMouseDown: (e) => {\n                if (e.target === e.currentTarget) {\n                    handleTrackClick(e);\n                }\n            } }, layeredClips.map((clip, index) => {\n            return (React.createElement(TimelineClip, { key: clip.id, clip: clip, track: track, layer: clip.layer, zoom: state.zoom, fps: state.fps, onSelect: () => onSelectClip(clip.id), onDragStart: () => onClipDragStart(clip.id), onDragEnd: onClipDragEnd, tabIndex: isSelected ? 0 : -1, \"aria-posinset\": index + 1, \"aria-setsize\": layeredClips.length, style: {\n                    top: getClipTop(clip.layer)\n                } }));\n        }))));\n};\n","__webpack_require__.h = () => (\"8ed169b3d9a811575295\")"],"names":[],"sourceRoot":""}
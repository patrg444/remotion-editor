{"version":3,"file":"renderer.746d75b71c1539b2682d.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAA0F;AACxB;AACI;AACP;AACtB;AAC2B;AAC7D,wBAAwB,oDAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,iDAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA,aAAa,wDAAW;AACxB;AACA,mBAAmB,iEAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAW;AACxB;AACA;AACA,wBAAwB,iBAAiB;AACzC,+BAA+B,mDAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAW;AACxB;AACA;AACA,wBAAwB,UAAU;AAClC,+BAA+B,mDAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yDAAkB;AAC3E;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA,aAAa;AACb;AACA,mCAAmC,8CAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,uEAAiB;AACxE,6EAA6E,uEAAiB;AAC9F;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,UAAU;AAC7C,8BAA8B,iDAAU;AACxC,WAAW,iEAAoB;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL,8CAA8C,+CAAQ;AACtD,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA,0BAA0B;AAC1B,aAAa;AACb;AACA,KAAK;AACL,QAAQ,IAAuE;AAC/E,QAAQ,gDAAS;AACjB;AACA;AACA,SAAS;AACT;AACA,IAAI,gDAAS;AACb;AACA,qCAAqC,gFAAqB;AAC1D;AACA,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA,KAAK;AACL,YAAY,0DAAmB,6BAA6B,SAAS,mBAAmB;AACxF;AACO;AACP,oBAAoB,iDAAU;AAC9B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjUA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,8CAA8C,OAAO;AACrD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;UChFA","sources":["webpack://remotion-editor/./src/renderer/contexts/TimelineContext.tsx","webpack://remotion-editor/./src/renderer/utils/timelineValidation.ts","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { createContext, useReducer, useContext, useEffect, useState } from 'react';\nimport { produce, produceWithPatches, applyPatches } from 'immer';\nimport { ActionTypes, initialTimelineState } from '../types/timeline';\nimport { TimelineConstants } from '../utils/timelineConstants';\nimport { logger } from '../utils/logger';\nimport { validateTimelineState } from '../utils/timelineValidation';\nexport const TimelineContext = createContext(undefined);\nconst NON_UNDOABLE_ACTIONS = new Set([\n    'SET_CURRENT_TIME',\n    'SET_PLAYING',\n    'SET_SCROLL_X',\n    'SET_SCROLL_Y',\n    'SET_DRAGGING',\n    'SET_ERROR',\n    'RESTORE_SNAPSHOT',\n    'SET_IS_PLAYING',\n    'SET_IS_DRAGGING',\n    'SELECT_CLIPS',\n    'SET_SELECTED_TRACK_ID',\n    'SET_DURATION',\n    'CLEAR_STATE',\n    'SET_STATE',\n    'SET_TRACKS',\n    'SET_SHOW_WAVEFORMS',\n    'SET_SHOW_KEYFRAMES',\n    'SET_SHOW_TRANSITIONS',\n    'SET_SHOW_EFFECTS',\n    'SET_RENDER_QUALITY',\n    'SET_SNAPPING',\n    'SELECT_TRACK',\n    'SELECT_CAPTIONS',\n    'PUSH_HISTORY',\n    'SET_HISTORY_INDEX',\n    'CLEAR_HISTORY'\n]);\nconst getHistoryDescription = (action) => {\n    switch (action.type) {\n        case ActionTypes.ADD_TRACK:\n            return 'Add track';\n        case ActionTypes.REMOVE_TRACK:\n            return 'Remove track';\n        case ActionTypes.ADD_CLIP:\n            return 'Add clip';\n        case ActionTypes.REMOVE_CLIP:\n            return 'Remove clip';\n        case ActionTypes.MOVE_CLIP:\n            return 'Move clip';\n        case ActionTypes.SPLIT_CLIP:\n            return 'Split clip';\n        case ActionTypes.TRIM_CLIP:\n            return 'Trim clip';\n        case ActionTypes.SET_ZOOM:\n            return 'Change zoom';\n        case ActionTypes.SET_FPS:\n            return 'Change FPS';\n        default:\n            return action.type;\n    }\n};\nconst isUndoable = (action) => {\n    return !NON_UNDOABLE_ACTIONS.has(action.type);\n};\nconst timelineReducer = (state, action) => {\n    logger.debug('[TimelineReducer]', {\n        type: action.type,\n        payload: action.payload,\n        isUndoable: isUndoable(action),\n        currentState: {\n            tracks: state.tracks.map(t => ({\n                id: t.id,\n                clips: t.clips.map(c => ({\n                    id: c.id,\n                    startTime: c.startTime,\n                    endTime: c.endTime,\n                    layer: c.layer\n                }))\n            }))\n        }\n    });\n    switch (action.type) {\n        case ActionTypes.CLEAR_STATE: {\n            const freshState = {\n                ...initialTimelineState,\n                history: {\n                    entries: [],\n                    currentIndex: -1\n                }\n            };\n            return freshState;\n        }\n        case ActionTypes.SET_STATE: {\n            const newState = {\n                ...action.payload,\n                history: action.payload.history || state.history\n            };\n            return newState;\n        }\n        case ActionTypes.UNDO: {\n            if (state.history.currentIndex > 0) {\n                const newIndex = state.history.currentIndex - 1;\n                const { inversePatches } = state.history.entries[newIndex];\n                const undone = applyPatches(state, inversePatches);\n                return {\n                    ...undone,\n                    history: {\n                        entries: state.history.entries,\n                        currentIndex: newIndex\n                    }\n                };\n            }\n            return state;\n        }\n        case ActionTypes.REDO: {\n            if (state.history.currentIndex < state.history.entries.length - 1) {\n                const newIndex = state.history.currentIndex + 1;\n                const { patches } = state.history.entries[newIndex];\n                const redone = applyPatches(state, patches);\n                return {\n                    ...redone,\n                    history: {\n                        entries: state.history.entries,\n                        currentIndex: newIndex\n                    }\n                };\n            }\n            return state;\n        }\n        default: {\n            const [nextState, patches, inversePatches] = produceWithPatches(state, draft => {\n                switch (action.type) {\n                    case ActionTypes.SET_DURATION:\n                        draft.duration = action.payload;\n                        break;\n                    case ActionTypes.SET_TRACKS:\n                        draft.tracks = action.payload;\n                        break;\n                    case ActionTypes.SET_CURRENT_TIME:\n                        draft.currentTime = action.payload;\n                        break;\n                    case ActionTypes.SET_PLAYING:\n                        draft.isPlaying = action.payload;\n                        break;\n                    case ActionTypes.SET_SCROLL_X:\n                        draft.scrollX = action.payload;\n                        break;\n                    case ActionTypes.SET_SCROLL_Y:\n                        draft.scrollY = action.payload;\n                        break;\n                    case ActionTypes.SET_ZOOM:\n                        draft.zoom = action.payload;\n                        break;\n                    case ActionTypes.SET_FPS:\n                        draft.fps = action.payload;\n                        break;\n                    case ActionTypes.SET_DRAGGING:\n                        draft.isDragging = action.payload.isDragging;\n                        draft.dragStartX = action.payload.dragStartX;\n                        draft.dragStartY = action.payload.dragStartY;\n                        break;\n                    case ActionTypes.SET_ERROR:\n                        draft.error = action.payload;\n                        break;\n                    case ActionTypes.ADD_TRACK:\n                        draft.tracks.push(action.payload.track);\n                        break;\n                    case ActionTypes.UPDATE_TRACK: {\n                        const trackIndex = draft.tracks.findIndex(t => t.id === action.payload.trackId);\n                        if (trackIndex !== -1) {\n                            draft.tracks[trackIndex] = {\n                                ...draft.tracks[trackIndex],\n                                ...action.payload.track\n                            };\n                        }\n                        break;\n                    }\n                    case ActionTypes.REMOVE_TRACK:\n                        draft.tracks = draft.tracks.filter(t => t.id !== action.payload.trackId);\n                        break;\n                    case ActionTypes.ADD_CLIP: {\n                        const trackToAddClip = draft.tracks.find(t => t.id === action.payload.trackId);\n                        if (trackToAddClip) {\n                            const newClip = {\n                                ...action.payload.clip,\n                                startTime: action.payload.clip.startTime ?? 0,\n                                endTime: action.payload.clip.endTime ?? (action.payload.clip.duration ?? 0)\n                            };\n                            trackToAddClip.clips.push(newClip);\n                            trackToAddClip.clips.sort((a, b) => a.startTime - b.startTime);\n                        }\n                        break;\n                    }\n                    case ActionTypes.UPDATE_CLIP: {\n                        const trackWithClip = draft.tracks.find(t => t.id === action.payload.trackId);\n                        if (trackWithClip) {\n                            const clipIndex = trackWithClip.clips.findIndex(c => c.id === action.payload.clipId);\n                            if (clipIndex !== -1) {\n                                trackWithClip.clips[clipIndex] = {\n                                    ...trackWithClip.clips[clipIndex],\n                                    ...action.payload.clip\n                                };\n                            }\n                        }\n                        break;\n                    }\n                    case ActionTypes.REMOVE_CLIP: {\n                        const trackToRemoveClip = draft.tracks.find(t => t.id === action.payload.trackId);\n                        if (trackToRemoveClip) {\n                            trackToRemoveClip.clips = trackToRemoveClip.clips.filter(c => c.id !== action.payload.clipId);\n                        }\n                        break;\n                    }\n                    case ActionTypes.SPLIT_CLIP: {\n                        const trackToSplit = draft.tracks.find(t => t.id === action.payload.trackId);\n                        if (trackToSplit) {\n                            const clipToSplit = trackToSplit.clips.find(c => c.id === action.payload.clipId);\n                            if (clipToSplit && action.payload.time > clipToSplit.startTime && action.payload.time < clipToSplit.endTime) {\n                                const splitPoint = action.payload.time;\n                                trackToSplit.clips = trackToSplit.clips.filter(c => c.id !== clipToSplit.id);\n                                const firstClip = {\n                                    ...clipToSplit,\n                                    id: `${clipToSplit.id}-1`,\n                                    endTime: splitPoint\n                                };\n                                const secondClip = {\n                                    ...clipToSplit,\n                                    id: `${clipToSplit.id}-2`,\n                                    startTime: splitPoint\n                                };\n                                trackToSplit.clips.push(firstClip, secondClip);\n                                trackToSplit.clips.sort((a, b) => a.startTime - b.startTime);\n                                draft.selectedClipIds = [firstClip.id];\n                            }\n                        }\n                        break;\n                    }\n                    case ActionTypes.SELECT_CLIPS:\n                        draft.selectedClipIds = action.payload.clipIds;\n                        break;\n                    case ActionTypes.SET_SELECTED_TRACK_ID:\n                        draft.selectedTrackId = action.payload;\n                        break;\n                }\n            });\n            if (isUndoable(action)) {\n                const finalState = produce(nextState, draft => {\n                    if (draft.history.currentIndex < draft.history.entries.length - 1) {\n                        draft.history.entries = draft.history.entries.slice(0, draft.history.currentIndex + 1);\n                    }\n                    const entry = {\n                        type: 'partial',\n                        timestamp: Date.now(),\n                        patches: JSON.parse(JSON.stringify(patches)),\n                        inversePatches: JSON.parse(JSON.stringify(inversePatches)),\n                        description: getHistoryDescription(action)\n                    };\n                    draft.history.entries.push(entry);\n                    draft.history.currentIndex++;\n                    if (draft.history.entries.length > TimelineConstants.History.MAX_HISTORY_SIZE) {\n                        draft.history.entries = draft.history.entries.slice(-TimelineConstants.History.MAX_HISTORY_SIZE);\n                        draft.history.currentIndex = draft.history.entries.length - 1;\n                    }\n                });\n                return finalState;\n            }\n            return nextState;\n        }\n    }\n};\nexport const TimelineProvider = ({ children }) => {\n    const [state, dispatch] = useReducer(timelineReducer, {\n        ...initialTimelineState,\n        history: {\n            entries: [],\n            currentIndex: -1\n        }\n    });\n    const [isInitialized, setIsInitialized] = useState(false);\n    useEffect(() => {\n        try {\n            window.dispatchEvent(new CustomEvent('timeline:initializing'));\n            window.timelineDispatch = dispatch;\n            window.timelineState = state;\n            window.dispatchEvent(new CustomEvent('timeline:dispatchReady'));\n            window.timelineReady = true;\n            window.dispatchEvent(new CustomEvent('timeline:initialized'));\n            setIsInitialized(true);\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            logger.error('[TimelineProvider] Error initializing timeline:', new Error(errorMessage));\n            window.dispatchEvent(new CustomEvent('timeline:error', {\n                detail: { error: new Error(errorMessage) }\n            }));\n        }\n    }, []);\n    if (process.env.NODE_ENV !== 'production' || process.env.CYPRESS === 'true') {\n        useEffect(() => {\n            window.timelineState = state;\n            window.timelineDispatch = dispatch;\n        }, [state, dispatch]);\n    }\n    useEffect(() => {\n        try {\n            const validationErrors = validateTimelineState(state);\n            if (validationErrors.length > 0) {\n                logger.warn('[Timeline] State validation errors:', validationErrors);\n            }\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            logger.error('[Timeline] State validation failed:', new Error(errorMessage));\n        }\n    }, [state]);\n    return (React.createElement(TimelineContext.Provider, { value: { state, dispatch } }, children));\n};\nexport const useTimelineContext = () => {\n    const context = useContext(TimelineContext);\n    if (!context) {\n        throw new Error('useTimelineContext must be used within a TimelineProvider');\n    }\n    return context;\n};\n","/**\n * Validates the timeline state structure and returns any validation errors\n */\nexport function validateTimelineState(state) {\n    const errors = [];\n    // Check required properties\n    if (!state) {\n        errors.push('Timeline state is undefined');\n        return errors;\n    }\n    // Check tracks array\n    if (!Array.isArray(state.tracks)) {\n        errors.push('Tracks must be an array');\n    }\n    else {\n        // Validate each track\n        state.tracks.forEach((track, index) => {\n            if (!track.id) {\n                errors.push(`Track at index ${index} is missing id`);\n            }\n            if (!track.name) {\n                errors.push(`Track at index ${index} is missing name`);\n            }\n            if (!track.type) {\n                errors.push(`Track at index ${index} is missing type`);\n            }\n            if (!Array.isArray(track.clips)) {\n                errors.push(`Track at index ${index} clips must be an array`);\n            }\n        });\n    }\n    // Check numeric properties\n    if (typeof state.currentTime !== 'number') {\n        errors.push('currentTime must be a number');\n    }\n    if (typeof state.duration !== 'number') {\n        errors.push('duration must be a number');\n    }\n    if (typeof state.zoom !== 'number') {\n        errors.push('zoom must be a number');\n    }\n    if (typeof state.fps !== 'number') {\n        errors.push('fps must be a number');\n    }\n    if (typeof state.scrollX !== 'number') {\n        errors.push('scrollX must be a number');\n    }\n    if (typeof state.scrollY !== 'number') {\n        errors.push('scrollY must be a number');\n    }\n    // Check boolean properties\n    if (typeof state.isPlaying !== 'boolean') {\n        errors.push('isPlaying must be a boolean');\n    }\n    if (typeof state.isDragging !== 'boolean') {\n        errors.push('isDragging must be a boolean');\n    }\n    // Check arrays\n    if (!Array.isArray(state.selectedClipIds)) {\n        errors.push('selectedClipIds must be an array');\n    }\n    if (!Array.isArray(state.selectedCaptionIds)) {\n        errors.push('selectedCaptionIds must be an array');\n    }\n    if (!Array.isArray(state.markers)) {\n        errors.push('markers must be an array');\n    }\n    // Check history\n    if (!state.history) {\n        errors.push('history is missing');\n    }\n    else {\n        if (!Array.isArray(state.history.entries)) {\n            errors.push('history.entries must be an array');\n        }\n        if (typeof state.history.currentIndex !== 'number') {\n            errors.push('history.currentIndex must be a number');\n        }\n    }\n    return errors;\n}\n","__webpack_require__.h = () => (\"9258e196ec2b175cb32a\")"],"names":[],"sourceRoot":""}
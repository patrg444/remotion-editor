{"version":3,"file":"renderer.1d8d257826eae8ea80af.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;AAAiD;AACc;AACf;AACA;AACzC,0BAA0B,iLAAiL;AAClN,sBAAsB,6CAAM;AAC5B,0BAA0B,6CAAM;AAChC;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA,2CAA2C,uEAAiB;AAC5D,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA,oDAAoD,uEAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAmB,UAAU,wCAAwC;AACjF,QAAQ,0DAAmB,UAAU,uCAAuC,yBAAyB,0DAAmB,CAAC,yDAAa,IAAI,8NAA8N;AACxW,QAAQ,0DAAmB,UAAU,+HAA+H;AACpK,YAAY,0DAAmB,UAAU;AACzC;AACA;AACA;AACA;AACA,mBAAmB;AACnB,mCAAmC,0DAAmB,CAAC,yDAAa,IAAI,qVAAqV;AAC7Z,oCAAoC,0DAAmB,UAAU;AACjE;AACA,mBAAmB;AACnB,gBAAgB,0DAAmB,UAAU,yCAAyC;AACtF,gBAAgB,0DAAmB;AACnC;;;;;;;;;UCjHA","sources":["webpack://remotion-editor/./src/renderer/components/TimelineTracks.tsx","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport { TimelineConstants } from '../utils/timelineConstants';\nimport { TimelineTrack } from './TimelineTrack';\nimport { TrackControls } from './TrackControls';\nexport const TimelineTracks = ({ tracks, selectedTrackId, selectedClipIds, onSelectTrack, onSelectClip, onClipDragStart, onClipDragEnd, onToggleVisibility, onUpdateTrack, onDeleteTrack, onMoveTrack, zoom, fps }) => {\n    const tracksRef = useRef(null);\n    const lastTracksRef = useRef(tracks);\n    // Handle track updates and positioning\n    useEffect(() => {\n        const tracksChanged = tracks !== lastTracksRef.current;\n        lastTracksRef.current = tracks;\n        if (tracksRef.current) {\n            const height = tracks.length * TimelineConstants.UI.TRACK_HEIGHT;\n            tracksRef.current.style.height = `${height}px`;\n            // Force reflow to ensure height is applied\n            void tracksRef.current.offsetHeight;\n            // Notify that tracks container is ready\n            window.dispatchEvent(new CustomEvent('tracks:ready', {\n                detail: {\n                    height,\n                    trackCount: tracks.length,\n                    tracks: tracks.map(t => ({\n                        id: t.id,\n                        clipCount: t.clips.length,\n                        clips: t.clips.map(c => ({\n                            id: c.id,\n                            startTime: c.startTime,\n                            endTime: c.endTime,\n                            layer: c.layer\n                        }))\n                    }))\n                }\n            }));\n            // Wait for next frame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                if (tracksRef.current) {\n                    // Get final dimensions after styles are applied\n                    const rect = tracksRef.current.getBoundingClientRect();\n                    // Notify that tracks are positioned\n                    window.dispatchEvent(new CustomEvent('tracks:positioned', {\n                        detail: {\n                            height: rect.height,\n                            trackCount: tracks.length,\n                            tracks: tracks.map(t => ({\n                                id: t.id,\n                                clipCount: t.clips.length,\n                                clips: t.clips.map(c => ({\n                                    id: c.id,\n                                    startTime: c.startTime,\n                                    endTime: c.endTime,\n                                    layer: c.layer\n                                }))\n                            }))\n                        }\n                    }));\n                    // Force another reflow to ensure all updates are applied\n                    void tracksRef.current.offsetHeight;\n                }\n            });\n        }\n    }, [tracks]);\n    // Handle track ready events\n    useEffect(() => {\n        const handleTrackReady = (e) => {\n            const { trackId, clipCount } = e.detail;\n            const track = tracks.find(t => t.id === trackId);\n            if (track) {\n                requestAnimationFrame(() => {\n                    window.dispatchEvent(new CustomEvent('tracks:ready', {\n                        detail: {\n                            height: tracks.length * TimelineConstants.UI.TRACK_HEIGHT,\n                            trackCount: tracks.length,\n                            tracks: tracks.map(t => ({\n                                id: t.id,\n                                clipCount: t.clips.length,\n                                clips: t.clips.map(c => ({\n                                    id: c.id,\n                                    startTime: c.startTime,\n                                    endTime: c.endTime,\n                                    layer: c.layer\n                                }))\n                            }))\n                        }\n                    }));\n                });\n            }\n        };\n        window.addEventListener('track:ready', handleTrackReady);\n        return () => {\n            window.removeEventListener('track:ready', handleTrackReady);\n        };\n    }, [tracks]);\n    const handleContainerClick = (e) => {\n        // Only deselect if clicking directly on the container (not on tracks)\n        if (e.target === e.currentTarget || e.target.classList.contains('timeline-tracks-background')) {\n            onSelectTrack('');\n        }\n    };\n    return (React.createElement(\"div\", { className: \"timeline-tracks-container\" },\n        React.createElement(\"div\", { className: \"timeline-tracks-controls\" }, tracks.map((track) => (React.createElement(TrackControls, { key: track.id, track: track, isSelected: track.id === selectedTrackId, onSelect: onSelectTrack, onUpdateTrack: onUpdateTrack, onDeleteTrack: onDeleteTrack, onMoveTrack: onMoveTrack, onToggleVisibility: onToggleVisibility })))),\n        React.createElement(\"div\", { ref: tracksRef, className: \"timeline-tracks-content\", \"data-testid\": \"timeline-tracks-content\", onClick: handleContainerClick },\n            React.createElement(\"div\", { className: \"timeline-tracks-background\", style: {\n                    position: 'absolute',\n                    inset: 0,\n                    zIndex: -1,\n                    minHeight: '100%'\n                } }),\n            tracks.map((track) => (React.createElement(TimelineTrack, { key: track.id, track: track, isSelected: track.id === selectedTrackId, zoom: zoom, fps: fps, onSelectTrack: onSelectTrack, onSelectClip: onSelectClip, onClipDragStart: onClipDragStart, onClipDragEnd: onClipDragEnd, onUpdateTrack: onUpdateTrack, onDeleteTrack: onDeleteTrack, onMoveTrack: onMoveTrack, onToggleVisibility: onToggleVisibility }))),\n            tracks.length === 0 && (React.createElement(\"div\", { className: \"timeline-tracks-empty\", onClick: () => {\n                    window.dispatchEvent(new CustomEvent('timeline:add-track-requested'));\n                } },\n                React.createElement(\"div\", { className: \"timeline-tracks-empty-icon\" }, \"\\u2795\"),\n                React.createElement(\"span\", null, \"No tracks yet\\u2014click to add a track\"))))));\n};\n","__webpack_require__.h = () => (\"b4726fe8e78dbe6f7127\")"],"names":[],"sourceRoot":""}
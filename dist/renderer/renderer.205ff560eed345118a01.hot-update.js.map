{"version":3,"file":"renderer.205ff560eed345118a01.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;AAA2C;AACF;AACY;AACK;AACnD,8BAA8B,0DAA0D;AAC/F,4BAA4B,kDAAW;AACvC;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,uBAAuB,kDAAW;AAClC;AACA,oBAAoB;AACpB,QAAQ,iDAAM;AACd;AACA;AACA,SAAS;AACT,KAAK;AACL,0BAA0B,kDAAW;AACrC;AACA;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,iBAAiB,6DAAc;AAC/B,iBAAiB,6DAAc;AAC/B;AACA,iBAAiB,6DAAc;AAC/B;AACA,iBAAiB,6DAAc;AAC/B;AACA,iBAAiB,6DAAc;AAC/B;AACA,iBAAiB,6DAAc;AAC/B;AACA,iBAAiB,6DAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAmB,UAAU,kCAAkC,KAAK;AAChF,qBAAqB,gBAAgB;AACrC,sBAAsB,4BAA4B;AAClD,WAAW;AACX,QAAQ,0DAAmB,UAAU,wLAAwL;AAC7N,QAAQ,0DAAmB,CAAC,mEAAkB,IAAI,mDAAmD;AACrG,QAAQ,0DAAmB,UAAU,uCAAuC;AAC5E,QAAQ,0DAAmB,UAAU,yLAAyL;AAC9N;;;;;;;;;;;;;;;;;;;;AC7DiD;AACU;AACV;AAC1C,8BAA8B,wDAAwD;AAC7F,sBAAsB,6CAAM;AAC5B,kBAAkB,6CAAM;AACxB,uBAAuB,6CAAM;AAC7B,YAAY,aAAa,EAAE,uEAAe;AAC1C;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA,8BAA8B,4DAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,0DAAmB,aAAa,uDAAuD,+BAA+B,sCAAsC;AACxK;AACA,iEAAe,kBAAkB,EAAC;;;;;;;;;;;;;;;;;ACzK+B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qCAAqC;AAC5C,kBAAkB,6CAAM,GAAG;AAC3B,8CAA8C,+CAAQ,GAAG;AACzD,gCAAgC,+CAAQ,GAAG;AAC3C,uBAAuB,6CAAM;AAC7B,+BAA+B,6CAAM;AACrC;AACA;AACA;AACA;AACA,oBAAoB,kDAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,+BAA+B;AAC/B;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,kDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,gCAAgC;AACxH,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,gCAAgC;AACzH;AACA;AACA;AACA;AACA,8EAA8E,IAAI;AAClF;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA,+BAA+B;AAC/B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD,wCAAwC,uBAAuB;AAC/D;AACA;AACA,KAAK;AACL,uBAAuB,kDAAW;AAClC;AACA,2BAA2B;AAC3B,oBAAoB;AACpB,KAAK;AACL,2BAA2B,kDAAW;AACtC;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,SAAS;AACT;AACA,2BAA2B;AAC3B;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChOqD;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK,6DAAc;AACnB;AACA;AACA;AACA,wBAAwB,gEAAgE;AACxF,2BAA2B,yEAAyE;AACpG,yBAAyB;AACzB;AACA,KAAK;AACL,KAAK,6DAAc;AACnB;AACA;AACA;AACA,wBAAwB,gEAAgE;AACxF,2BAA2B,yEAAyE;AACpG,yBAAyB;AACzB;AACA,KAAK;AACL,KAAK,6DAAc;AACnB;AACA;AACA;AACA,wBAAwB,gEAAgE;AACxF,2BAA2B,yEAAyE;AACpG,yBAAyB,uEAAuE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK,6DAAc;AACnB;AACA;AACA;AACA,wBAAwB,gEAAgE;AACxF,2BAA2B,yEAAyE;AACpG,yBAAyB,uEAAuE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK,6DAAc;AACnB;AACA;AACA;AACA,wBAAwB,gEAAgE;AACxF,2BAA2B,yEAAyE;AACpG,yBAAyB;AACzB;AACA,KAAK;AACL,KAAK,6DAAc;AACnB;AACA;AACA;AACA,wBAAwB,gEAAgE;AACxF,2BAA2B,yEAAyE;AACpG,yBAAyB;AACzB;AACA,KAAK;AACL,KAAK,6DAAc;AACnB;AACA;AACA;AACA,wBAAwB,gEAAgE;AACxF,2BAA2B,yEAAyE;AACpG,yBAAyB,uEAAuE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,WAAW,EAAC;;;;;;;;;UChN3B","sources":["webpack://remotion-editor/./src/renderer/components/TimelineTransition.tsx","webpack://remotion-editor/./src/renderer/components/TransitionRenderer.tsx","webpack://remotion-editor/./src/renderer/hooks/useTextureCache.ts","webpack://remotion-editor/./src/renderer/transitions/shaders.ts","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { useCallback } from 'react';\nimport { logger } from '../utils/logger';\nimport { TransitionType } from '../types/transition';\nimport { TransitionRenderer } from './TransitionRenderer';\nexport const TimelineTransition = ({ id, type, startTime, endTime, duration, onDurationChange }) => {\n    const handleDragStart = useCallback((e) => {\n        e.stopPropagation();\n        logger.debug('Starting transition handle drag:', {\n            id,\n            type,\n            startTime,\n            endTime,\n            duration\n        });\n    }, [id, type, startTime, endTime, duration]);\n    const handleDrag = useCallback((e) => {\n        if (!e.clientX)\n            return; // Ignore invalid drag events\n        logger.debug('Dragging transition handle:', {\n            clientX: e.clientX,\n            duration\n        });\n    }, [duration]);\n    const handleDragEnd = useCallback((e) => {\n        if (!e.clientX)\n            return;\n        const newDuration = Math.max(0.1, Math.min(2.0, duration + (e.clientX - e.currentTarget.getBoundingClientRect().left) / 100));\n        logger.debug('Ending transition handle drag:', {\n            id,\n            oldDuration: duration,\n            newDuration\n        });\n        onDurationChange(newDuration);\n    }, [id, duration, onDurationChange]);\n    const getTransitionIcon = () => {\n        switch (type) {\n            case TransitionType.Dissolve:\n            case TransitionType.Crossfade:\n                return '↔️';\n            case TransitionType.Fade:\n                return '🌅';\n            case TransitionType.Wipe:\n                return '➡️';\n            case TransitionType.Slide:\n                return '⏩';\n            case TransitionType.Zoom:\n                return '🔍';\n            case TransitionType.Push:\n                return '👉';\n            default:\n                return '↔️';\n        }\n    };\n    return (React.createElement(\"div\", { className: `timeline-transition ${type}`, \"data-testid\": \"timeline-transition\", \"data-transition-id\": id, \"data-type\": type, \"data-duration\": duration.toString(), style: {\n            left: `${startTime * 100}px`,\n            width: `${(endTime - startTime) * 100}px`\n        } },\n        React.createElement(\"div\", { className: \"timeline-transition-handle left\", \"data-testid\": \"timeline-transition-handle\", draggable: true, onDragStart: handleDragStart, onDrag: handleDrag, onDragEnd: handleDragEnd }),\n        React.createElement(TransitionRenderer, { type: type, progress: 0.5, width: 200, height: 20 }),\n        React.createElement(\"div\", { className: \"timeline-transition-icon\" }, getTransitionIcon()),\n        React.createElement(\"div\", { className: \"timeline-transition-handle right\", \"data-testid\": \"timeline-transition-handle\", draggable: true, onDragStart: handleDragStart, onDrag: handleDrag, onDragEnd: handleDragEnd })));\n};\n","import React, { useRef, useEffect } from 'react';\nimport { useTextureCache } from '../hooks/useTextureCache';\nimport transitions from '../transitions/shaders';\nexport const TransitionRenderer = ({ transition, fromClip, toClip, progress, width, height, }) => {\n    const canvasRef = useRef(null);\n    const glRef = useRef(null);\n    const programRef = useRef(null);\n    const { getTexture } = useTextureCache();\n    // Initialize WebGL context and shaders\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        if (!canvas)\n            return;\n        const gl = canvas.getContext('webgl2');\n        if (!gl) {\n            console.error('WebGL2 not supported');\n            return;\n        }\n        glRef.current = gl;\n        // Clean up\n        return () => {\n            if (programRef.current) {\n                gl.deleteProgram(programRef.current);\n            }\n        };\n    }, []);\n    // Render transition\n    useEffect(() => {\n        const gl = glRef.current;\n        if (!gl || !transition.type)\n            return;\n        const transitionDef = transitions[transition.type];\n        if (!transitionDef)\n            return;\n        const renderFrame = async () => {\n            try {\n                // Load images\n                const [fromImage, toImage] = await Promise.all([\n                    fromClip.thumbnail ? getTexture(fromClip.thumbnail) : null,\n                    toClip.thumbnail ? getTexture(toClip.thumbnail) : null,\n                ]);\n                if (!fromImage || !toImage)\n                    return;\n                // Create WebGL textures from images\n                const fromTexture = gl.createTexture();\n                const toTexture = gl.createTexture();\n                if (!fromTexture || !toTexture)\n                    return;\n                // Load first texture\n                gl.activeTexture(gl.TEXTURE0);\n                gl.bindTexture(gl.TEXTURE_2D, fromTexture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, fromImage);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                // Load second texture\n                gl.activeTexture(gl.TEXTURE1);\n                gl.bindTexture(gl.TEXTURE_2D, toTexture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, toImage);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                // Create and compile shaders\n                const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n                if (!vertexShader || !fragmentShader)\n                    return;\n                gl.shaderSource(vertexShader, transitionDef.vertexShader);\n                gl.shaderSource(fragmentShader, transitionDef.fragmentShader);\n                gl.compileShader(vertexShader);\n                if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n                    console.error('Vertex shader compilation failed:', gl.getShaderInfoLog(vertexShader));\n                    return;\n                }\n                gl.compileShader(fragmentShader);\n                if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n                    console.error('Fragment shader compilation failed:', gl.getShaderInfoLog(fragmentShader));\n                    return;\n                }\n                // Create and link program\n                const program = gl.createProgram();\n                if (!program)\n                    return;\n                gl.attachShader(program, vertexShader);\n                gl.attachShader(program, fragmentShader);\n                gl.linkProgram(program);\n                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                    console.error('Program linking failed:', gl.getProgramInfoLog(program));\n                    return;\n                }\n                gl.useProgram(program);\n                programRef.current = program;\n                // Set up uniforms\n                Object.entries(transitionDef.uniforms).forEach(([name, uniform]) => {\n                    const location = gl.getUniformLocation(program, name);\n                    if (!location)\n                        return;\n                    switch (name) {\n                        case 'progress':\n                            gl.uniform1f(location, progress);\n                            break;\n                        case 'fromTexture':\n                            gl.uniform1i(location, 0);\n                            break;\n                        case 'toTexture':\n                            gl.uniform1i(location, 1);\n                            break;\n                        case 'direction':\n                            const dir = transition.params?.direction || 'right';\n                            let vec;\n                            switch (dir) {\n                                case 'right':\n                                    vec = [1, 0];\n                                    break;\n                                case 'left':\n                                    vec = [-1, 0];\n                                    break;\n                                case 'up':\n                                    vec = [0, -1];\n                                    break;\n                                case 'down':\n                                    vec = [0, 1];\n                                    break;\n                                default:\n                                    vec = [1, 0]; // Default to right\n                            }\n                            gl.uniform2fv(location, new Float32Array(vec));\n                            break;\n                        case 'scale':\n                            if (transition.params?.scale) {\n                                gl.uniform1f(location, transition.params.scale);\n                            }\n                            break;\n                    }\n                });\n                // Set up attributes\n                const positionBuffer = gl.createBuffer();\n                const positions = new Float32Array([\n                    -1, -1,\n                    1, -1,\n                    -1, 1,\n                    1, 1,\n                ]);\n                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n                const positionLocation = gl.getAttribLocation(program, 'position');\n                gl.enableVertexAttribArray(positionLocation);\n                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n                // Draw\n                gl.viewport(0, 0, width, height);\n                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n                // Clean up\n                // Clean up\n                gl.deleteBuffer(positionBuffer);\n                gl.deleteShader(vertexShader);\n                gl.deleteShader(fragmentShader);\n                gl.deleteTexture(fromTexture);\n                gl.deleteTexture(toTexture);\n            }\n            catch (error) {\n                console.error('Error rendering transition:', error);\n            }\n        };\n        renderFrame();\n    }, [transition, fromClip, toClip, progress, width, height, getTexture]);\n    return (React.createElement(\"canvas\", { ref: canvasRef, width: width, height: height, style: { width: '100%', height: '100%' }, \"data-testid\": \"transition-canvas\" }));\n};\nexport default TransitionRenderer;\n","import { useCallback, useRef, useState, useEffect } from 'react';\nconst DEFAULT_OPTIONS = {\n    maxCacheSize: 100,\n    expirationTime: 5 * 60 * 1000,\n    maxTextureSize: 4096, // Default max texture size\n};\nfunction isValidImageData(data) {\n    if (!data)\n        return false;\n    try {\n        // Check if it has required properties\n        const hasValidProps = 'width' in data &&\n            'height' in data &&\n            'data' in data &&\n            typeof data.width === 'number' &&\n            typeof data.height === 'number' &&\n            data.width > 0 &&\n            data.height > 0 &&\n            data.data instanceof Uint8ClampedArray;\n        if (!hasValidProps)\n            return false;\n        // Check data length\n        const expectedLength = data.width * data.height * 4;\n        return data.data.length === expectedLength;\n    }\n    catch (error) {\n        console.error('ImageData validation error:', error);\n        return false;\n    }\n}\nexport function useTextureCache(options = {}) {\n    const cache = useRef({});\n    const [loadingStates, setLoadingStates] = useState({});\n    const [errors, setErrors] = useState({});\n    const cleanupRef = useRef();\n    const initialCleanupDone = useRef(false);\n    const effectiveOptions = {\n        ...DEFAULT_OPTIONS,\n        ...options,\n    };\n    const cleanup = useCallback(() => {\n        const now = Date.now();\n        const entries = Object.entries(cache.current);\n        console.log('Cleanup - Initial cache size:', entries.length);\n        console.log('Cleanup - Cache entries:', entries.map(([key, entry]) => ({\n            key,\n            lastUsed: entry.lastUsed,\n            timeSinceLastUse: now - entry.lastUsed\n        })));\n        // Sort by last used time (most recently used first)\n        entries.sort(([, a], [, b]) => b.lastUsed - a.lastUsed);\n        // Keep track of removed entries\n        const removedKeys = [];\n        // First, remove expired entries\n        for (const [key, entry] of entries) {\n            if (now - entry.lastUsed > effectiveOptions.expirationTime) {\n                console.log('Cleanup - Removing expired entry:', key);\n                delete cache.current[key];\n                removedKeys.push(key);\n            }\n        }\n        // Then, if we're still over maxCacheSize, remove oldest entries\n        const remainingEntries = Object.entries(cache.current);\n        console.log('Cleanup - Remaining entries before size check:', remainingEntries.length);\n        if (remainingEntries.length > effectiveOptions.maxCacheSize) {\n            // Re-sort remaining entries by last used time\n            remainingEntries.sort(([, a], [, b]) => b.lastUsed - a.lastUsed);\n            // Keep only the most recently used entries up to maxCacheSize\n            const entriesToRemove = remainingEntries.slice(effectiveOptions.maxCacheSize);\n            console.log('Cleanup - Entries to remove due to size limit:', entriesToRemove.length);\n            for (const [key] of entriesToRemove) {\n                console.log('Cleanup - Removing entry due to size limit:', key);\n                delete cache.current[key];\n                removedKeys.push(key);\n            }\n        }\n        // Update loading states and errors if any entries were removed\n        if (removedKeys.length > 0) {\n            setLoadingStates(prev => {\n                const next = { ...prev };\n                removedKeys.forEach(key => {\n                    delete next[key];\n                });\n                return next;\n            });\n            setErrors(prev => {\n                const next = { ...prev };\n                removedKeys.forEach(key => {\n                    delete next[key];\n                });\n                return next;\n            });\n        }\n        console.log('Cleanup - Final cache size:', Object.keys(cache.current).length);\n    }, [effectiveOptions.maxCacheSize, effectiveOptions.expirationTime]);\n    // Clean up expired textures\n    useEffect(() => {\n        if (options.disableAutoCleanup) {\n            return;\n        }\n        // Clear any existing interval\n        if (cleanupRef.current) {\n            clearInterval(cleanupRef.current);\n        }\n        // Set up new interval\n        cleanupRef.current = setInterval(cleanup, 60000); // Run cleanup every minute\n        // Run cleanup immediately only once\n        if (!initialCleanupDone.current) {\n            cleanup();\n            initialCleanupDone.current = true;\n        }\n        return () => {\n            if (cleanupRef.current) {\n                clearInterval(cleanupRef.current);\n            }\n        };\n    }, [cleanup, options.disableAutoCleanup]);\n    const getTexture = useCallback(async (source) => {\n        const key = source instanceof ImageData ? source.data.toString() : source;\n        console.log('getTexture - Current cache size:', Object.keys(cache.current).length);\n        console.log('getTexture - Loading texture:', key);\n        // Check texture size limits first\n        if (source instanceof ImageData) {\n            if (source.width > effectiveOptions.maxTextureSize || source.height > effectiveOptions.maxTextureSize) {\n                const error = new Error(`Texture size exceeds maximum allowed size of ${effectiveOptions.maxTextureSize}px`);\n                setErrors(prev => ({ ...prev, [key]: error }));\n                throw error;\n            }\n            // Then validate ImageData\n            if (!isValidImageData(source)) {\n                const error = new Error('Invalid ImageData provided');\n                setErrors(prev => ({ ...prev, [key]: error }));\n                throw error;\n            }\n        }\n        // Update last used time if in cache\n        if (cache.current[key]) {\n            console.log('getTexture - Found in cache:', key);\n            cache.current[key].lastUsed = Date.now();\n            return cache.current[key].image;\n        }\n        // Set loading state\n        setLoadingStates(prev => ({ ...prev, [key]: true }));\n        try {\n            let dataUrl = '';\n            if (source instanceof ImageData) {\n                const canvas = document.createElement('canvas');\n                canvas.width = source.width;\n                canvas.height = source.height;\n                const ctx = canvas.getContext('2d');\n                if (!ctx)\n                    throw new Error('Could not get canvas context');\n                ctx.putImageData(source, 0, 0);\n                dataUrl = canvas.toDataURL();\n            }\n            else {\n                dataUrl = source;\n            }\n            // Create and load the image\n            const img = new Image();\n            await new Promise((resolve, reject) => {\n                img.onload = () => {\n                    // Check texture size limits for loaded image\n                    if (img.width > effectiveOptions.maxTextureSize || img.height > effectiveOptions.maxTextureSize) {\n                        reject(new Error(`Texture size exceeds maximum allowed size of ${effectiveOptions.maxTextureSize}px`));\n                        return;\n                    }\n                    resolve();\n                };\n                img.onerror = () => reject(new Error(`Failed to load image: ${key}`));\n                img.src = dataUrl;\n            });\n            // Cache the loaded image\n            cache.current[key] = {\n                image: img,\n                lastUsed: Date.now(),\n                isLoading: false,\n            };\n            console.log('getTexture - Added to cache:', key);\n            console.log('getTexture - New cache size:', Object.keys(cache.current).length);\n            setLoadingStates(prev => ({ ...prev, [key]: false }));\n            setErrors(prev => {\n                const next = { ...prev };\n                delete next[key];\n                return next;\n            });\n            return img;\n        }\n        catch (error) {\n            const err = error instanceof Error ? error : new Error('Unknown error loading texture');\n            setErrors(prev => ({ ...prev, [key]: err }));\n            setLoadingStates(prev => ({ ...prev, [key]: false }));\n            throw err;\n        }\n    }, []);\n    const clearCache = useCallback(() => {\n        cache.current = {};\n        setLoadingStates({});\n        setErrors({});\n    }, []);\n    const refreshTexture = useCallback(async (source) => {\n        const key = source instanceof ImageData ? source.data.toString() : source;\n        delete cache.current[key];\n        setLoadingStates(prev => {\n            const next = { ...prev };\n            delete next[key];\n            return next;\n        });\n        setErrors(prev => {\n            const next = { ...prev };\n            delete next[key];\n            return next;\n        });\n        return getTexture(source);\n    }, [getTexture]);\n    return {\n        getTexture,\n        clearCache,\n        refreshTexture,\n        isLoading: loadingStates,\n        errors,\n        getCacheSize: () => Object.keys(cache.current).length,\n        _cleanup: cleanup, // Expose for testing\n    };\n}\n","import { TransitionType } from '../types/transition';\n// Common vertex shader (pass-through)\nconst commonVertexShader = `#version 300 es\nin vec2 position;\nout vec2 vUv;\n\nvoid main() {\n    vUv = position * 0.5 + 0.5;\n    gl_Position = vec4(position, 0.0, 1.0);\n}`;\n// Core fragment shaders\nconst dissolveShader = `#version 300 es\nprecision highp float;\n\nuniform sampler2D fromTexture;\nuniform sampler2D toTexture;\nuniform float progress;\n\nin vec2 vUv;\nout vec4 fragColor;\n\nvoid main() {\n    vec4 fromColor = texture(fromTexture, vUv);\n    vec4 toColor = texture(toTexture, vUv);\n    fragColor = mix(fromColor, toColor, progress);\n}`;\nconst fadeShader = `#version 300 es\nprecision highp float;\n\nuniform sampler2D fromTexture;\nuniform sampler2D toTexture;\nuniform float progress;\n\nin vec2 vUv;\nout vec4 fragColor;\n\nvoid main() {\n    vec4 fromColor = texture(fromTexture, vUv);\n    vec4 toColor = texture(toTexture, vUv);\n    fromColor.a = 1.0 - progress;\n    toColor.a = progress;\n    fragColor = mix(fromColor, toColor, progress);\n}`;\nconst slideShader = `#version 300 es\nprecision highp float;\n\nuniform sampler2D fromTexture;\nuniform sampler2D toTexture;\nuniform float progress;\nuniform vec2 direction;\n\nin vec2 vUv;\nout vec4 fragColor;\n\nvoid main() {\n    vec2 p = vUv + progress * direction;\n    vec2 f = clamp(p, 0.0, 1.0);\n    vec2 t = clamp(p - direction, 0.0, 1.0);\n    \n    vec4 fromColor = texture(fromTexture, f);\n    vec4 toColor = texture(toTexture, t);\n    \n    fragColor = mix(fromColor, toColor, step(0.0, progress * 2.0 - 1.0));\n}`;\nconst zoomShader = `#version 300 es\nprecision highp float;\n\nuniform sampler2D fromTexture;\nuniform sampler2D toTexture;\nuniform float progress;\n\nin vec2 vUv;\nout vec4 fragColor;\n\nvoid main() {\n    vec2 center = vec2(0.5, 0.5);\n    vec2 fromCoord = center + (vUv - center) * (1.0 - progress);\n    vec2 toCoord = center + (vUv - center) * progress;\n    \n    vec4 fromColor = texture(fromTexture, fromCoord);\n    vec4 toColor = texture(toTexture, toCoord);\n    \n    fragColor = mix(fromColor, toColor, progress);\n}`;\nconst pushShader = `#version 300 es\nprecision highp float;\n\nuniform sampler2D fromTexture;\nuniform sampler2D toTexture;\nuniform float progress;\nuniform vec2 direction;\n\nin vec2 vUv;\nout vec4 fragColor;\n\nvoid main() {\n    vec2 p = vUv - progress * direction;\n    vec2 f = clamp(p, 0.0, 1.0);\n    vec2 t = clamp(p + direction, 0.0, 1.0);\n    \n    vec4 fromColor = texture(fromTexture, f);\n    vec4 toColor = texture(toTexture, t);\n    \n    fragColor = mix(fromColor, toColor, step(1.0, p.x + p.y));\n}`;\nconst wipeShader = `#version 300 es\nprecision highp float;\n\nuniform sampler2D fromTexture;\nuniform sampler2D toTexture;\nuniform float progress;\nuniform vec2 direction;\n\nin vec2 vUv;\nout vec4 fragColor;\n\nvoid main() {\n    vec4 fromColor = texture(fromTexture, vUv);\n    vec4 toColor = texture(toTexture, vUv);\n    \n    float threshold = dot(vUv - 0.5, normalize(direction));\n    float edge = smoothstep(-0.1, 0.1, threshold - progress + 0.5);\n    \n    fragColor = mix(toColor, fromColor, edge);\n}`;\nconst transitions = {\n    [TransitionType.Dissolve]: {\n        vertexShader: commonVertexShader,\n        fragmentShader: dissolveShader,\n        uniforms: {\n            progress: { type: 'float', value: 0.0, defaultValue: 0.0, name: 'progress' },\n            fromTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'fromTexture' },\n            toTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'toTexture' }\n        }\n    },\n    [TransitionType.Fade]: {\n        vertexShader: commonVertexShader,\n        fragmentShader: fadeShader,\n        uniforms: {\n            progress: { type: 'float', value: 0.0, defaultValue: 0.0, name: 'progress' },\n            fromTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'fromTexture' },\n            toTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'toTexture' }\n        }\n    },\n    [TransitionType.Wipe]: {\n        vertexShader: commonVertexShader,\n        fragmentShader: wipeShader,\n        uniforms: {\n            progress: { type: 'float', value: 0.0, defaultValue: 0.0, name: 'progress' },\n            fromTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'fromTexture' },\n            toTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'toTexture' },\n            direction: {\n                type: 'vec2',\n                value: [1.0, 0.0],\n                defaultValue: [1.0, 0.0],\n                name: 'direction'\n            }\n        }\n    },\n    [TransitionType.Slide]: {\n        vertexShader: commonVertexShader,\n        fragmentShader: slideShader,\n        uniforms: {\n            progress: { type: 'float', value: 0.0, defaultValue: 0.0, name: 'progress' },\n            fromTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'fromTexture' },\n            toTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'toTexture' },\n            direction: {\n                type: 'vec2',\n                value: [1.0, 0.0],\n                defaultValue: [1.0, 0.0],\n                name: 'direction'\n            }\n        }\n    },\n    [TransitionType.Crossfade]: {\n        vertexShader: commonVertexShader,\n        fragmentShader: dissolveShader,\n        uniforms: {\n            progress: { type: 'float', value: 0.0, defaultValue: 0.0, name: 'progress' },\n            fromTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'fromTexture' },\n            toTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'toTexture' }\n        }\n    },\n    [TransitionType.Zoom]: {\n        vertexShader: commonVertexShader,\n        fragmentShader: zoomShader,\n        uniforms: {\n            progress: { type: 'float', value: 0.0, defaultValue: 0.0, name: 'progress' },\n            fromTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'fromTexture' },\n            toTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'toTexture' }\n        }\n    },\n    [TransitionType.Push]: {\n        vertexShader: commonVertexShader,\n        fragmentShader: pushShader,\n        uniforms: {\n            progress: { type: 'float', value: 0.0, defaultValue: 0.0, name: 'progress' },\n            fromTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'fromTexture' },\n            toTexture: { type: 'sampler2D', value: null, defaultValue: null, name: 'toTexture' },\n            direction: {\n                type: 'vec2',\n                value: [1.0, 0.0],\n                defaultValue: [1.0, 0.0],\n                name: 'direction'\n            }\n        }\n    }\n};\nexport default transitions;\n","__webpack_require__.h = () => (\"96f0a800727b45edee75\")"],"names":[],"sourceRoot":""}
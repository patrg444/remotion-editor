{"version":3,"file":"renderer.dc188deababa42cc0484.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAoE;AACF;AAC8B;AACjC;AACtB;AAClC,wBAAwB,oDAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,iDAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA,aAAa,wDAAW;AACxB;AACA;AACA,mBAAmB,iEAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa,wDAAW;AACxB;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA,+BAA+B,mDAAY;AAC3C;AACA;AACA;AACA,oBAAoB,iDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa,wDAAW;AACxB;AACA;AACA,wBAAwB,UAAU;AAClC;AACA,+BAA+B,mDAAY;AAC3C;AACA;AACA;AACA,oBAAoB,iDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,yDAAyD,yDAAkB;AAC3E;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4DAAW;AAC/C;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4DAAW;AACpD;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAM;AACtC;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC;AACjC;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA,aAAa;AACb;AACA,sCAAsC,mDAAY;AAClD;AACA;AACA;AACA,mCAAmC,8CAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,uEAAiB;AACxE,6EAA6E,uEAAiB;AAC9F;AACA;AACA,iBAAiB;AACjB,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,UAAU;AAC7C;AACA,8BAA8B,iDAAU;AACxC,WAAW,iEAAoB;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL,8CAA8C,qDAAc;AAC5D;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;UCxsBA","sources":["webpack://remotion-editor/./src/renderer/contexts/TimelineContext.tsx","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { createContext, useReducer, useEffect } from 'react';\nimport { produce, produceWithPatches, applyPatches } from 'immer';\nimport { ActionTypes, initialTimelineState, isVideoClip, isAudioClip } from '../types/timeline';\nimport { TimelineConstants } from '../utils/timelineConstants';\nimport { logger } from '../utils/logger';\nexport const TimelineContext = createContext(undefined);\nconst NON_UNDOABLE_ACTIONS = new Set([\n    'SET_CURRENT_TIME',\n    'SET_PLAYING',\n    'SET_SCROLL_X',\n    'SET_SCROLL_Y',\n    'SET_DRAGGING',\n    'SET_ERROR',\n    'RESTORE_SNAPSHOT',\n    'SET_IS_PLAYING',\n    'SET_IS_DRAGGING',\n    'SELECT_CLIPS',\n    'SET_SELECTED_TRACK_ID',\n    'SET_DURATION',\n    'CLEAR_STATE',\n    'SET_STATE',\n    'SET_TRACKS',\n    'SET_SHOW_WAVEFORMS',\n    'SET_SHOW_KEYFRAMES',\n    'SET_SHOW_TRANSITIONS',\n    'SET_SHOW_EFFECTS',\n    'SET_RENDER_QUALITY',\n    'SET_SNAPPING',\n    'SELECT_TRACK',\n    'SELECT_CAPTIONS',\n    'PUSH_HISTORY',\n    'SET_HISTORY_INDEX',\n    'CLEAR_HISTORY'\n]);\nconst getHistoryDescription = (action) => {\n    switch (action.type) {\n        case ActionTypes.ADD_TRACK:\n            return 'Add track';\n        case ActionTypes.REMOVE_TRACK:\n            return 'Remove track';\n        case ActionTypes.ADD_CLIP:\n            return 'Add clip';\n        case ActionTypes.REMOVE_CLIP:\n            return 'Remove clip';\n        case ActionTypes.MOVE_CLIP:\n            return 'Move clip';\n        case ActionTypes.SPLIT_CLIP:\n            return 'Split clip';\n        case ActionTypes.TRIM_CLIP:\n            return 'Trim clip';\n        case ActionTypes.SET_ZOOM:\n            return 'Change zoom';\n        case ActionTypes.SET_FPS:\n            return 'Change FPS';\n        default:\n            return action.type;\n    }\n};\nconst isUndoable = (action) => {\n    return !NON_UNDOABLE_ACTIONS.has(action.type);\n};\nexport const timelineReducer = (state, action) => {\n    logger.debug('[TimelineReducer]', {\n        type: action.type,\n        payload: action.payload,\n        isUndoable: isUndoable(action),\n        currentState: {\n            tracks: state.tracks.map(t => ({\n                id: t.id,\n                clips: t.clips.map(c => ({\n                    id: c.id,\n                    startTime: c.startTime,\n                    endTime: c.endTime,\n                    layer: c.layer\n                }))\n            }))\n        }\n    });\n    switch (action.type) {\n        case ActionTypes.CLEAR_STATE: {\n            // Create a fresh copy of initial state with empty history\n            const freshState = {\n                ...initialTimelineState,\n                history: {\n                    entries: [],\n                    currentIndex: -1\n                }\n            };\n            return freshState;\n        }\n        case ActionTypes.SET_STATE: {\n            // If the payload has a history property, use it, otherwise preserve the current history\n            const newState = {\n                ...action.payload,\n                history: action.payload.history || state.history\n            };\n            // Notify of state change\n            requestAnimationFrame(() => {\n                window.dispatchEvent(new CustomEvent('timeline:state-changed', {\n                    detail: {\n                        tracks: newState.tracks.map(t => ({\n                            id: t.id,\n                            clipCount: t.clips.length,\n                            clips: t.clips.map(c => ({\n                                id: c.id,\n                                startTime: c.startTime,\n                                endTime: c.endTime,\n                                layer: c.layer\n                            }))\n                        }))\n                    }\n                }));\n            });\n            return newState;\n        }\n        case ActionTypes.UNDO: {\n            if (state.history.currentIndex > 0) {\n                const newIndex = state.history.currentIndex - 1;\n                const { inversePatches } = state.history.entries[newIndex];\n                // Apply patches directly to state\n                const undone = applyPatches(state, inversePatches);\n                // Find and log only clip-related patches\n                const clipPatches = inversePatches.filter(p => p.path.includes('/clips/'));\n                if (clipPatches.length > 0) {\n                    logger.debug('[UNDO] Applying clip patches:', {\n                        clipCount: clipPatches.length,\n                        patches: clipPatches.map(p => ({\n                            op: p.op,\n                            path: p.path,\n                            value: p.value?.id\n                        }))\n                    });\n                }\n                // Return final state with updated history\n                const finalState = {\n                    ...undone,\n                    history: {\n                        entries: state.history.entries,\n                        currentIndex: newIndex\n                    }\n                };\n                // Notify of undo completion\n                requestAnimationFrame(() => {\n                    window.dispatchEvent(new CustomEvent('timeline:undo-complete', {\n                        detail: {\n                            fromIndex: state.history.currentIndex,\n                            toIndex: newIndex,\n                            description: state.history.entries[newIndex].description\n                        }\n                    }));\n                    // Force state update notification\n                    window.dispatchEvent(new CustomEvent('timeline:state-changed', {\n                        detail: {\n                            tracks: finalState.tracks.map(t => ({\n                                id: t.id,\n                                clipCount: t.clips.length,\n                                clips: t.clips.map(c => ({\n                                    id: c.id,\n                                    startTime: c.startTime,\n                                    endTime: c.endTime,\n                                    layer: c.layer\n                                }))\n                            }))\n                        }\n                    }));\n                });\n                return finalState;\n            }\n            return state;\n        }\n        case ActionTypes.REDO: {\n            if (state.history.currentIndex < state.history.entries.length - 1) {\n                const newIndex = state.history.currentIndex + 1;\n                const { patches } = state.history.entries[newIndex];\n                // Apply patches directly to state\n                const redone = applyPatches(state, patches);\n                // Find and log only clip-related patches\n                const clipPatches = patches.filter(p => p.path.includes('/clips/'));\n                if (clipPatches.length > 0) {\n                    logger.debug('[REDO] Applying clip patches:', {\n                        clipCount: clipPatches.length,\n                        patches: clipPatches.map(p => ({\n                            op: p.op,\n                            path: p.path,\n                            value: p.value?.id\n                        }))\n                    });\n                }\n                // Return final state with updated history\n                const finalState = {\n                    ...redone,\n                    history: {\n                        entries: state.history.entries,\n                        currentIndex: newIndex\n                    }\n                };\n                // Notify of redo completion\n                requestAnimationFrame(() => {\n                    window.dispatchEvent(new CustomEvent('timeline:redo-complete', {\n                        detail: {\n                            fromIndex: state.history.currentIndex,\n                            toIndex: newIndex,\n                            description: state.history.entries[newIndex].description\n                        }\n                    }));\n                    // Force state update notification\n                    window.dispatchEvent(new CustomEvent('timeline:state-changed', {\n                        detail: {\n                            tracks: finalState.tracks.map(t => ({\n                                id: t.id,\n                                clipCount: t.clips.length,\n                                clips: t.clips.map(c => ({\n                                    id: c.id,\n                                    startTime: c.startTime,\n                                    endTime: c.endTime,\n                                    layer: c.layer\n                                }))\n                            }))\n                        }\n                    }));\n                });\n                return finalState;\n            }\n            return state;\n        }\n        default: {\n            const [nextState, patches, inversePatches] = produceWithPatches(state, draft => {\n                switch (action.type) {\n                    case ActionTypes.SET_DURATION:\n                        draft.duration = action.payload;\n                        break;\n                    case ActionTypes.SET_TRACKS:\n                        draft.tracks = action.payload;\n                        break;\n                    case ActionTypes.SET_CURRENT_TIME:\n                        draft.currentTime = action.payload;\n                        break;\n                    case ActionTypes.SET_PLAYING:\n                        draft.isPlaying = action.payload;\n                        break;\n                    case ActionTypes.SET_SCROLL_X:\n                        draft.scrollX = action.payload;\n                        break;\n                    case ActionTypes.SET_SCROLL_Y:\n                        draft.scrollY = action.payload;\n                        break;\n                    case ActionTypes.SET_ZOOM:\n                        draft.zoom = action.payload;\n                        break;\n                    case ActionTypes.SET_FPS:\n                        draft.fps = action.payload;\n                        break;\n                    case ActionTypes.SET_DRAGGING:\n                        draft.isDragging = action.payload.isDragging;\n                        draft.dragStartX = action.payload.dragStartX;\n                        draft.dragStartY = action.payload.dragStartY;\n                        break;\n                    case ActionTypes.SET_ERROR:\n                        draft.error = action.payload;\n                        break;\n                    case ActionTypes.ADD_TRACK:\n                        draft.tracks.push(action.payload.track);\n                        break;\n                    case ActionTypes.UPDATE_TRACK: {\n                        const trackIndex = draft.tracks.findIndex(t => t.id === action.payload.trackId);\n                        if (trackIndex !== -1) {\n                            draft.tracks[trackIndex] = {\n                                ...draft.tracks[trackIndex],\n                                ...action.payload.track\n                            };\n                        }\n                        break;\n                    }\n                    case ActionTypes.REMOVE_TRACK:\n                        draft.tracks = draft.tracks.filter(t => t.id !== action.payload.trackId);\n                        break;\n                    case ActionTypes.ADD_CLIP: {\n                        const trackToAddClip = draft.tracks.find(t => t.id === action.payload.trackId);\n                        if (trackToAddClip) {\n                            trackToAddClip.clips = trackToAddClip.clips.filter(c => c.id !== action.payload.clip.id);\n                            const newClip = {\n                                ...action.payload.clip,\n                                startTime: action.payload.clip.startTime ?? 0,\n                                endTime: action.payload.clip.endTime ?? (action.payload.clip.duration ?? 0),\n                                initialBounds: action.payload.clip.initialBounds || {\n                                    startTime: action.payload.clip.startTime ?? 0,\n                                    endTime: action.payload.clip.endTime ?? (action.payload.clip.duration ?? 0),\n                                    mediaOffset: action.payload.clip.mediaOffset ?? 0,\n                                    mediaDuration: action.payload.clip.mediaDuration ?? ((action.payload.clip.endTime ?? 0) - (action.payload.clip.startTime ?? 0))\n                                }\n                            };\n                            trackToAddClip.clips.push(newClip);\n                            trackToAddClip.clips.sort((a, b) => a.startTime - b.startTime);\n                        }\n                        break;\n                    }\n                    case ActionTypes.UPDATE_CLIP: {\n                        const trackWithClip = draft.tracks.find(t => t.id === action.payload.trackId);\n                        if (trackWithClip) {\n                            const clipIndex = trackWithClip.clips.findIndex(c => c.id === action.payload.clipId);\n                            if (clipIndex !== -1) {\n                                trackWithClip.clips[clipIndex] = {\n                                    ...trackWithClip.clips[clipIndex],\n                                    ...action.payload.clip\n                                };\n                            }\n                        }\n                        break;\n                    }\n                    case ActionTypes.REMOVE_CLIP: {\n                        const trackToRemoveClip = draft.tracks.find(t => t.id === action.payload.trackId);\n                        if (trackToRemoveClip) {\n                            trackToRemoveClip.clips = trackToRemoveClip.clips.filter(c => c.id !== action.payload.clipId);\n                        }\n                        break;\n                    }\n                    case ActionTypes.MOVE_CLIP: {\n                        const sourceTrack = draft.tracks.find(t => t.id === action.payload.sourceTrackId);\n                        const targetTrack = draft.tracks.find(t => t.id === action.payload.targetTrackId);\n                        if (sourceTrack && targetTrack) {\n                            const clipToMove = sourceTrack.clips.find(c => c.id === action.payload.clipId);\n                            if (clipToMove) {\n                                const desiredStart = Math.max(0, action.payload.newTime);\n                                const delta = desiredStart - clipToMove.startTime;\n                                const newStartTime = clipToMove.startTime + delta;\n                                const newEndTime = clipToMove.endTime + delta;\n                                const updatedClip = {\n                                    ...clipToMove,\n                                    startTime: newStartTime,\n                                    endTime: newEndTime,\n                                    mediaOffset: clipToMove.mediaOffset + delta,\n                                    handles: {\n                                        startPosition: (clipToMove.handles?.startPosition ?? clipToMove.mediaOffset) + delta,\n                                        endPosition: (clipToMove.handles?.endPosition ?? (clipToMove.mediaOffset + (clipToMove.endTime - clipToMove.startTime))) + delta\n                                    },\n                                    initialBounds: {\n                                        ...clipToMove.initialBounds,\n                                        startTime: newStartTime,\n                                        endTime: newEndTime,\n                                        mediaOffset: (clipToMove.initialBounds?.mediaOffset ?? clipToMove.mediaOffset) + delta,\n                                        mediaDuration: clipToMove.initialBounds?.mediaDuration ?? clipToMove.mediaDuration\n                                    }\n                                };\n                                if (sourceTrack.id === targetTrack.id) {\n                                    const clipIndex = sourceTrack.clips.findIndex(c => c.id === clipToMove.id);\n                                    if (clipIndex !== -1) {\n                                        sourceTrack.clips[clipIndex] = updatedClip;\n                                    }\n                                }\n                                else {\n                                    sourceTrack.clips = sourceTrack.clips.filter(c => c.id !== clipToMove.id);\n                                    targetTrack.clips.push(updatedClip);\n                                }\n                            }\n                        }\n                        break;\n                    }\n                    case ActionTypes.TRIM_CLIP: {\n                        for (const track of draft.tracks) {\n                            const clipToTrim = track.clips.find(c => c.id === action.payload.clipId);\n                            if (clipToTrim) {\n                                const oldEndTime = clipToTrim.endTime;\n                                const clipIndex = track.clips.findIndex(c => c.id === clipToTrim.id);\n                                const effectiveMax = ((clipToTrim.initialBounds?.mediaOffset ?? clipToTrim.mediaOffset) + (clipToTrim.initialBounds?.mediaDuration ?? clipToTrim.mediaDuration)) - clipToTrim.mediaOffset;\n                                const maxEndTime = clipToTrim.startTime + effectiveMax;\n                                const minEndTime = clipToTrim.startTime + 0.1;\n                                let newEndTime = oldEndTime;\n                                if (action.payload.ripple) {\n                                    const dragTargetEndTime = action.payload.endTime ?? oldEndTime;\n                                    const dragDirection = Math.sign(dragTargetEndTime - oldEndTime);\n                                    const currentDuration = oldEndTime - clipToTrim.startTime;\n                                    const isInitialState = Math.abs(currentDuration - 2) < 0.01;\n                                    if (!draft.rippleState) {\n                                        draft.rippleState = {};\n                                    }\n                                    if (!(clipToTrim.id in draft.rippleState)) {\n                                        draft.rippleState[clipToTrim.id] = { initialExtensionDone: false };\n                                    }\n                                    if (dragDirection > 0) {\n                                        if (isInitialState && !draft.rippleState[clipToTrim.id].initialExtensionDone) {\n                                            newEndTime = Math.min(dragTargetEndTime, maxEndTime);\n                                            if (newEndTime > oldEndTime) {\n                                                draft.rippleState[clipToTrim.id].initialExtensionDone = true;\n                                            }\n                                        }\n                                        else if (draft.rippleState[clipToTrim.id].initialExtensionDone || !isInitialState) {\n                                            newEndTime = Math.min(dragTargetEndTime, maxEndTime);\n                                        }\n                                    }\n                                    else {\n                                        newEndTime = Math.max(dragTargetEndTime, minEndTime);\n                                    }\n                                }\n                                else {\n                                    newEndTime = action.payload.endTime !== undefined\n                                        ? Math.min(action.payload.endTime, maxEndTime)\n                                        : clipToTrim.endTime;\n                                }\n                                track.clips[clipIndex] = {\n                                    ...clipToTrim,\n                                    endTime: newEndTime,\n                                    handles: action.payload.handles || {\n                                        startPosition: clipToTrim.mediaOffset,\n                                        endPosition: clipToTrim.mediaOffset + (newEndTime - clipToTrim.startTime)\n                                    }\n                                };\n                                if (action.payload.ripple) {\n                                    const deltaTime = newEndTime - oldEndTime;\n                                    const subsequentClips = track.clips\n                                        .slice(clipIndex + 1)\n                                        .filter(c => c.startTime >= oldEndTime);\n                                    subsequentClips.forEach((clipToMove) => {\n                                        const idx = track.clips.findIndex(c => c.id === clipToMove.id);\n                                        if (idx !== -1) {\n                                            const duration = clipToMove.endTime - clipToMove.startTime;\n                                            const newStart = clipToMove.startTime + deltaTime;\n                                            track.clips[idx] = {\n                                                ...clipToMove,\n                                                startTime: newStart,\n                                                endTime: newStart + duration,\n                                                mediaOffset: clipToMove.mediaOffset + deltaTime,\n                                                handles: {\n                                                    startPosition: (clipToMove.handles?.startPosition ?? clipToMove.mediaOffset) + deltaTime,\n                                                    endPosition: (clipToMove.handles?.endPosition ?? (clipToMove.mediaOffset + duration)) + deltaTime\n                                                },\n                                                initialBounds: {\n                                                    ...clipToMove.initialBounds,\n                                                    startTime: newStart,\n                                                    endTime: newStart + duration,\n                                                    mediaOffset: (clipToMove.initialBounds?.mediaOffset ?? clipToMove.mediaOffset) + deltaTime,\n                                                    mediaDuration: clipToMove.initialBounds?.mediaDuration ?? clipToMove.mediaDuration\n                                                }\n                                            };\n                                        }\n                                    });\n                                    track.clips.sort((a, b) => a.startTime - b.startTime);\n                                }\n                            }\n                        }\n                        break;\n                    }\n                    case ActionTypes.SPLIT_CLIP: {\n                        const trackToSplit = draft.tracks.find(t => t.id === action.payload.trackId);\n                        if (trackToSplit) {\n                            const clipToSplit = trackToSplit.clips.find(c => c.id === action.payload.clipId);\n                            if (clipToSplit && action.payload.time > clipToSplit.startTime && action.payload.time < clipToSplit.endTime) {\n                                const splitPoint = action.payload.time;\n                                const firstDuration = splitPoint - clipToSplit.startTime;\n                                const originalMediaOffset = clipToSplit.initialBounds?.mediaOffset ?? clipToSplit.mediaOffset;\n                                const originalMediaDuration = clipToSplit.initialBounds?.mediaDuration ?? clipToSplit.mediaDuration;\n                                const firstMediaStart = originalMediaOffset;\n                                const firstMediaEnd = originalMediaOffset + firstDuration;\n                                const secondMediaStart = originalMediaOffset + firstDuration;\n                                const fullMediaDuration = originalMediaDuration;\n                                // Remove the original clip\n                                trackToSplit.clips = trackToSplit.clips.filter(c => c.id !== clipToSplit.id);\n                                // Create clips based on type\n                                let firstClip;\n                                let secondClip;\n                                const baseProps = {\n                                    effects: clipToSplit.effects,\n                                    layer: clipToSplit.layer,\n                                    originalDuration: clipToSplit.originalDuration || clipToSplit.mediaDuration,\n                                    mediaDuration: fullMediaDuration,\n                                    handles: {\n                                        startPosition: firstMediaStart,\n                                        endPosition: firstMediaEnd\n                                    },\n                                    initialBounds: {\n                                        startTime: clipToSplit.startTime,\n                                        endTime: splitPoint,\n                                        mediaOffset: firstMediaStart,\n                                        mediaDuration: fullMediaDuration\n                                    }\n                                };\n                                const baseProps2 = {\n                                    effects: clipToSplit.effects,\n                                    layer: clipToSplit.layer,\n                                    originalDuration: clipToSplit.originalDuration || clipToSplit.mediaDuration,\n                                    mediaDuration: fullMediaDuration,\n                                    handles: {\n                                        startPosition: secondMediaStart,\n                                        endPosition: secondMediaStart + (clipToSplit.endTime - splitPoint)\n                                    },\n                                    initialBounds: {\n                                        startTime: splitPoint,\n                                        endTime: clipToSplit.endTime,\n                                        mediaOffset: secondMediaStart,\n                                        mediaDuration: fullMediaDuration\n                                    }\n                                };\n                                if (isVideoClip(clipToSplit)) {\n                                    firstClip = {\n                                        ...baseProps,\n                                        id: `${clipToSplit.id}-1`,\n                                        type: 'video',\n                                        name: clipToSplit.name,\n                                        startTime: clipToSplit.startTime,\n                                        endTime: splitPoint,\n                                        src: clipToSplit.src,\n                                        mediaOffset: firstMediaStart,\n                                        transform: clipToSplit.transform,\n                                        effects: clipToSplit.effects,\n                                        originalDuration: clipToSplit.originalDuration || clipToSplit.mediaDuration\n                                    };\n                                    secondClip = {\n                                        ...baseProps2,\n                                        id: `${clipToSplit.id}-2`,\n                                        type: 'video',\n                                        name: clipToSplit.name,\n                                        startTime: splitPoint,\n                                        endTime: clipToSplit.endTime,\n                                        src: clipToSplit.src,\n                                        mediaOffset: secondMediaStart,\n                                        transform: clipToSplit.transform,\n                                        effects: clipToSplit.effects,\n                                        originalDuration: clipToSplit.originalDuration || clipToSplit.mediaDuration\n                                    };\n                                }\n                                else if (isAudioClip(clipToSplit)) {\n                                    firstClip = {\n                                        ...baseProps,\n                                        id: `${clipToSplit.id}-1`,\n                                        type: 'audio',\n                                        name: clipToSplit.name,\n                                        startTime: clipToSplit.startTime,\n                                        endTime: splitPoint,\n                                        src: clipToSplit.src,\n                                        mediaOffset: firstMediaStart,\n                                        volume: clipToSplit.volume || 1,\n                                        isMuted: clipToSplit.isMuted || false,\n                                        effects: clipToSplit.effects,\n                                        originalDuration: clipToSplit.originalDuration || clipToSplit.mediaDuration\n                                    };\n                                    secondClip = {\n                                        ...baseProps2,\n                                        id: `${clipToSplit.id}-2`,\n                                        type: 'audio',\n                                        name: clipToSplit.name,\n                                        startTime: splitPoint,\n                                        endTime: clipToSplit.endTime,\n                                        src: clipToSplit.src,\n                                        mediaOffset: secondMediaStart,\n                                        volume: clipToSplit.volume || 1,\n                                        isMuted: clipToSplit.isMuted || false,\n                                        effects: clipToSplit.effects,\n                                        originalDuration: clipToSplit.originalDuration || clipToSplit.mediaDuration\n                                    };\n                                }\n                                else {\n                                    firstClip = {\n                                        ...baseProps,\n                                        id: `${clipToSplit.id}-1`,\n                                        type: 'caption',\n                                        name: clipToSplit.name,\n                                        startTime: clipToSplit.startTime,\n                                        endTime: splitPoint,\n                                        text: clipToSplit.text || '',\n                                        captions: clipToSplit.captions || [],\n                                        mediaOffset: firstMediaStart,\n                                        effects: clipToSplit.effects,\n                                        originalDuration: clipToSplit.originalDuration || clipToSplit.mediaDuration\n                                    };\n                                    secondClip = {\n                                        ...baseProps2,\n                                        id: `${clipToSplit.id}-2`,\n                                        type: 'caption',\n                                        name: clipToSplit.name,\n                                        startTime: splitPoint,\n                                        endTime: clipToSplit.endTime,\n                                        text: clipToSplit.text || '',\n                                        captions: clipToSplit.captions || [],\n                                        mediaOffset: secondMediaStart,\n                                        effects: clipToSplit.effects,\n                                        originalDuration: clipToSplit.originalDuration || clipToSplit.mediaDuration\n                                    };\n                                }\n                                // Log split operation\n                                logger.debug('Split operation:', {\n                                    originalClip: clipToSplit,\n                                    firstClip,\n                                    secondClip,\n                                    splitPoint,\n                                    trackId: trackToSplit.id\n                                });\n                                // Add new clips\n                                trackToSplit.clips.push(firstClip, secondClip);\n                                trackToSplit.clips.sort((a, b) => a.startTime - b.startTime);\n                                // Update ripple state\n                                if (draft.rippleState && draft.rippleState[clipToSplit.id]) {\n                                    delete draft.rippleState[clipToSplit.id];\n                                }\n                                if (!draft.rippleState) {\n                                    draft.rippleState = {};\n                                }\n                                draft.rippleState[firstClip.id] = { initialExtensionDone: false };\n                                draft.rippleState[secondClip.id] = { initialExtensionDone: false };\n                                // Update selection\n                                draft.selectedClipIds = [firstClip.id];\n                                // Notify of split completion\n                                requestAnimationFrame(() => {\n                                    window.dispatchEvent(new CustomEvent('timeline:clip-split', {\n                                        detail: {\n                                            trackId: trackToSplit.id,\n                                            originalClipId: clipToSplit.id,\n                                            splitTime: splitPoint,\n                                            firstClipId: firstClip.id,\n                                            secondClipId: secondClip.id\n                                        }\n                                    }));\n                                });\n                            }\n                        }\n                        break;\n                    }\n                    case ActionTypes.SELECT_CLIPS:\n                        draft.selectedClipIds = action.payload.clipIds;\n                        break;\n                    case ActionTypes.SET_SELECTED_TRACK_ID:\n                        draft.selectedTrackId = action.payload;\n                        break;\n                }\n            });\n            // Create a new state with the patches applied\n            const stateAfterPatches = applyPatches(state, patches);\n            // Only create history entry for undoable actions\n            if (isUndoable(action)) {\n                // Create a new state with history updates\n                const finalState = produce(stateAfterPatches, draft => {\n                    // If we've undone before, truncate future entries\n                    if (draft.history.currentIndex < draft.history.entries.length - 1) {\n                        draft.history.entries = draft.history.entries.slice(0, draft.history.currentIndex + 1);\n                    }\n                    // Create a deep copy of patches to avoid reference issues\n                    const entry = {\n                        type: 'partial',\n                        timestamp: Date.now(),\n                        patches: JSON.parse(JSON.stringify(patches)),\n                        inversePatches: JSON.parse(JSON.stringify(inversePatches)),\n                        description: getHistoryDescription(action)\n                    };\n                    // If we're at the end of history, just push\n                    if (draft.history.currentIndex === draft.history.entries.length - 1) {\n                        draft.history.entries.push(entry);\n                        draft.history.currentIndex++;\n                    }\n                    else {\n                        // Otherwise, truncate and push\n                        draft.history.entries = draft.history.entries.slice(0, draft.history.currentIndex + 1);\n                        draft.history.entries.push(entry);\n                        draft.history.currentIndex = draft.history.entries.length - 1;\n                    }\n                    // Trim history if it exceeds max size\n                    if (draft.history.entries.length > TimelineConstants.History.MAX_HISTORY_SIZE) {\n                        draft.history.entries = draft.history.entries.slice(-TimelineConstants.History.MAX_HISTORY_SIZE);\n                        draft.history.currentIndex = draft.history.entries.length - 1;\n                    }\n                });\n                logger.debug('Added history entry:', {\n                    description: getHistoryDescription(action),\n                    currentIndex: finalState.history.currentIndex,\n                    totalEntries: finalState.history.entries.length\n                });\n                // Notify of state change\n                requestAnimationFrame(() => {\n                    window.dispatchEvent(new CustomEvent('timeline:state-changed', {\n                        detail: {\n                            tracks: finalState.tracks.map(t => ({\n                                id: t.id,\n                                clipCount: t.clips.length,\n                                clips: t.clips.map(c => ({\n                                    id: c.id,\n                                    startTime: c.startTime,\n                                    endTime: c.endTime,\n                                    layer: c.layer\n                                }))\n                            }))\n                        }\n                    }));\n                });\n                return finalState;\n            }\n            return stateAfterPatches;\n        }\n    }\n};\nexport const TimelineProvider = ({ children }) => {\n    console.log('[TimelineProvider] Mounting...');\n    const [state, dispatch] = useReducer(timelineReducer, {\n        ...initialTimelineState,\n        history: {\n            entries: [],\n            currentIndex: -1\n        }\n    });\n    const [isInitialized, setIsInitialized] = React.useState(false);\n    // One-time initialization effect\n    useEffect(() => {\n        console.log('[TimelineProvider] Mounting (one-time)...');\n        try {\n            // Step 1: Dispatch initializing event\n            window.dispatchEvent(new CustomEvent('timeline:initializing'));\n            // Step 2: Set up window properties\n            window.timelineDispatch = dispatch;\n            // Step 3: Dispatch ready event\n            window.dispatchEvent(new CustomEvent('timeline:dispatchReady'));\n            // Step 4: Set ready flag and dispatch initialized event\n            window.timelineReady = true;\n        }\n        finally {\n        }\n    });\n};\n","__webpack_require__.h = () => (\"432dbd5b70f91eeea575\")"],"names":[],"sourceRoot":""}
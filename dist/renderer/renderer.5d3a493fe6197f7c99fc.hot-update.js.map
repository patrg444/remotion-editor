{"version":3,"file":"renderer.5d3a493fe6197f7c99fc.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAA8D;AACW;AACR;AACnB;AACY;AACO;AACxB;AACsB;AACxD,yBAAyB,0JAA0J;AAC1L,yBAAyB,6CAAM;AAC/B,4BAA4B,6CAAM;AAClC,YAAY,2CAA2C,EAAE,6EAAkB;AAC3E,YAAY,kBAAkB,EAAE,6EAAkB;AAClD;AACA,4BAA4B,kDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA;AACA,mDAAmD,OAAO;AAC1D,sDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,oBAAoB,iDAAM;AAC1B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;AACL,6BAA6B,kDAAW;AACxC;AACA;AACA;AACA,KAAK;AACL,4BAA4B,kDAAW;AACvC;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,2BAA2B,kDAAW;AACtC;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,4BAA4B,kDAAW;AACvC;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,uBAAuB,kDAAW;AAClC;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA;AACA;AACA;AACA,kCAAkC,uEAAiB;AACnD,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2DAAU;AACpD;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA,yBAAyB;AACzB,iCAAiC;AACjC;AACA;AACA;AACA,0CAA0C,2DAAU;AACpD;AACA;AACA;AACA;AACA,yBAAyB;AACzB,iCAAiC;AACjC;AACA;AACA;AACA,4CAA4C,2DAAU;AACtD;AACA;AACA;AACA,yBAAyB;AACzB,iCAAiC;AACjC;AACA;AACA;AACA,kEAAkE,UAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA,kCAAkC,wDAAW;AAC7C;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA,iDAAiD,WAAW,8BAA8B,UAAU;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,kDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iCAAiC,uEAAiB;AAClD,YAAY,0DAAmB,UAAU,iFAAiF,8BAA8B,EAAE,YAAY,EAAE,oCAAoC,yFAAyF,YAAY;AACjT;AACA,uBAAuB,YAAY;AACnC,WAAW;AACX,QAAQ,0DAAmB,UAAU,0HAA0H,WAAW;AAC1K;AACA;AACA;AACA,aAAa;AACb,2BAA2B,YAAY;AACvC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAmB,CAAC,mEAAkB,IAAI,mPAAmP,4DAAW,uDAAuD,4DAAW;AAClY;AACA,kCAAkC,wDAAW;AAC7C;AACA;AACA,0CAA0C;AAC1C;AACA,yBAAyB;AACzB,uBAAuB;AACvB,aAAa;AACb,+CAA+C,0DAAmB,CAAC,uDAAY,IAAI;AACnF;AACA,mBAAmB;AACnB;;;;;;;;;UC/TA","sources":["webpack://remotion-editor/./src/renderer/components/TimelineTrack.tsx","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { useCallback, useEffect, useRef } from 'react';\nimport { ActionTypes, createClip, isVideoClip } from '../types/timeline';\nimport { useTimelineContext } from '../hooks/useTimelineContext';\nimport { TimelineClip } from './TimelineClip';\nimport { TimelineTransition } from './TimelineTransition';\nimport { useLayerManagement } from '../hooks/useLayerManagement';\nimport { logger } from '../utils/logger';\nimport { TimelineConstants } from '../utils/timelineConstants';\nexport const TimelineTrack = ({ track, isSelected, zoom, fps, onSelectTrack, onSelectClip, onClipDragStart, onClipDragEnd, onToggleVisibility, onUpdateTrack, onDeleteTrack, onMoveTrack }) => {\n    const containerRef = useRef(null);\n    const trackContentRef = useRef(null);\n    const { assignLayers, getTrackHeight, getClipTop } = useLayerManagement();\n    const { state, dispatch } = useTimelineContext();\n    // Get clips with optimized layer assignments and notify track ready\n    const clipsWithLayers = useCallback(() => {\n        const layeredClips = assignLayers(track.clips, track);\n        // Notify that track is ready with current clip count\n        requestAnimationFrame(() => {\n            window.dispatchEvent(new CustomEvent('track:ready', {\n                detail: {\n                    trackId: track.id,\n                    clipCount: layeredClips.length,\n                    clips: layeredClips.map(c => ({\n                        id: c.id,\n                        startTime: c.startTime,\n                        endTime: c.endTime,\n                        layer: c.layer\n                    }))\n                }\n            }));\n        });\n        return layeredClips;\n    }, [track, assignLayers]);\n    // Handle clip updates\n    useEffect(() => {\n        const handleClipRendered = (e) => {\n            const { clipId } = e.detail;\n            if (track.clips.some(c => c.id === clipId)) {\n                requestAnimationFrame(() => {\n                    window.dispatchEvent(new CustomEvent('track:ready', {\n                        detail: {\n                            trackId: track.id,\n                            clipCount: track.clips.length,\n                            clips: track.clips.map(c => ({\n                                id: c.id,\n                                startTime: c.startTime,\n                                endTime: c.endTime,\n                                layer: c.layer\n                            }))\n                        }\n                    }));\n                });\n            }\n        };\n        window.addEventListener('clip:rendered', handleClipRendered);\n        return () => {\n            window.removeEventListener('clip:rendered', handleClipRendered);\n        };\n    }, [track.id, track.clips]);\n    // Handle track updates and positioning\n    useEffect(() => {\n        if (containerRef.current && trackContentRef.current) {\n            const height = getTrackHeight(clipsWithLayers());\n            containerRef.current.style.height = `${height}px`;\n            trackContentRef.current.style.height = `${height}px`;\n            // Force reflow to ensure height is applied\n            void containerRef.current.offsetHeight;\n            void trackContentRef.current.offsetHeight;\n            // Notify that track is ready\n            window.dispatchEvent(new CustomEvent('track:ready', {\n                detail: {\n                    trackId: track.id,\n                    height,\n                    clipCount: track.clips.length\n                }\n            }));\n            // Wait for next frame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                if (containerRef.current && trackContentRef.current) {\n                    // Get final dimensions after styles are applied\n                    const containerRect = containerRef.current.getBoundingClientRect();\n                    const contentRect = trackContentRef.current.getBoundingClientRect();\n                    // Notify that track is positioned\n                    window.dispatchEvent(new CustomEvent('track:positioned', {\n                        detail: {\n                            trackId: track.id,\n                            containerHeight: containerRect.height,\n                            contentHeight: contentRect.height,\n                            clipCount: track.clips.length\n                        }\n                    }));\n                    logger.debug('[TimelineTrack] Track positioned:', {\n                        trackId: track.id,\n                        containerRect,\n                        contentRect,\n                        clipCount: track.clips.length\n                    });\n                }\n            });\n        }\n    }, [track.id, track.clips.length, clipsWithLayers, getTrackHeight]);\n    const handleTrackClick = useCallback((e) => {\n        if (e.currentTarget === e.target) {\n            onSelectTrack(track.id);\n        }\n    }, [track.id, onSelectTrack]);\n    const handleDragEnter = useCallback((e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        logger.debug('Track drag enter:', {\n            target: e.target,\n            currentTarget: e.currentTarget,\n            className: e.currentTarget.className\n        });\n        e.currentTarget.classList.add('drag-over');\n    }, []);\n    const handleDragOver = useCallback((e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        logger.debug('Track drag over:', {\n            target: e.target,\n            currentTarget: e.currentTarget,\n            className: e.currentTarget.className\n        });\n        e.currentTarget.classList.add('drag-over');\n    }, []);\n    const handleDragLeave = useCallback((e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        logger.debug('Track drag leave:', {\n            target: e.target,\n            currentTarget: e.currentTarget,\n            className: e.currentTarget.className\n        });\n        e.currentTarget.classList.remove('drag-over');\n    }, []);\n    const handleDrop = useCallback((e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        e.currentTarget.classList.remove('drag-over');\n        try {\n            logger.debug('Drop event:', {\n                types: e.dataTransfer.types,\n                data: e.dataTransfer.getData('application/json'),\n                target: e.currentTarget.className,\n                currentTarget: e.currentTarget.className,\n                clientX: e.clientX,\n                clientY: e.clientY\n            });\n            const jsonData = e.dataTransfer.getData('application/json');\n            if (!jsonData) {\n                logger.error('No JSON data in drop event');\n                return;\n            }\n            const data = JSON.parse(jsonData);\n            logger.debug('Parsed drop data:', data);\n            if (data) {\n                // Calculate time position based on drop coordinates\n                const trackRect = e.currentTarget.getBoundingClientRect();\n                const dropX = e.clientX - trackRect.left;\n                const timeScale = TimelineConstants.Scale.getScale(state.zoom);\n                const startTime = Math.max(0, (dropX + state.scrollX) / timeScale); // Convert to time, accounting for scroll\n                // Create clip using helper\n                let clip;\n                // Create clip with proper duration properties\n                const initialDuration = data.duration;\n                const baseProps = {\n                    name: data.name,\n                    startTime,\n                    endTime: startTime + initialDuration,\n                    mediaOffset: 0,\n                    mediaDuration: initialDuration,\n                    originalDuration: initialDuration,\n                    initialDuration: initialDuration,\n                    effects: []\n                };\n                switch (data.type) {\n                    case 'video': {\n                        const videoClip = createClip('video', {\n                            ...baseProps,\n                            src: data.path,\n                            transform: {\n                                scale: 1,\n                                rotation: 0,\n                                position: { x: 0, y: 0 },\n                                opacity: 1\n                            }\n                        });\n                        clip = { ...videoClip, layer: 0 };\n                        break;\n                    }\n                    case 'audio': {\n                        const audioClip = createClip('audio', {\n                            ...baseProps,\n                            src: data.path,\n                            volume: 1,\n                            isMuted: false\n                        });\n                        clip = { ...audioClip, layer: 0 };\n                        break;\n                    }\n                    case 'caption': {\n                        const captionClip = createClip('caption', {\n                            ...baseProps,\n                            text: '',\n                            captions: []\n                        });\n                        clip = { ...captionClip, layer: 0 };\n                        break;\n                    }\n                    default:\n                        throw new Error(`Unsupported clip type: ${data.type}`);\n                }\n                // Ensure track type matches clip type\n                if ((track.type === 'video' && data.type === 'video') ||\n                    (track.type === 'audio' && data.type === 'audio') ||\n                    (track.type === 'caption' && data.type === 'caption')) {\n                    // Update track with new clip\n                    const updatedClips = [...(track.clips || []), clip];\n                    onUpdateTrack(track.id, { clips: updatedClips });\n                    // Update timeline duration if needed\n                    const maxEndTime = Math.max(...updatedClips.map(c => c.endTime));\n                    if (maxEndTime > state.duration) {\n                        dispatch({\n                            type: ActionTypes.SET_DURATION,\n                            payload: Math.max(maxEndTime, 10)\n                        });\n                    }\n                    // Wait for next frame to ensure clip is added\n                    requestAnimationFrame(() => {\n                        // Notify that clip was added\n                        window.dispatchEvent(new CustomEvent('track:clip-added', {\n                            detail: {\n                                trackId: track.id,\n                                clipId: clip.id,\n                                startTime,\n                                endTime: startTime + initialDuration\n                            }\n                        }));\n                    });\n                }\n                else {\n                    console.error(`Track type (${track.type}) does not match clip type (${data.type})`);\n                    return;\n                }\n            }\n        }\n        catch (error) {\n            console.error('Error handling drop:', error);\n        }\n    }, [track.id, track.clips, onUpdateTrack, state, dispatch, state.zoom]);\n    const handleKeyDown = useCallback((e) => {\n        switch (e.key) {\n            case 'Enter':\n            case ' ':\n                e.preventDefault();\n                onSelectTrack(track.id);\n                break;\n            case 'ArrowUp':\n                e.preventDefault();\n                // Focus previous track\n                const prevTrack = containerRef.current?.previousElementSibling;\n                if (prevTrack instanceof HTMLElement) {\n                    prevTrack.focus();\n                }\n                break;\n            case 'ArrowDown':\n                e.preventDefault();\n                // Focus next track\n                const nextTrack = containerRef.current?.nextElementSibling;\n                if (nextTrack instanceof HTMLElement) {\n                    nextTrack.focus();\n                }\n                break;\n            case 'Tab':\n                // Let default tab behavior work, but ensure clips are in tab order\n                if (e.shiftKey && isSelected) {\n                    // When shift+tab on selected track, focus last clip\n                    const clips = containerRef.current?.querySelectorAll('.timeline-clip');\n                    const lastClip = clips?.[clips.length - 1];\n                    if (lastClip instanceof HTMLElement) {\n                        e.preventDefault();\n                        lastClip.focus();\n                    }\n                }\n                break;\n        }\n    }, [track.id, onSelectTrack, isSelected]);\n    const layeredClips = clipsWithLayers();\n    const trackHeight = Math.max(TimelineConstants.UI.TRACK_HEIGHT, getTrackHeight(layeredClips));\n    return (React.createElement(\"div\", { ref: containerRef, \"data-testid\": \"timeline-track\", className: `timeline-track ${isSelected ? 'selected' : ''} ${track.type} ${!track.clips?.length ? 'empty' : ''}`, onClick: handleTrackClick, onKeyDown: handleKeyDown, role: \"region\", \"aria-label\": `${track.name} track`, \"aria-selected\": isSelected, tabIndex: 0, style: {\n            opacity: track.isVisible ? 1 : 0.5,\n            height: `${trackHeight}px`\n        } },\n        React.createElement(\"div\", { ref: trackContentRef, \"data-testid\": \"track-content\", className: \"track-content\", role: \"list\", \"aria-label\": `Clips in ${track.name}`, onDragEnter: handleDragEnter, onDragOver: handleDragOver, onDragLeave: handleDragLeave, onDrop: handleDrop, onMouseDown: (e) => {\n                if (e.target === e.currentTarget) {\n                    handleTrackClick(e);\n                }\n            }, style: {\n                height: `${trackHeight}px`\n            } },\n            track.transitions?.map((transition) => {\n                const clipA = layeredClips.find(c => c.id === transition.clipAId);\n                const clipB = layeredClips.find(c => c.id === transition.clipBId);\n                if (!clipA || !clipB)\n                    return null;\n                return (React.createElement(TimelineTransition, { key: transition.id, id: transition.id, type: transition.type, startTime: clipA.endTime - transition.duration, endTime: clipB.startTime + transition.duration, duration: transition.duration, clipAId: clipA.id, clipBId: clipB.id, clipAThumbnail: isVideoClip(clipA) ? clipA.thumbnail : undefined, clipBThumbnail: isVideoClip(clipB) ? clipB.thumbnail : undefined, direction: transition.params?.direction, onDurationChange: (newDuration) => {\n                        dispatch({\n                            type: ActionTypes.UPDATE_TRANSITION,\n                            payload: {\n                                transitionId: transition.id,\n                                params: { duration: newDuration }\n                            }\n                        });\n                    } }));\n            }),\n            layeredClips.map((clip, index) => (React.createElement(TimelineClip, { key: clip.id, clip: clip, track: track, layer: clip.layer, zoom: state.zoom, fps: state.fps, onSelect: () => onSelectClip(clip.id), onDragStart: () => onClipDragStart(clip.id), onDragEnd: onClipDragEnd, tabIndex: isSelected ? 0 : -1, \"aria-posinset\": index + 1, \"aria-setsize\": layeredClips.length, style: {\n                    top: getClipTop(clip.layer)\n                } }))))));\n};\n","__webpack_require__.h = () => (\"b6c13f8f065c57b4449d\")"],"names":[],"sourceRoot":""}
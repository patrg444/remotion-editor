{"version":3,"file":"renderer.432dbd5b70f91eeea575.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;AAAgF;AACvB;AAChB;AAC2B;AAC7D,wBAAwB,oDAAa;AAC5C;AACO,4BAA4B,UAAU;AAC7C;AACA,8BAA8B,iDAAU;AACxC,WAAW,iEAAoB;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL,8CAA8C,qDAAc;AAC5D;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA,0BAA0B;AAC1B,aAAa;AACb;AACA,KAAK,OAAO;AACZ;AACA,QAAQ,IAAuE;AAC/E,QAAQ,gDAAS;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,IAAI,gDAAS;AACb;AACA,qCAAqC,gFAAqB;AAC1D;AACA,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA,KAAK;AACL,YAAY,0DAAmB,6BAA6B,SAAS,mBAAmB;AACxF;AACO;AACP,oBAAoB,iDAAU;AAC9B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,8CAA8C,OAAO;AACrD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;UChFA","sources":["webpack://remotion-editor/./src/renderer/contexts/TimelineContext.tsx","webpack://remotion-editor/./src/renderer/utils/timelineValidation.ts","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { createContext, useReducer, useContext, useEffect } from 'react';\nimport { initialTimelineState } from '../types/timeline';\nimport { logger } from '../utils/logger';\nimport { validateTimelineState } from '../utils/timelineValidation';\nexport const TimelineContext = createContext(undefined);\n// ... (previous code remains the same until TimelineProvider)\nexport const TimelineProvider = ({ children }) => {\n    console.log('[TimelineProvider] Mounting...');\n    const [state, dispatch] = useReducer(timelineReducer, {\n        ...initialTimelineState,\n        history: {\n            entries: [],\n            currentIndex: -1\n        }\n    });\n    const [isInitialized, setIsInitialized] = React.useState(false);\n    // One-time initialization effect\n    useEffect(() => {\n        console.log('[TimelineProvider] Mounting (one-time)...');\n        try {\n            // Step 1: Dispatch initializing event\n            window.dispatchEvent(new CustomEvent('timeline:initializing'));\n            // Step 2: Set up window properties\n            window.timelineDispatch = dispatch;\n            window.timelineState = state;\n            // Step 3: Dispatch ready event\n            window.dispatchEvent(new CustomEvent('timeline:dispatchReady'));\n            // Step 4: Set ready flag and dispatch initialized event\n            window.timelineReady = true;\n            window.dispatchEvent(new CustomEvent('timeline:initialized'));\n            setIsInitialized(true);\n            logger.debug('[Timeline] Initialization complete');\n            // No cleanup to avoid race conditions\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            logger.error('[TimelineProvider] Error initializing timeline:', new Error(errorMessage));\n            window.dispatchEvent(new CustomEvent('timeline:error', {\n                detail: { error: new Error(errorMessage) }\n            }));\n        }\n    }, []); // Empty deps array for one-time initialization\n    // Optional sync effect for development/testing\n    if (process.env.NODE_ENV !== 'production' || process.env.CYPRESS === 'true') {\n        useEffect(() => {\n            // Keep window.timelineState and window.timelineDispatch separate\n            window.timelineState = state;\n            window.timelineDispatch = dispatch;\n        }, [state, dispatch]);\n    }\n    // Separate effect for state validation\n    useEffect(() => {\n        try {\n            const validationErrors = validateTimelineState(state);\n            if (validationErrors.length > 0) {\n                logger.warn('[Timeline] State validation errors:', validationErrors);\n            }\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            logger.error('[Timeline] State validation failed:', new Error(errorMessage));\n        }\n    }, [state]);\n    return (React.createElement(TimelineContext.Provider, { value: { state, dispatch } }, children));\n};\nexport const useTimelineContext = () => {\n    const context = useContext(TimelineContext);\n    if (!context) {\n        throw new Error('useTimelineContext must be used within a TimelineProvider');\n    }\n    return context;\n};\n","/**\n * Validates the timeline state structure and returns any validation errors\n */\nexport function validateTimelineState(state) {\n    const errors = [];\n    // Check required properties\n    if (!state) {\n        errors.push('Timeline state is undefined');\n        return errors;\n    }\n    // Check tracks array\n    if (!Array.isArray(state.tracks)) {\n        errors.push('Tracks must be an array');\n    }\n    else {\n        // Validate each track\n        state.tracks.forEach((track, index) => {\n            if (!track.id) {\n                errors.push(`Track at index ${index} is missing id`);\n            }\n            if (!track.name) {\n                errors.push(`Track at index ${index} is missing name`);\n            }\n            if (!track.type) {\n                errors.push(`Track at index ${index} is missing type`);\n            }\n            if (!Array.isArray(track.clips)) {\n                errors.push(`Track at index ${index} clips must be an array`);\n            }\n        });\n    }\n    // Check numeric properties\n    if (typeof state.currentTime !== 'number') {\n        errors.push('currentTime must be a number');\n    }\n    if (typeof state.duration !== 'number') {\n        errors.push('duration must be a number');\n    }\n    if (typeof state.zoom !== 'number') {\n        errors.push('zoom must be a number');\n    }\n    if (typeof state.fps !== 'number') {\n        errors.push('fps must be a number');\n    }\n    if (typeof state.scrollX !== 'number') {\n        errors.push('scrollX must be a number');\n    }\n    if (typeof state.scrollY !== 'number') {\n        errors.push('scrollY must be a number');\n    }\n    // Check boolean properties\n    if (typeof state.isPlaying !== 'boolean') {\n        errors.push('isPlaying must be a boolean');\n    }\n    if (typeof state.isDragging !== 'boolean') {\n        errors.push('isDragging must be a boolean');\n    }\n    // Check arrays\n    if (!Array.isArray(state.selectedClipIds)) {\n        errors.push('selectedClipIds must be an array');\n    }\n    if (!Array.isArray(state.selectedCaptionIds)) {\n        errors.push('selectedCaptionIds must be an array');\n    }\n    if (!Array.isArray(state.markers)) {\n        errors.push('markers must be an array');\n    }\n    // Check history\n    if (!state.history) {\n        errors.push('history is missing');\n    }\n    else {\n        if (!Array.isArray(state.history.entries)) {\n            errors.push('history.entries must be an array');\n        }\n        if (typeof state.history.currentIndex !== 'number') {\n            errors.push('history.currentIndex must be a number');\n        }\n    }\n    return errors;\n}\n","__webpack_require__.h = () => (\"749ef314730fe634b5a1\")"],"names":[],"sourceRoot":""}
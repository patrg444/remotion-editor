{"version":3,"file":"renderer.9db80ae8a756d72ddffb.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAwE;AACI;AAChB;AACA;AACI;AACZ;AACE;AACS;AACR;AACU;AACd;AACI;AACH;AACpD;AACA;AACA;AACA;AACO,wBAAwB,0IAA0I;AACzK,wDAAwD,+CAAQ;AAChE,sCAAsC,+CAAQ;AAC9C,wCAAwC,+CAAQ;AAChD,wCAAwC,+CAAQ;AAChD,oCAAoC,+CAAQ;AAC5C,YAAY,2BAA2B,EAAE,mEAAa;AACtD,YAAY,kBAAkB,EAAE,6EAAkB;AAClD,qBAAqB,gEAAW;AAChC,YAAY,yCAAyC,EAAE,oEAAa;AACpE,oBAAoB,6CAAM;AAC1B;AACA,0BAA0B,6CAAM;AAChC,yBAAyB,6CAAM,GAAG,sEAAsE;AACxG;AACA,+BAA+B,gEAAU,mBAAmB,uBAAuB;AACnF,6BAA6B,gEAAU,iBAAiB,uBAAuB;AAC/E,8BAA8B,gEAAU,kCAAkC,uBAAuB;AACjG;AACA;AACA;AACA;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAY;AACrC,0BAA0B,kEAAY;AACtC,gCAAgC,uEAAiB;AACjD;AACA;AACA,4CAA4C,iBAAiB;AAC7D,6CAA6C,kBAAkB;AAC/D,2CAA2C,IAAI;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,kDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,kDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,4DAAW;AACvB,oBAAoB,0DAAmB,CAAC,qEAAgB,IAAI,0DAA0D;AACtH;AACA,YAAY,4DAAW;AACvB,oBAAoB,0DAAmB,CAAC,qEAAgB,IAAI,0DAA0D;AACtH;AACA,YAAY,8DAAa;AACzB,oBAAoB,0DAAmB,CAAC,yEAAkB,IAAI,0DAA0D;AACxH;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW,kEAAY,wBAAwB;AAChE,kBAAkB,WAAW,kEAAY,uCAAuC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAmB,UAAU,0EAA0E,WAAW,EAAE,+CAA+C,EAAE,6BAA6B,oHAAoH,WAAW,YAAY,oBAAoB,KAAK,iBAAiB,aAAa,kBAAkB,qaAAqa;AACv0B,sBAAsB,0DAAmB,CAAC,8DAAe,IAAI,gBAAgB;AAC7E,QAAQ,0DAAmB,UAAU;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,QAAQ,0DAAmB,UAAU;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,QAAQ,0DAAmB,UAAU,4BAA4B;AACjE;AACA,kDAAkD,0DAAmB,WAAW,SAAS,wEAAwE;AACjK;AACA,gBAAgB,gEAAU,uBAAuB,uBAAuB;AACxE;AACA;;;;;;;;;UC5LA","sources":["webpack://remotion-editor/./src/renderer/components/TimelineClip.tsx","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { useCallback, useState, useRef, useEffect } from 'react';\nimport { isVideoClip, isAudioClip, isCaptionClip } from '../types/timeline';\nimport { VideoClipContent } from './clips/VideoClipContent';\nimport { AudioClipContent } from './clips/AudioClipContent';\nimport { CaptionClipContent } from './clips/CaptionClipContent';\nimport { formatTime } from '../utils/timelineUnits';\nimport { timeToPixels } from '../utils/timelineScale';\nimport { TimelineConstants } from '../utils/timelineConstants';\nimport { useRippleEdit } from '../hooks/useRippleEdit';\nimport { useTimelineContext } from '../hooks/useTimelineContext';\nimport { useTimeline } from '../hooks/useTimeline';\nimport { useSnapPoints } from '../hooks/useSnapPoints';\nimport { TrimModeTooltip } from './TrimModeTooltip';\nconst KEYBOARD_MOVE_STEP = 1;\nconst KEYBOARD_MOVE_FAST = 10;\nconst TRACK_LABEL_WIDTH = 160;\nconst SNAP_THRESHOLD = 5;\nexport const TimelineClip = ({ clip, track, layer, zoom, fps, onSelect, onDragStart, onDragEnd, tabIndex = 0, 'aria-posinset': posinset, 'aria-setsize': setsize, style }) => {\n    const [isKeyboardDragging, setIsKeyboardDragging] = useState(false);\n    const [isAtLimit, setIsAtLimit] = useState(false);\n    const [isDragging, setIsDragging] = useState(false);\n    const [isTrimming, setIsTrimming] = useState(null);\n    const [trimMode, setTrimMode] = useState('normal');\n    const { rippleDelete, rippleTrim } = useRippleEdit();\n    const { state, dispatch } = useTimelineContext();\n    const timeline = useTimeline();\n    const { getAllSnapPoints, findNearestSnapPoint } = useSnapPoints(fps);\n    const clipRef = useRef(null);\n    // Track emissions to handle Strict Mode double-mounting\n    const hasEmittedRef = useRef(false);\n    const lastPropsRef = useRef({ id: clip.id, startTime: clip.startTime, endTime: clip.endTime, layer });\n    // Format times for display\n    const startTimeFormatted = formatTime(clip.startTime, { fps, showFrames: true });\n    const endTimeFormatted = formatTime(clip.endTime, { fps, showFrames: true });\n    const durationFormatted = formatTime(clip.endTime - clip.startTime, { fps, showFrames: true });\n    const clipDuration = clip.endTime - clip.startTime;\n    // Check if clip is selected\n    const isSelected = state.selectedClipIds?.includes(clip.id) ?? false;\n    // Emit clip events when mounted, positioned, or updated\n    useEffect(() => {\n        const propsChanged = lastPropsRef.current.id !== clip.id ||\n            lastPropsRef.current.startTime !== clip.startTime ||\n            lastPropsRef.current.endTime !== clip.endTime ||\n            lastPropsRef.current.layer !== layer;\n        if (propsChanged) {\n            hasEmittedRef.current = false;\n            lastPropsRef.current = { id: clip.id, startTime: clip.startTime, endTime: clip.endTime, layer };\n        }\n        if (!hasEmittedRef.current && clipRef.current) {\n            // Force a reflow to ensure styles are applied\n            void clipRef.current.offsetHeight;\n            // Calculate position and dimensions\n            const left = timeToPixels(clip.startTime, zoom);\n            const width = timeToPixels(clip.endTime - clip.startTime, zoom);\n            const top = layer * TimelineConstants.UI.TRACK_HEIGHT;\n            // Update styles\n            clipRef.current.style.transition = 'none';\n            clipRef.current.style.left = `${Math.round(left)}px`;\n            clipRef.current.style.width = `${Math.round(width)}px`;\n            clipRef.current.style.top = `${top}px`;\n            // Force another reflow\n            void clipRef.current.offsetHeight;\n            clipRef.current.style.transition = '';\n            // Dispatch rendered event\n            window.dispatchEvent(new CustomEvent('clip:rendered', {\n                detail: {\n                    clipId: clip.id,\n                    startTime: clip.startTime,\n                    endTime: clip.endTime,\n                    layer,\n                    left,\n                    width,\n                    top\n                }\n            }));\n            // Wait for next frame to ensure styles are applied\n            requestAnimationFrame(() => {\n                if (!clipRef.current)\n                    return;\n                // Get final position after styles are applied\n                const rect = clipRef.current.getBoundingClientRect();\n                // Dispatch positioned event\n                window.dispatchEvent(new CustomEvent('clip:positioned', {\n                    detail: {\n                        clipId: clip.id,\n                        left: rect.left,\n                        width: rect.width,\n                        top: rect.top\n                    }\n                }));\n                hasEmittedRef.current = true;\n            });\n        }\n        return () => {\n            // Reset emission flag on cleanup only if props changed\n            if (propsChanged) {\n                hasEmittedRef.current = false;\n            }\n        };\n    }, [clip.id, clip.startTime, clip.endTime, layer, zoom]);\n    const handlePointerDown = useCallback((e, trimSide) => {\n        e.preventDefault();\n        e.stopPropagation();\n        const target = e.currentTarget;\n        target.setPointerCapture(e.pointerId);\n        const isTrimmingMode = trimSide ? (trimSide === 'trim-start' ? 'start' : 'end') : null;\n        setIsDragging(!isTrimmingMode);\n        setIsTrimming(isTrimmingMode);\n        onSelect();\n        onDragStart();\n    }, [onSelect, onDragStart]);\n    const handleKeyDown = useCallback((e) => {\n        switch (e.key) {\n            case 'Enter':\n            case ' ':\n                e.preventDefault();\n                onSelect();\n                break;\n            case 'Delete':\n            case 'Backspace':\n                e.preventDefault();\n                rippleDelete(clip, track);\n                break;\n        }\n    }, [onSelect, rippleDelete, clip, track]);\n    const renderClipContent = () => {\n        if (isVideoClip(clip)) {\n            return (React.createElement(VideoClipContent, { clip: clip, isSelected: isSelected, zoom: zoom, fps: fps }));\n        }\n        if (isAudioClip(clip)) {\n            return (React.createElement(AudioClipContent, { clip: clip, isSelected: isSelected, zoom: zoom, fps: fps }));\n        }\n        if (isCaptionClip(clip)) {\n            return (React.createElement(CaptionClipContent, { clip: clip, isSelected: isSelected, zoom: zoom, fps: fps }));\n        }\n        return null;\n    };\n    const clipStyle = {\n        position: 'absolute',\n        left: `${Math.round(timeToPixels(clip.startTime, zoom))}px`,\n        width: `${Math.round(timeToPixels(clip.endTime - clip.startTime, zoom))}px`,\n        height: '100%',\n        cursor: isKeyboardDragging ? 'move' : isDragging ? 'grabbing' : 'grab',\n        top: style?.top,\n        willChange: isDragging ? 'transform' : undefined,\n        touchAction: 'none',\n        userSelect: 'none',\n        pointerEvents: 'auto',\n        zIndex: isDragging || isTrimming ? 100 : 1,\n        opacity: clipDuration > clip.mediaDuration ? 0.7 : 1\n    };\n    return (React.createElement(\"div\", { ref: clipRef, \"data-testid\": \"timeline-clip\", className: `timeline-clip ${clip.type} ${isKeyboardDragging ? 'keyboard-dragging' : ''} ${isSelected ? 'selected' : ''}`, style: clipStyle, onPointerDown: handlePointerDown, onKeyDown: handleKeyDown, role: \"listitem\", \"aria-label\": `${clip.name} clip from ${startTimeFormatted} to ${endTimeFormatted}, duration ${durationFormatted}`, \"aria-grabbed\": isKeyboardDragging, \"aria-dropeffect\": \"move\", tabIndex: tabIndex, \"aria-posinset\": posinset, \"aria-setsize\": setsize, \"data-clip-id\": clip.id, \"data-moving\": isDragging || isTrimming ? 'true' : undefined, \"data-trimming\": isTrimming || undefined, \"data-at-limit\": isAtLimit || (clip.endTime - clip.startTime) > clip.mediaDuration || undefined, \"data-trim-mode\": trimMode, \"data-selected\": isSelected },\n        isTrimming && React.createElement(TrimModeTooltip, { mode: trimMode }),\n        React.createElement(\"div\", { className: \"clip-handle left clip-trim-start\", onPointerDown: (e) => {\n                e.stopPropagation();\n                handlePointerDown(e, 'trim-start');\n            }, style: {\n                position: 'absolute',\n                left: -8,\n                width: 16,\n                height: '100%',\n                cursor: 'col-resize',\n                zIndex: 10,\n                background: 'rgba(255, 255, 255, 0.1)',\n                opacity: 0,\n                transition: 'opacity 0.15s ease'\n            } }),\n        renderClipContent(),\n        React.createElement(\"div\", { className: \"clip-handle right clip-trim-end\", onPointerDown: (e) => {\n                e.stopPropagation();\n                handlePointerDown(e, 'trim-end');\n            }, style: {\n                position: 'absolute',\n                right: -8,\n                width: 16,\n                height: '100%',\n                cursor: 'col-resize',\n                zIndex: 10,\n                background: 'rgba(255, 255, 255, 0.1)',\n                opacity: 0,\n                transition: 'opacity 0.15s ease'\n            } }),\n        React.createElement(\"div\", { className: \"clip-duration\" },\n            durationFormatted,\n            clipDuration > clip.mediaDuration && (React.createElement(\"span\", { style: { fontSize: '0.8em', opacity: 0.7, marginLeft: '4px', color: '#ff6b6b' } },\n                \"(\",\n                formatTime(clip.mediaDuration, { fps, showFrames: true }),\n                \" source)\")))));\n};\n","__webpack_require__.h = () => (\"df9c30e95fd002d69652\")"],"names":[],"sourceRoot":""}
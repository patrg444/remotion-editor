{"version":3,"file":"renderer.9e9e063007e23f06f9ac.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAA2D;AACP;AACE;AACS;AACR;AACU;AACd;AACI;AACH;AACpD;AACA;AACA;AACA;AACO,wBAAwB,0IAA0I;AACzK,wDAAwD,+CAAQ;AAChE,sCAAsC,+CAAQ;AAC9C,wCAAwC,+CAAQ;AAChD,wCAAwC,+CAAQ;AAChD,oCAAoC,+CAAQ;AAC5C,YAAY,2BAA2B,EAAE,mEAAa;AACtD,YAAY,kBAAkB,EAAE,6EAAkB;AAClD,qBAAqB,+DAAW;AAChC,YAAY,yCAAyC,EAAE,mEAAa;AACpE,oBAAoB,6CAAM;AAC1B;AACA,0BAA0B,6CAAM;AAChC,yBAAyB,6CAAM,GAAG,sEAAsE;AACxG;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAY;AACrC,0BAA0B,kEAAY;AACtC,gCAAgC,uEAAiB;AACjD;AACA;AACA,4CAA4C,iBAAiB;AAC7D,6CAA6C,kBAAkB;AAC/D,2CAA2C,IAAI;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,0DAAmB,UAAU,0EAA0E,WAAW,EAAE,+CAA+C,EAAE,0DAA0D,oHAAoH,WAAW,YAAY,oBAAoB,KAAK,iBAAiB,aAAa,kBAAkB,wYAAwY;AACv0B,sBAAsB,0DAAmB,CAAC,6DAAe,IAAI,gBAAgB;AAC7E,QAAQ,0DAAmB,UAAU;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,QAAQ,0DAAmB,UAAU;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,QAAQ,0DAAmB,UAAU,4BAA4B;AACjE;AACA,kDAAkD,0DAAmB,WAAW,SAAS,wEAAwE;AACjK;AACA,gBAAgB,gEAAU,uBAAuB,uBAAuB;AACxE;AACA;;;;;;;;;UChIA","sources":["webpack://remotion-editor/./src/renderer/components/TimelineClip.tsx","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\nimport { formatTime } from '../utils/timelineUnits';\nimport { timeToPixels } from '../utils/timelineScale';\nimport { TimelineConstants } from '../utils/timelineConstants';\nimport { useRippleEdit } from '../hooks/useRippleEdit';\nimport { useTimelineContext } from '../hooks/useTimelineContext';\nimport { useTimeline } from '../hooks/useTimeline';\nimport { useSnapPoints } from '../hooks/useSnapPoints';\nimport { TrimModeTooltip } from './TrimModeTooltip';\nconst KEYBOARD_MOVE_STEP = 1;\nconst KEYBOARD_MOVE_FAST = 10;\nconst TRACK_LABEL_WIDTH = 160;\nconst SNAP_THRESHOLD = 5;\nexport const TimelineClip = ({ clip, track, layer, zoom, fps, onSelect, onDragStart, onDragEnd, tabIndex = 0, 'aria-posinset': posinset, 'aria-setsize': setsize, style }) => {\n    const [isKeyboardDragging, setIsKeyboardDragging] = useState(false);\n    const [isAtLimit, setIsAtLimit] = useState(false);\n    const [isDragging, setIsDragging] = useState(false);\n    const [isTrimming, setIsTrimming] = useState(null);\n    const [trimMode, setTrimMode] = useState('normal');\n    const { rippleDelete, rippleTrim } = useRippleEdit();\n    const { state, dispatch } = useTimelineContext();\n    const timeline = useTimeline();\n    const { getAllSnapPoints, findNearestSnapPoint } = useSnapPoints(fps);\n    const clipRef = useRef(null);\n    // Track emissions to handle Strict Mode double-mounting\n    const hasEmittedRef = useRef(false);\n    const lastPropsRef = useRef({ id: clip.id, startTime: clip.startTime, endTime: clip.endTime, layer });\n    // Emit clip events when mounted, positioned, or updated\n    useEffect(() => {\n        const propsChanged = lastPropsRef.current.id !== clip.id ||\n            lastPropsRef.current.startTime !== clip.startTime ||\n            lastPropsRef.current.endTime !== clip.endTime ||\n            lastPropsRef.current.layer !== layer;\n        if (propsChanged) {\n            hasEmittedRef.current = false;\n            lastPropsRef.current = { id: clip.id, startTime: clip.startTime, endTime: clip.endTime, layer };\n        }\n        if (!hasEmittedRef.current && clipRef.current) {\n            // Force a reflow to ensure styles are applied\n            void clipRef.current.offsetHeight;\n            // Calculate position and dimensions\n            const left = timeToPixels(clip.startTime, zoom);\n            const width = timeToPixels(clip.endTime - clip.startTime, zoom);\n            const top = layer * TimelineConstants.UI.TRACK_HEIGHT;\n            // Update styles\n            clipRef.current.style.transition = 'none';\n            clipRef.current.style.left = `${Math.round(left)}px`;\n            clipRef.current.style.width = `${Math.round(width)}px`;\n            clipRef.current.style.top = `${top}px`;\n            // Force another reflow\n            void clipRef.current.offsetHeight;\n            clipRef.current.style.transition = '';\n            // Dispatch rendered event\n            window.dispatchEvent(new CustomEvent('clip:rendered', {\n                detail: {\n                    clipId: clip.id,\n                    startTime: clip.startTime,\n                    endTime: clip.endTime,\n                    layer,\n                    left,\n                    width,\n                    top\n                }\n            }));\n            // Wait for next frame to ensure styles are applied\n            requestAnimationFrame(() => {\n                if (!clipRef.current)\n                    return;\n                // Get final position after styles are applied\n                const rect = clipRef.current.getBoundingClientRect();\n                // Dispatch positioned event\n                window.dispatchEvent(new CustomEvent('clip:positioned', {\n                    detail: {\n                        clipId: clip.id,\n                        left: rect.left,\n                        width: rect.width,\n                        top: rect.top\n                    }\n                }));\n                hasEmittedRef.current = true;\n            });\n        }\n        return () => {\n            // Reset emission flag on cleanup only if props changed\n            if (propsChanged) {\n                hasEmittedRef.current = false;\n            }\n        };\n    }, [clip.id, clip.startTime, clip.endTime, layer, zoom]);\n    // Rest of the component implementation...\n    // (Previous implementation remains the same)\n    return (React.createElement(\"div\", { ref: clipRef, \"data-testid\": \"timeline-clip\", className: `timeline-clip ${clip.type} ${isKeyboardDragging ? 'keyboard-dragging' : ''} ${state.selectedClipIds.includes(clip.id) ? 'selected' : ''}`, style: clipStyle, onPointerDown: handlePointerDown, onKeyDown: handleKeyDown, role: \"listitem\", \"aria-label\": `${clip.name} clip from ${startTimeFormatted} to ${endTimeFormatted}, duration ${durationFormatted}`, \"aria-grabbed\": isKeyboardDragging, \"aria-dropeffect\": \"move\", tabIndex: tabIndex, \"aria-posinset\": posinset, \"aria-setsize\": setsize, \"data-clip-id\": clip.id, \"data-moving\": isDragging || isTrimming ? 'true' : undefined, \"data-trimming\": isTrimming || undefined, \"data-at-limit\": isAtLimit || (clip.endTime - clip.startTime) > clip.mediaDuration || undefined, \"data-trim-mode\": trimMode },\n        isTrimming && React.createElement(TrimModeTooltip, { mode: trimMode }),\n        React.createElement(\"div\", { className: \"clip-handle left clip-trim-start\", onPointerDown: (e) => {\n                e.stopPropagation();\n                handlePointerDown(e, 'trim-start');\n            }, style: {\n                position: 'absolute',\n                left: -8,\n                width: 16,\n                height: '100%',\n                cursor: 'col-resize',\n                zIndex: 10,\n                background: 'rgba(255, 255, 255, 0.1)',\n                opacity: 0,\n                transition: 'opacity 0.15s ease'\n            } }),\n        renderClipContent(),\n        React.createElement(\"div\", { className: \"clip-handle right clip-trim-end\", onPointerDown: (e) => {\n                e.stopPropagation();\n                handlePointerDown(e, 'trim-end');\n            }, style: {\n                position: 'absolute',\n                right: -8,\n                width: 16,\n                height: '100%',\n                cursor: 'col-resize',\n                zIndex: 10,\n                background: 'rgba(255, 255, 255, 0.1)',\n                opacity: 0,\n                transition: 'opacity 0.15s ease'\n            } }),\n        React.createElement(\"div\", { className: \"clip-duration\" },\n            durationFormatted,\n            clipDuration > clip.mediaDuration && (React.createElement(\"span\", { style: { fontSize: '0.8em', opacity: 0.7, marginLeft: '4px', color: '#ff6b6b' } },\n                \"(\",\n                formatTime(clip.mediaDuration, { fps, showFrames: true }),\n                \" source)\")))));\n};\n","__webpack_require__.h = () => (\"831377de3dad4c2c9e99\")"],"names":[],"sourceRoot":""}
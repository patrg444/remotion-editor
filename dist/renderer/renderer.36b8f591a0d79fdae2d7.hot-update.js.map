{"version":3,"file":"renderer.36b8f591a0d79fdae2d7.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAgF;AACC;AACX;AACP;AACtB;AAC2B;AACf;AACrD;AACA,oDAAa;AACN,wBAAwB,oDAAa;AACrC;AACP,oBAAoB,iDAAU;AAC9B;AACA;AACA;AACA;AACA;AACO,4BAA4B,UAAU;AAC7C,8BAA8B,iDAAU;AACxC,WAAW,iEAAoB;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA,0BAA0B;AAC1B,aAAa;AACb;AACA,KAAK;AACL,QAAQ,IAAuE;AAC/E,QAAQ,gDAAS;AACjB;AACA;AACA,SAAS;AACT;AACA,IAAI,gDAAS;AACb;AACA,qCAAqC,gFAAqB;AAC1D;AACA,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA,KAAK;AACL,YAAY,0DAAmB,6BAA6B,SAAS,mBAAmB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAW;AACxB;AACA,mBAAmB,iEAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAW;AACxB;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8CAAO;AAC1C;AACA;AACA;AACA;AACA,oBAAoB,mDAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa,wDAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8CAAO;AAC1C;AACA;AACA;AACA;AACA,oBAAoB,mDAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,yDAAyD,yDAAkB;AAC3E;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC,2DAA2D,yBAAyB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6DAAc,OAAO,6DAAc,WAAW,6DAAc;AAC1G;AACA,0CAA0C,uEAAiB;AAC3D,sCAAsC,6DAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,kEAAkE,yBAAyB;AAC3F;AACA;AACA,8DAA8D;AAC9D,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA,kDAAkD,6DAAc,OAAO,6DAAc,WAAW,6DAAc;AAC9G;AACA,8CAA8C,uEAAiB;AAC/D,0CAA0C,6DAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,6DAAc,OAAO,6DAAc,WAAW,6DAAc;AAC9G;AACA,8CAA8C,uEAAiB;AAC/D,0CAA0C,6DAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,6DAAc,OAAO,6DAAc,WAAW,6DAAc;AAClH;AACA,kDAAkD,uEAAiB;AACnE,8CAA8C,6DAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC,gCAAgC,aAAa;AAC7C,gEAAgE,yBAAyB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA,wEAAwE,mDAAmD;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,6DAAc,OAAO,6DAAc,WAAW,6DAAc;AACtH;AACA,sDAAsD,uEAAiB;AACvE,kDAAkD,6DAAc;AAChE;AACA;AACA;AACA;AACA,8DAA8D,uEAAiB,oCAAoC,uEAAiB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,6DAAc,OAAO,6DAAc,WAAW,6DAAc;AAC9G;AACA,8CAA8C,uEAAiB;AAC/D,0CAA0C,6DAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,6DAAc,OAAO,6DAAc,WAAW,6DAAc;AAClH;AACA,kDAAkD,uEAAiB;AACnE,8CAA8C,6DAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC;AACjC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;;ACrsBA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,8CAA8C,OAAO;AACrD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;UChFA","sources":["webpack://remotion-editor/./src/renderer/contexts/TimelineContext.tsx","webpack://remotion-editor/./src/renderer/utils/timelineValidation.ts","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { createContext, useReducer, useContext, useEffect } from 'react';\nimport { produce, produceWithPatches, applyPatches, enablePatches } from 'immer';\nimport { ActionTypes, initialTimelineState } from '../types/timeline';\nimport { TimelineConstants } from '../utils/timelineConstants';\nimport { logger } from '../utils/logger';\nimport { validateTimelineState } from '../utils/timelineValidation';\nimport { TransitionType } from '../types/transition';\n// Enable patches for Immer\nenablePatches();\nexport const TimelineContext = createContext(undefined);\nexport const useTimelineContext = () => {\n    const context = useContext(TimelineContext);\n    if (!context) {\n        throw new Error('useTimelineContext must be used within a TimelineProvider');\n    }\n    return context;\n};\nexport const TimelineProvider = ({ children }) => {\n    const [state, dispatch] = useReducer(timelineReducer, {\n        ...initialTimelineState,\n        history: {\n            entries: [],\n            currentIndex: -1\n        }\n    });\n    useEffect(() => {\n        try {\n            window.dispatchEvent(new CustomEvent('timeline:initializing'));\n            window.timelineDispatch = dispatch;\n            window.timelineState = state;\n            window.dispatchEvent(new CustomEvent('timeline:dispatchReady'));\n            window.timelineReady = true;\n            window.dispatchEvent(new CustomEvent('timeline:initialized'));\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            logger.error('[TimelineProvider] Error initializing timeline:', new Error(errorMessage));\n            window.dispatchEvent(new CustomEvent('timeline:error', {\n                detail: { error: new Error(errorMessage) }\n            }));\n        }\n    }, []);\n    if (process.env.NODE_ENV !== 'production' || process.env.CYPRESS === 'true') {\n        useEffect(() => {\n            window.timelineState = state;\n            window.timelineDispatch = dispatch;\n        }, [state, dispatch]);\n    }\n    useEffect(() => {\n        try {\n            const validationErrors = validateTimelineState(state);\n            if (validationErrors.length > 0) {\n                logger.warn('[Timeline] State validation errors:', validationErrors);\n            }\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            logger.error('[Timeline] State validation failed:', new Error(errorMessage));\n        }\n    }, [state]);\n    return (React.createElement(TimelineContext.Provider, { value: { state, dispatch } }, children));\n};\nconst NON_UNDOABLE_ACTIONS = new Set([\n    'SET_CURRENT_TIME',\n    'SET_PLAYING',\n    'SET_SCROLL_X',\n    'SET_SCROLL_Y',\n    'SET_DRAGGING',\n    'SET_ERROR',\n    'RESTORE_SNAPSHOT',\n    'SET_IS_PLAYING',\n    'SET_IS_DRAGGING',\n    'SELECT_CLIPS',\n    'SET_SELECTED_TRACK_ID',\n    'SET_DURATION',\n    'CLEAR_STATE',\n    'SET_STATE',\n    'SET_TRACKS',\n    'SET_SHOW_WAVEFORMS',\n    'SET_SHOW_KEYFRAMES',\n    'SET_SHOW_TRANSITIONS',\n    'SET_SHOW_EFFECTS',\n    'SET_RENDER_QUALITY',\n    'SET_SNAPPING',\n    'SELECT_TRACK',\n    'SELECT_CAPTIONS',\n    'PUSH_HISTORY',\n    'SET_HISTORY_INDEX',\n    'CLEAR_HISTORY'\n]);\nconst getHistoryDescription = (action) => {\n    switch (action.type) {\n        case ActionTypes.ADD_TRACK:\n            return 'Add track';\n        case ActionTypes.REMOVE_TRACK:\n            return 'Remove track';\n        case ActionTypes.ADD_CLIP:\n            return 'Add clip';\n        case ActionTypes.REMOVE_CLIP:\n            return 'Remove clip';\n        case ActionTypes.MOVE_CLIP:\n            return 'Move clip';\n        case ActionTypes.SPLIT_CLIP:\n            return 'Split clip';\n        case ActionTypes.TRIM_CLIP:\n            return 'Trim clip';\n        case ActionTypes.SET_ZOOM:\n            return 'Change zoom';\n        case ActionTypes.SET_FPS:\n            return 'Change FPS';\n        default:\n            return action.type;\n    }\n};\nconst isUndoable = (action) => {\n    return !NON_UNDOABLE_ACTIONS.has(action.type);\n};\nconst createFreshState = (state) => {\n    const freshState = JSON.parse(JSON.stringify(state));\n    freshState.tracks = freshState.tracks.map((track) => ({\n        ...track,\n        clips: track.clips.map((clip) => ({\n            ...clip,\n            layer: clip.layer ?? 0 // Ensure layer property exists\n        }))\n    }));\n    freshState.selectedClipIds = Array.from(freshState.selectedClipIds);\n    freshState.history = {\n        entries: freshState.history.entries.map(entry => ({\n            ...entry,\n            patches: JSON.parse(JSON.stringify(entry.patches)),\n            inversePatches: JSON.parse(JSON.stringify(entry.inversePatches))\n        })),\n        currentIndex: freshState.history.currentIndex\n    };\n    return freshState;\n};\nconst timelineReducer = (state, action) => {\n    switch (action.type) {\n        case ActionTypes.CLEAR_STATE: {\n            return {\n                ...initialTimelineState,\n                history: {\n                    entries: [],\n                    currentIndex: -1\n                }\n            };\n        }\n        case ActionTypes.SET_STATE: {\n            return {\n                ...action.payload,\n                history: action.payload.history || state.history\n            };\n        }\n        case ActionTypes.UNDO: {\n            if (state.history.currentIndex > 0) {\n                const newIndex = state.history.currentIndex - 1;\n                const entry = state.history.entries[newIndex];\n                // Create a fresh copy of state before applying patches\n                const stateCopy = createFreshState(state);\n                // Create final state with both patches and history update\n                const finalState = produce(stateCopy, draft => {\n                    // Create deep copies of patches to avoid any proxy issues\n                    const inversePatchesCopy = JSON.parse(JSON.stringify(entry.inversePatches));\n                    // Apply patches and ensure selection state is preserved\n                    const prevSelectedClipIds = Array.from(draft.selectedClipIds);\n                    applyPatches(draft, inversePatchesCopy);\n                    // If the selected clip still exists after applying patches, keep it selected\n                    const selectedClipsExist = prevSelectedClipIds.some((id) => draft.tracks.some((track) => track.clips.some((clip) => clip.id === id)));\n                    if (!selectedClipsExist && draft.tracks.length > 0) {\n                        // If no selected clips exist, try to select the first clip\n                        const firstTrack = draft.tracks[0];\n                        if (firstTrack.clips.length > 0) {\n                            draft.selectedClipIds = [firstTrack.clips[0].id];\n                        }\n                    }\n                    // Create a fresh copy of the history entries\n                    const newEntries = state.history.entries.map(entry => ({\n                        ...entry,\n                        patches: JSON.parse(JSON.stringify(entry.patches)),\n                        inversePatches: JSON.parse(JSON.stringify(entry.inversePatches))\n                    }));\n                    // Update history with a new object\n                    draft.history = {\n                        entries: newEntries,\n                        currentIndex: newIndex\n                    };\n                });\n                // Notify of undo completion\n                requestAnimationFrame(() => {\n                    window.dispatchEvent(new CustomEvent('timeline:undo-complete', {\n                        detail: {\n                            fromIndex: state.history.currentIndex,\n                            toIndex: newIndex,\n                            description: state.history.entries[newIndex].description\n                        }\n                    }));\n                });\n                return finalState;\n            }\n            return state;\n        }\n        case ActionTypes.REDO: {\n            if (state.history.currentIndex < state.history.entries.length - 1) {\n                const newIndex = state.history.currentIndex + 1;\n                const entry = state.history.entries[newIndex];\n                // Create a fresh copy of state before applying patches\n                const stateCopy = createFreshState(state);\n                // Create final state with both patches and history update\n                const finalState = produce(stateCopy, draft => {\n                    // Create deep copies of patches to avoid any proxy issues\n                    const patchesCopy = JSON.parse(JSON.stringify(entry.patches));\n                    // Apply patches and ensure selection state is preserved\n                    const prevSelectedClipIds = Array.from(draft.selectedClipIds);\n                    applyPatches(draft, patchesCopy);\n                    // If the selected clip still exists after applying patches, keep it selected\n                    const selectedClipsExist = prevSelectedClipIds.some((id) => draft.tracks.some((track) => track.clips.some((clip) => clip.id === id)));\n                    if (!selectedClipsExist && draft.tracks.length > 0) {\n                        // If no selected clips exist, try to select the first clip\n                        const firstTrack = draft.tracks[0];\n                        if (firstTrack.clips.length > 0) {\n                            draft.selectedClipIds = [firstTrack.clips[0].id];\n                        }\n                    }\n                    // Create a fresh copy of the history entries\n                    const newEntries = state.history.entries.map(entry => ({\n                        ...entry,\n                        patches: JSON.parse(JSON.stringify(entry.patches)),\n                        inversePatches: JSON.parse(JSON.stringify(entry.inversePatches))\n                    }));\n                    // Update history with a new object\n                    draft.history = {\n                        entries: newEntries,\n                        currentIndex: newIndex\n                    };\n                });\n                // Notify of redo completion\n                requestAnimationFrame(() => {\n                    window.dispatchEvent(new CustomEvent('timeline:redo-complete', {\n                        detail: {\n                            fromIndex: state.history.currentIndex,\n                            toIndex: newIndex,\n                            description: state.history.entries[newIndex].description\n                        }\n                    }));\n                });\n                return finalState;\n            }\n            return state;\n        }\n        default: {\n            const [nextState, patches, inversePatches] = produceWithPatches(state, draft => {\n                switch (action.type) {\n                    case ActionTypes.SET_DURATION:\n                        draft.duration = action.payload;\n                        break;\n                    case ActionTypes.SET_TRACKS:\n                        draft.tracks = action.payload.map((track) => ({\n                            ...track,\n                            clips: track.clips.map((clip) => ({\n                                ...clip,\n                                layer: clip.layer ?? 0\n                            }))\n                        }));\n                        break;\n                    case ActionTypes.SET_CURRENT_TIME:\n                        draft.currentTime = action.payload;\n                        break;\n                    case ActionTypes.SET_PLAYING:\n                        draft.isPlaying = action.payload;\n                        break;\n                    case ActionTypes.SET_SCROLL_X:\n                        draft.scrollX = action.payload;\n                        break;\n                    case ActionTypes.SET_SCROLL_Y:\n                        draft.scrollY = action.payload;\n                        break;\n                    case ActionTypes.SET_ZOOM:\n                        draft.zoom = action.payload;\n                        break;\n                    case ActionTypes.SET_FPS:\n                        draft.fps = action.payload;\n                        break;\n                    case ActionTypes.SET_DRAGGING:\n                        draft.isDragging = action.payload.isDragging;\n                        draft.dragStartX = action.payload.dragStartX;\n                        draft.dragStartY = action.payload.dragStartY;\n                        break;\n                    case ActionTypes.SET_ERROR:\n                        draft.error = action.payload;\n                        break;\n                    case ActionTypes.ADD_TRACK:\n                        console.log('ADD_TRACK action:', { payload: action.payload });\n                        const newTrack = {\n                            ...action.payload.track,\n                            transitions: Array.isArray(action.payload.track.transitions) ? action.payload.track.transitions : [],\n                            allowTransitions: true,\n                            transitionsEnabled: true,\n                            showTransitions: true,\n                            allowOverlap: true,\n                            transitionTypes: [TransitionType.Wipe, TransitionType.Dissolve, TransitionType.Fade],\n                            transitionDefaults: {\n                                duration: TimelineConstants.Transitions.MIN_DURATION,\n                                type: TransitionType.Wipe,\n                                direction: 'right'\n                            }\n                        };\n                        console.log('Adding track with transitions:', newTrack);\n                        draft.tracks = [...draft.tracks, newTrack];\n                        break;\n                    case ActionTypes.UPDATE_TRACK: {\n                        const trackIndex = draft.tracks.findIndex((t) => t.id === action.payload.trackId);\n                        if (trackIndex !== -1) {\n                            console.log('UPDATE_TRACK action:', { payload: action.payload });\n                            const updatedTrack = {\n                                ...draft.tracks[trackIndex],\n                                ...(action.payload.track || {}),\n                                ...(action.payload.updates || {}),\n                                transitions: draft.tracks[trackIndex].transitions || [],\n                                allowTransitions: true,\n                                transitionsEnabled: true,\n                                showTransitions: true,\n                                allowOverlap: true,\n                                transitionTypes: [TransitionType.Wipe, TransitionType.Dissolve, TransitionType.Fade],\n                                transitionDefaults: {\n                                    duration: TimelineConstants.Transitions.MIN_DURATION,\n                                    type: TransitionType.Wipe,\n                                    direction: 'right'\n                                }\n                            };\n                            console.log('Updated track:', updatedTrack);\n                            draft.tracks = [\n                                ...draft.tracks.slice(0, trackIndex),\n                                updatedTrack,\n                                ...draft.tracks.slice(trackIndex + 1)\n                            ];\n                        }\n                        break;\n                    }\n                    case ActionTypes.REMOVE_TRACK:\n                        draft.tracks = draft.tracks.filter((t) => t.id !== action.payload.trackId);\n                        break;\n                    case ActionTypes.ADD_CLIP: {\n                        const trackIndex = draft.tracks.findIndex((t) => t.id === action.payload.trackId);\n                        if (trackIndex !== -1) {\n                            const trackToAddClip = draft.tracks[trackIndex];\n                            const newClip = {\n                                ...action.payload.clip,\n                                startTime: action.payload.clip.startTime ?? 0,\n                                endTime: action.payload.clip.endTime ?? (action.payload.clip.duration ?? 0),\n                                layer: action.payload.clip.layer ?? 0\n                            };\n                            const newClips = [...trackToAddClip.clips, newClip].sort((a, b) => a.startTime - b.startTime);\n                            // Create new track with updated clips\n                            const updatedTrack = {\n                                ...trackToAddClip,\n                                clips: newClips,\n                                transitions: trackToAddClip.transitions || [],\n                                allowTransitions: true,\n                                transitionsEnabled: true,\n                                showTransitions: true,\n                                allowOverlap: true,\n                                transitionTypes: [TransitionType.Wipe, TransitionType.Dissolve, TransitionType.Fade],\n                                transitionDefaults: {\n                                    duration: TimelineConstants.Transitions.MIN_DURATION,\n                                    type: TransitionType.Wipe,\n                                    direction: 'right'\n                                }\n                            };\n                            // Update tracks array\n                            draft.tracks = [\n                                ...draft.tracks.slice(0, trackIndex),\n                                updatedTrack,\n                                ...draft.tracks.slice(trackIndex + 1)\n                            ];\n                        }\n                        break;\n                    }\n                    case ActionTypes.UPDATE_CLIP: {\n                        const trackIndex = draft.tracks.findIndex((t) => t.id === action.payload.trackId);\n                        if (trackIndex !== -1) {\n                            const trackWithClip = draft.tracks[trackIndex];\n                            const clipIndex = trackWithClip.clips.findIndex((c) => c.id === action.payload.clipId);\n                            if (clipIndex !== -1) {\n                                const newClips = [\n                                    ...trackWithClip.clips.slice(0, clipIndex),\n                                    {\n                                        ...trackWithClip.clips[clipIndex],\n                                        ...action.payload.clip,\n                                        layer: action.payload.clip.layer ?? trackWithClip.clips[clipIndex].layer ?? 0\n                                    },\n                                    ...trackWithClip.clips.slice(clipIndex + 1)\n                                ];\n                                // Create new track with updated clips\n                                const updatedTrack = {\n                                    ...trackWithClip,\n                                    clips: newClips,\n                                    transitions: trackWithClip.transitions || [],\n                                    allowTransitions: true,\n                                    transitionsEnabled: true,\n                                    showTransitions: true,\n                                    allowOverlap: true,\n                                    transitionTypes: [TransitionType.Wipe, TransitionType.Dissolve, TransitionType.Fade],\n                                    transitionDefaults: {\n                                        duration: TimelineConstants.Transitions.MIN_DURATION,\n                                        type: TransitionType.Wipe,\n                                        direction: 'right'\n                                    }\n                                };\n                                // Update tracks array\n                                draft.tracks = [\n                                    ...draft.tracks.slice(0, trackIndex),\n                                    updatedTrack,\n                                    ...draft.tracks.slice(trackIndex + 1)\n                                ];\n                            }\n                        }\n                        break;\n                    }\n                    case ActionTypes.ADD_TRANSITION: {\n                        const { transition } = action.payload;\n                        console.log('ADD_TRANSITION action:', { payload: action.payload });\n                        const trackIndex = draft.tracks.findIndex((t) => t.clips.some((c) => c.id === transition.clipAId) &&\n                            t.clips.some((c) => c.id === transition.clipBId));\n                        console.log('Found track index:', trackIndex);\n                        if (trackIndex !== -1) {\n                            // Initialize transitions array if it doesn't exist\n                            if (!draft.tracks[trackIndex].transitions) {\n                                draft.tracks[trackIndex].transitions = [];\n                            }\n                            // Create fresh copies of track and clips\n                            const trackCopy = JSON.parse(JSON.stringify(draft.tracks[trackIndex]));\n                            const clipA = JSON.parse(JSON.stringify(trackCopy.clips.find((c) => c.id === transition.clipAId)));\n                            const clipB = JSON.parse(JSON.stringify(trackCopy.clips.find((c) => c.id === transition.clipBId)));\n                            console.log('Found clips:', { clipA, clipB });\n                            // Validate clips exist and are adjacent\n                            if (clipA && clipB) {\n                                const areAdjacent = Math.abs(clipB.startTime - clipA.endTime) < 0.1;\n                                console.log('Clips adjacency check:', { areAdjacent, gap: clipB.startTime - clipA.endTime });\n                                if (areAdjacent) {\n                                    // Initialize transitions array and transition properties\n                                    const updatedTrack = {\n                                        ...trackCopy,\n                                        transitions: Array.isArray(trackCopy.transitions) ? trackCopy.transitions : [],\n                                        allowTransitions: true,\n                                        transitionsEnabled: true,\n                                        showTransitions: true,\n                                        allowOverlap: true,\n                                        transitionTypes: [TransitionType.Wipe, TransitionType.Dissolve, TransitionType.Fade],\n                                        transitionDefaults: {\n                                            duration: TimelineConstants.Transitions.MIN_DURATION,\n                                            type: TransitionType.Wipe,\n                                            direction: 'right'\n                                        }\n                                    };\n                                    // Enforce minimum/maximum duration\n                                    const duration = Math.max(TimelineConstants.Transitions.MIN_DURATION, Math.min(TimelineConstants.Transitions.MAX_DURATION, transition.duration));\n                                    // Create new transition object\n                                    const newTransition = {\n                                        ...transition,\n                                        duration,\n                                        id: transition.id,\n                                        type: transition.type,\n                                        clipAId: transition.clipAId,\n                                        clipBId: transition.clipBId,\n                                        startTime: clipA.endTime - (duration / 2),\n                                        endTime: clipB.startTime + (duration / 2),\n                                        params: {\n                                            ...transition.params,\n                                            duration,\n                                            direction: transition.params?.direction || 'right'\n                                        }\n                                    };\n                                    // Add transition to array\n                                    updatedTrack.transitions.push(newTransition);\n                                    // Update track in draft state\n                                    draft.tracks[trackIndex] = updatedTrack;\n                                    console.log('Added transition:', {\n                                        track: updatedTrack,\n                                        transition: newTransition,\n                                        allTransitions: updatedTrack.transitions,\n                                        trackState: draft.tracks[trackIndex],\n                                        trackIndex,\n                                        clipA: clipA,\n                                        clipB: clipB,\n                                        areAdjacent,\n                                        gap: clipB.startTime - clipA.endTime\n                                    });\n                                    // Notify that transition was added\n                                    requestAnimationFrame(() => {\n                                        window.dispatchEvent(new CustomEvent('timeline:transition-added', {\n                                            detail: {\n                                                trackId: trackCopy.id,\n                                                transitionId: newTransition.id,\n                                                transition: newTransition\n                                            }\n                                        }));\n                                    });\n                                }\n                            }\n                        }\n                        break;\n                    }\n                    case ActionTypes.UPDATE_TRANSITION: {\n                        const { transitionId, params } = action.payload;\n                        const trackIndex = draft.tracks.findIndex((track) => track.transitions?.some((t) => t.id === transitionId));\n                        if (trackIndex !== -1) {\n                            // Create fresh copy of track\n                            const trackCopy = JSON.parse(JSON.stringify(draft.tracks[trackIndex]));\n                            const transitionIndex = trackCopy.transitions.findIndex((t) => t.id === transitionId);\n                            if (transitionIndex !== -1) {\n                                // Get clips for this transition\n                                const transition = trackCopy.transitions[transitionIndex];\n                                const clipA = trackCopy.clips.find((c) => c.id === transition.clipAId);\n                                const clipB = trackCopy.clips.find((c) => c.id === transition.clipBId);\n                                if (clipA && clipB) {\n                                    // Create fresh copy of transition\n                                    const updatedTransition = {\n                                        ...transition,\n                                        params: {\n                                            ...transition.params,\n                                            ...params\n                                        }\n                                    };\n                                    if (params.duration) {\n                                        const duration = params.duration;\n                                        updatedTransition.duration = duration;\n                                        updatedTransition.startTime = clipA.endTime - (duration / 2);\n                                        updatedTransition.endTime = clipB.startTime + (duration / 2);\n                                    }\n                                    // Update transitions array\n                                    trackCopy.transitions[transitionIndex] = updatedTransition;\n                                    // Update track in draft\n                                    draft.tracks[trackIndex] = trackCopy;\n                                    // Notify that transition was updated\n                                    requestAnimationFrame(() => {\n                                        window.dispatchEvent(new CustomEvent('timeline:transition-updated', {\n                                            detail: {\n                                                trackId: trackCopy.id,\n                                                transitionId,\n                                                transition: updatedTransition\n                                            }\n                                        }));\n                                    });\n                                }\n                            }\n                        }\n                        break;\n                    }\n                    case ActionTypes.REMOVE_TRANSITION: {\n                        const { transitionId } = action.payload;\n                        const trackIndex = draft.tracks.findIndex((track) => track.transitions?.some((t) => t.id === transitionId));\n                        if (trackIndex !== -1) {\n                            // Create fresh copy of track\n                            const trackCopy = JSON.parse(JSON.stringify(draft.tracks[trackIndex]));\n                            // Filter out the transition\n                            trackCopy.transitions = trackCopy.transitions.filter((t) => t.id !== transitionId);\n                            // Update track in draft\n                            draft.tracks[trackIndex] = trackCopy;\n                            // Notify that transition was removed\n                            requestAnimationFrame(() => {\n                                window.dispatchEvent(new CustomEvent('timeline:transition-removed', {\n                                    detail: {\n                                        trackId: trackCopy.id,\n                                        transitionId\n                                    }\n                                }));\n                            });\n                        }\n                        break;\n                    }\n                    case ActionTypes.REMOVE_CLIP: {\n                        const trackIndex = draft.tracks.findIndex((t) => t.id === action.payload.trackId);\n                        if (trackIndex !== -1) {\n                            const trackToRemoveClip = draft.tracks[trackIndex];\n                            const newClips = trackToRemoveClip.clips.filter((c) => c.id !== action.payload.clipId);\n                            // Create new track with updated clips\n                            const updatedTrack = {\n                                ...trackToRemoveClip,\n                                clips: newClips,\n                                transitions: trackToRemoveClip.transitions || [],\n                                allowTransitions: true,\n                                transitionsEnabled: true,\n                                showTransitions: true,\n                                allowOverlap: true,\n                                transitionTypes: [TransitionType.Wipe, TransitionType.Dissolve, TransitionType.Fade],\n                                transitionDefaults: {\n                                    duration: TimelineConstants.Transitions.MIN_DURATION,\n                                    type: TransitionType.Wipe,\n                                    direction: 'right'\n                                }\n                            };\n                            // Update tracks array\n                            draft.tracks = [\n                                ...draft.tracks.slice(0, trackIndex),\n                                updatedTrack,\n                                ...draft.tracks.slice(trackIndex + 1)\n                            ];\n                        }\n                        break;\n                    }\n                    case ActionTypes.SPLIT_CLIP: {\n                        const trackIndex = draft.tracks.findIndex((t) => t.id === action.payload.trackId);\n                        if (trackIndex !== -1) {\n                            const trackToSplit = draft.tracks[trackIndex];\n                            const clipToSplit = trackToSplit.clips.find((c) => c.id === action.payload.clipId);\n                            if (clipToSplit && action.payload.time > clipToSplit.startTime && action.payload.time < clipToSplit.endTime) {\n                                const splitPoint = action.payload.time;\n                                const firstDuration = splitPoint - clipToSplit.startTime;\n                                const originalMediaOffset = clipToSplit.mediaOffset ?? 0;\n                                const originalMediaDuration = clipToSplit.mediaDuration ?? (clipToSplit.endTime - clipToSplit.startTime);\n                                const firstMediaStart = originalMediaOffset;\n                                const firstMediaEnd = originalMediaOffset + firstDuration;\n                                const secondMediaStart = originalMediaOffset + firstDuration;\n                                const fullMediaDuration = originalMediaDuration;\n                                // Create first clip\n                                const firstClip = {\n                                    ...clipToSplit,\n                                    id: `${clipToSplit.id}-1`,\n                                    startTime: clipToSplit.startTime,\n                                    endTime: splitPoint,\n                                    mediaOffset: firstMediaStart,\n                                    mediaDuration: fullMediaDuration,\n                                    layer: clipToSplit.layer ?? 0,\n                                    handles: {\n                                        startPosition: firstMediaStart,\n                                        endPosition: firstMediaEnd\n                                    },\n                                    initialBounds: {\n                                        startTime: clipToSplit.startTime,\n                                        endTime: splitPoint,\n                                        mediaOffset: firstMediaStart,\n                                        mediaDuration: fullMediaDuration\n                                    }\n                                };\n                                // Create second clip\n                                const secondClip = {\n                                    ...clipToSplit,\n                                    id: `${clipToSplit.id}-2`,\n                                    startTime: splitPoint,\n                                    endTime: clipToSplit.endTime,\n                                    mediaOffset: secondMediaStart,\n                                    mediaDuration: fullMediaDuration,\n                                    layer: clipToSplit.layer ?? 0,\n                                    handles: {\n                                        startPosition: secondMediaStart,\n                                        endPosition: secondMediaStart + (clipToSplit.endTime - splitPoint)\n                                    },\n                                    initialBounds: {\n                                        startTime: splitPoint,\n                                        endTime: clipToSplit.endTime,\n                                        mediaOffset: secondMediaStart,\n                                        mediaDuration: fullMediaDuration\n                                    }\n                                };\n                                // Create new clips array\n                                const newClips = trackToSplit.clips\n                                    .filter((c) => c.id !== clipToSplit.id)\n                                    .concat([firstClip, secondClip])\n                                    .sort((a, b) => a.startTime - b.startTime);\n                                // Create new track with updated clips\n                                const updatedTrack = {\n                                    ...trackToSplit,\n                                    clips: newClips,\n                                    transitions: trackToSplit.transitions || [],\n                                    allowTransitions: true,\n                                    transitionsEnabled: true,\n                                    showTransitions: true,\n                                    allowOverlap: true,\n                                    transitionTypes: [TransitionType.Wipe, TransitionType.Dissolve, TransitionType.Fade],\n                                    transitionDefaults: {\n                                        duration: TimelineConstants.Transitions.MIN_DURATION,\n                                        type: TransitionType.Wipe,\n                                        direction: 'right'\n                                    }\n                                };\n                                // Update tracks array\n                                draft.tracks = [\n                                    ...draft.tracks.slice(0, trackIndex),\n                                    updatedTrack,\n                                    ...draft.tracks.slice(trackIndex + 1)\n                                ];\n                                // Update selection\n                                draft.selectedClipIds = [firstClip.id];\n                                // Notify of split completion\n                                requestAnimationFrame(() => {\n                                    window.dispatchEvent(new CustomEvent('timeline:clip-split', {\n                                        detail: {\n                                            trackId: trackToSplit.id,\n                                            originalClipId: clipToSplit.id,\n                                            splitTime: splitPoint,\n                                            firstClipId: firstClip.id,\n                                            secondClipId: secondClip.id,\n                                            firstClip: {\n                                                startTime: firstClip.startTime,\n                                                endTime: firstClip.endTime,\n                                                mediaOffset: firstClip.mediaOffset,\n                                                mediaDuration: first\n                                            }\n                                        }\n                                    }));\n                                });\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    }\n};\n","/**\n * Validates the timeline state structure and returns any validation errors\n */\nexport function validateTimelineState(state) {\n    const errors = [];\n    // Check required properties\n    if (!state) {\n        errors.push('Timeline state is undefined');\n        return errors;\n    }\n    // Check tracks array\n    if (!Array.isArray(state.tracks)) {\n        errors.push('Tracks must be an array');\n    }\n    else {\n        // Validate each track\n        state.tracks.forEach((track, index) => {\n            if (!track.id) {\n                errors.push(`Track at index ${index} is missing id`);\n            }\n            if (!track.name) {\n                errors.push(`Track at index ${index} is missing name`);\n            }\n            if (!track.type) {\n                errors.push(`Track at index ${index} is missing type`);\n            }\n            if (!Array.isArray(track.clips)) {\n                errors.push(`Track at index ${index} clips must be an array`);\n            }\n        });\n    }\n    // Check numeric properties\n    if (typeof state.currentTime !== 'number') {\n        errors.push('currentTime must be a number');\n    }\n    if (typeof state.duration !== 'number') {\n        errors.push('duration must be a number');\n    }\n    if (typeof state.zoom !== 'number') {\n        errors.push('zoom must be a number');\n    }\n    if (typeof state.fps !== 'number') {\n        errors.push('fps must be a number');\n    }\n    if (typeof state.scrollX !== 'number') {\n        errors.push('scrollX must be a number');\n    }\n    if (typeof state.scrollY !== 'number') {\n        errors.push('scrollY must be a number');\n    }\n    // Check boolean properties\n    if (typeof state.isPlaying !== 'boolean') {\n        errors.push('isPlaying must be a boolean');\n    }\n    if (typeof state.isDragging !== 'boolean') {\n        errors.push('isDragging must be a boolean');\n    }\n    // Check arrays\n    if (!Array.isArray(state.selectedClipIds)) {\n        errors.push('selectedClipIds must be an array');\n    }\n    if (!Array.isArray(state.selectedCaptionIds)) {\n        errors.push('selectedCaptionIds must be an array');\n    }\n    if (!Array.isArray(state.markers)) {\n        errors.push('markers must be an array');\n    }\n    // Check history\n    if (!state.history) {\n        errors.push('history is missing');\n    }\n    else {\n        if (!Array.isArray(state.history.entries)) {\n            errors.push('history.entries must be an array');\n        }\n        if (typeof state.history.currentIndex !== 'number') {\n            errors.push('history.currentIndex must be a number');\n        }\n    }\n    return errors;\n}\n","__webpack_require__.h = () => (\"c45d10fbcbe0707dc975\")"],"names":[],"sourceRoot":""}
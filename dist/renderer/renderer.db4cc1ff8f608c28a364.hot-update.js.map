{"version":3,"file":"renderer.db4cc1ff8f608c28a364.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAwE;AACiB;AAC7B;AACA;AACI;AACZ;AACgB;AACL;AACR;AACU;AACd;AACI;AACd;AACW;AACpD;AACA;AACA;AACA;AACO,wBAAwB,0IAA0I;AACzK,wDAAwD,+CAAQ;AAChE,sCAAsC,+CAAQ;AAC9C,wCAAwC,+CAAQ;AAChD,wCAAwC,+CAAQ;AAChD,oCAAoC,+CAAQ;AAC5C;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA,oBAAoB,kDAAM;AAC1B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,2BAA2B,EAAE,mEAAa;AACtD,YAAY,kBAAkB,EAAE,6EAAkB;AAClD,qBAAqB,gEAAW;AAChC,YAAY,yCAAyC,EAAE,oEAAa;AACpE,oBAAoB,6CAAM;AAC1B;AACA,IAAI,gDAAS;AACb;AACA;AACA,gBAAgB,kDAAM;AACtB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,6BAA6B,kEAAY;AACzC,8BAA8B,kEAAY;AAC1C;AACA;AACA;AACA,gDAAgD,iBAAiB;AACjE,iDAAiD,kBAAkB;AACnE,+CAA+C,iBAAiB,uEAAiB,iBAAiB;AAClG;AACA;AACA;AACA,gBAAgB,kDAAM;AACtB;AACA;AACA;AACA,0CAA0C,uEAAiB;AAC3D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uEAAiB;AAC/D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA;AACA,YAAY,kDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL,yBAAyB,6CAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,kDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAY;AACpD;AACA;AACA;AACA,kCAAkC,kEAAY;AAC9C,wBAAwB,kDAAM;AAC9B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA,0CAA0C,kEAAY,CAAC,uEAAiB;AACxE,+DAA+D,kEAAY;AAC3E,oCAAoC,kEAAY,gBAAgB,uEAAiB;AACjF;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAY;AACpD;AACA;AACA;AACA,kCAAkC,kEAAY;AAC9C,wBAAwB,kDAAM;AAC9B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,oDAAoD,oBAAoB;AACxE,qDAAqD,wBAAwB;AAC7E;AACA;AACA;AACA;AACA;AACA,0CAA0C,kEAAY,CAAC,uEAAiB;AACxE,mCAAmC,kEAAY,kBAAkB,uEAAiB;AAClF;AACA,oCAAoC,kEAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAY;AACpD;AACA;AACA;AACA,mCAAmC,kEAAY;AAC/C,wBAAwB,kDAAM;AAC9B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,kCAAkC,kEAAY;AAC9C,gBAAgB,kDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,gBAAgB,kDAAM;AACtB;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAY;AACtC,iBAAiB;AACjB;AACA,qDAAqD,qBAAqB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4BAA4B,kDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,8BAA8B,kEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,8BAA8B,kEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA,oBAAoB,kDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAW;AAC7B;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL,8BAA8B,kDAAW;AACzC;AACA;AACA,YAAY,kDAAM;AAClB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAY;AACxC,0BAA0B,kEAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kEAAY;AACvC;AACA;AACA;AACA;AACA,2BAA2B,kEAAY;AACvC;AACA;AACA;AACA;AACA,oCAAoC,kEAAY,+BAA+B,kEAAY;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAW;AAC7B;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA;AACA,gBAAgB,kDAAM;AACtB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAM;AACtB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,eAAe;AAC3E,wDAAwD,eAAe;AACvE;AACA,mEAAmE,eAAe;AAClF,+DAA+D,eAAe;AAC9E;AACA,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,kDAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,0BAA0B,kDAAW;AACrC;AACA;AACA,YAAY,kDAAM;AAClB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAW;AACzC;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,4DAAW;AACvB,oBAAoB,0DAAmB,CAAC,qEAAgB,IAAI,uFAAuF;AACnJ;AACA,YAAY,4DAAW;AACvB,oBAAoB,0DAAmB,CAAC,qEAAgB,IAAI,uFAAuF;AACnJ;AACA,YAAY,8DAAa;AACzB,oBAAoB,0DAAmB,CAAC,yEAAkB,IAAI,uFAAuF;AACrJ;AACA;AACA;AACA,+BAA+B,gEAAU,mBAAmB,uBAAuB;AACnF,6BAA6B,gEAAU,iBAAiB,uBAAuB;AAC/E,8BAA8B,gEAAU,kCAAkC,uBAAuB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kEAAY;AAC3D;AACA,QAAQ,kDAAM;AACd;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,wBAAwB,kEAAY;AACpC;AACA;AACA,iBAAiB,wBAAwB;AACzC,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAmB,UAAU,0EAA0E,WAAW,EAAE,+CAA+C,EAAE,0DAA0D,oHAAoH,WAAW,YAAY,oBAAoB,KAAK,iBAAiB,aAAa,kBAAkB,wYAAwY;AACv0B,sBAAsB,0DAAmB,CAAC,8DAAe,IAAI,gBAAgB;AAC7E,QAAQ,0DAAmB,UAAU;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,QAAQ,0DAAmB,UAAU;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,QAAQ,0DAAmB,UAAU,4BAA4B;AACjE;AACA,kDAAkD,0DAAmB,WAAW,SAAS,wEAAwE;AACjK;AACA,gBAAgB,gEAAU,uBAAuB,uBAAuB;AACxE;AACA;;;;;;;;;UC3tBA","sources":["webpack://remotion-editor/./src/renderer/components/TimelineClip.tsx","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { useCallback, useState, useRef, useEffect } from 'react';\nimport { isVideoClip, isAudioClip, isCaptionClip, ActionTypes } from '../types/timeline';\nimport { VideoClipContent } from './clips/VideoClipContent';\nimport { AudioClipContent } from './clips/AudioClipContent';\nimport { CaptionClipContent } from './clips/CaptionClipContent';\nimport { formatTime } from '../utils/timelineUnits';\nimport { timeToPixels, pixelsToTime } from '../utils/timelineScale';\nimport { TimelineConstants } from '../utils/timelineConstants';\nimport { useRippleEdit } from '../hooks/useRippleEdit';\nimport { useTimelineContext } from '../hooks/useTimelineContext';\nimport { useTimeline } from '../hooks/useTimeline';\nimport { useSnapPoints } from '../hooks/useSnapPoints';\nimport { logger } from '../utils/logger';\nimport { TrimModeTooltip } from './TrimModeTooltip';\nconst KEYBOARD_MOVE_STEP = 1;\nconst KEYBOARD_MOVE_FAST = 10;\nconst TRACK_LABEL_WIDTH = 160;\nconst SNAP_THRESHOLD = 5;\nexport const TimelineClip = ({ clip, track, layer, zoom, fps, onSelect, onDragStart, onDragEnd, tabIndex = 0, 'aria-posinset': posinset, 'aria-setsize': setsize, style }) => {\n    const [isKeyboardDragging, setIsKeyboardDragging] = useState(false);\n    const [isAtLimit, setIsAtLimit] = useState(false);\n    const [isDragging, setIsDragging] = useState(false);\n    const [isTrimming, setIsTrimming] = useState(null);\n    const [trimMode, setTrimMode] = useState('normal');\n    // Handle trim mode change events\n    useEffect(() => {\n        const handleTrimModeChange = (e) => {\n            if (isTrimming) {\n                const newMode = e.detail?.mode;\n                if (newMode && ['normal', 'ripple', 'slip'].includes(newMode)) {\n                    logger.debug('Setting trim mode from event:', {\n                        mode: newMode,\n                        isTrimming,\n                        currentMode: trimMode\n                    });\n                    setTrimMode(newMode);\n                }\n            }\n        };\n        window.addEventListener('trimModeChange', handleTrimModeChange);\n        return () => {\n            window.removeEventListener('trimModeChange', handleTrimModeChange);\n        };\n    }, [isTrimming, trimMode]);\n    const { rippleDelete, rippleTrim } = useRippleEdit();\n    const { state, dispatch } = useTimelineContext();\n    const timeline = useTimeline();\n    const { getAllSnapPoints, findNearestSnapPoint } = useSnapPoints(fps);\n    const clipRef = useRef(null);\n    // Listen for clip:rendered events\n    useEffect(() => {\n        const handleClipRendered = (e) => {\n            if (e.detail.clipId === clip.id && clipRef.current) {\n                logger.debug('Received clip:rendered event:', {\n                    clipId: clip.id,\n                    detail: e.detail,\n                    currentStyle: clipRef.current.style,\n                    currentRect: clipRef.current.getBoundingClientRect()\n                });\n                // Update clip position and dimensions\n                const left = timeToPixels(e.detail.startTime, zoom);\n                const width = timeToPixels(e.detail.endTime - e.detail.startTime, zoom);\n                // Force a reflow before updating styles\n                void clipRef.current.offsetHeight;\n                clipRef.current.style.transition = 'none';\n                clipRef.current.style.left = `${Math.round(left)}px`;\n                clipRef.current.style.width = `${Math.round(width)}px`;\n                clipRef.current.style.top = `${e.detail.layer * TimelineConstants.UI.TRACK_HEIGHT}px`;\n                // Force another reflow\n                void clipRef.current.offsetHeight;\n                clipRef.current.style.transition = '';\n                logger.debug('Updated clip style:', {\n                    clipId: clip.id,\n                    left,\n                    width,\n                    top: e.detail.layer * TimelineConstants.UI.TRACK_HEIGHT,\n                    zoom\n                });\n                // Dispatch a custom event to notify that the clip has been positioned\n                window.dispatchEvent(new CustomEvent('clip:positioned', {\n                    detail: {\n                        clipId: clip.id,\n                        left,\n                        width,\n                        top: e.detail.layer * TimelineConstants.UI.TRACK_HEIGHT\n                    }\n                }));\n            }\n        };\n        window.addEventListener('clip:rendered', handleClipRendered);\n        return () => {\n            window.removeEventListener('clip:rendered', handleClipRendered);\n        };\n    }, [clip.id, clip.startTime, clip.endTime, clip.layer, zoom]);\n    // Emit clip rendered event when mounted, positioned, or updated\n    useEffect(() => {\n        if (clipRef.current) {\n            const rect = clipRef.current.getBoundingClientRect();\n            logger.debug('Clip mounted/updated:', {\n                clipId: clip.id,\n                rect,\n                startTime: clip.startTime,\n                endTime: clip.endTime,\n                layer,\n                style: clipRef.current.style\n            });\n            // Use requestAnimationFrame to ensure DOM is ready\n            requestAnimationFrame(() => {\n                window.dispatchEvent(new CustomEvent('clip:rendered', {\n                    detail: {\n                        clipId: clip.id,\n                        height: rect.height,\n                        width: rect.width,\n                        left: rect.left,\n                        top: rect.top,\n                        startTime: clip.startTime,\n                        endTime: clip.endTime,\n                        layer\n                    }\n                }));\n            });\n        }\n    }, [clip.id, clip.startTime, clip.endTime, layer, isDragging, isTrimming]);\n    const dragStateRef = useRef({\n        isDragging: false,\n        isTrimming: null,\n        pointerDownX: 0,\n        originalStartPixels: 0,\n        originalEndPixels: 0,\n        pointerId: -1,\n        scrollX: 0,\n        lastDeltaPixels: 0,\n        maxExtension: 0,\n    });\n    const handlePointerMove = useCallback((e) => {\n        const dragState = dragStateRef.current;\n        if (!dragState.isDragging && !dragState.isTrimming)\n            return;\n        if (e.pointerId !== dragState.pointerId)\n            return;\n        if (clipRef.current) {\n            if (dragState.isDragging) {\n                const pointerDelta = (e.clientX - TRACK_LABEL_WIDTH) - dragState.pointerDownX;\n                const proposedLeft = dragState.originalStartPixels + pointerDelta;\n                let newLeft = Math.max(0, proposedLeft);\n                // Apply snapping if enabled\n                if (state.isSnappingEnabled) {\n                    const currentTime = pixelsToTime(newLeft, zoom);\n                    const snapPoints = getAllSnapPoints(state.tracks, state.markers, currentTime, zoom);\n                    const nearestPoint = findNearestSnapPoint(currentTime, snapPoints, 0.1, ['playhead']);\n                    if (nearestPoint) {\n                        newLeft = timeToPixels(nearestPoint.time, zoom);\n                        logger.debug('Snapped to point:', {\n                            type: nearestPoint.type,\n                            time: nearestPoint.time,\n                            source: nearestPoint.source\n                        });\n                    }\n                }\n                clipRef.current.style.left = `${Math.round(newLeft)}px`;\n                dragStateRef.current.lastDeltaPixels = newLeft - dragState.originalStartPixels;\n                setIsAtLimit(newLeft === 0);\n            }\n            else if (dragState.isTrimming === 'start') {\n                const minDurationPixels = timeToPixels(TimelineConstants.MIN_DURATION, zoom);\n                const minLeftPos = trimMode === 'ripple' ? 0 : timeToPixels(clip.mediaOffset, zoom);\n                const maxRightPos = timeToPixels(clip.endTime - TimelineConstants.MIN_DURATION, zoom);\n                const pointerDelta = e.clientX - TRACK_LABEL_WIDTH - dragState.pointerDownX;\n                const proposedLeft = dragState.originalStartPixels + pointerDelta;\n                let newLeft = Math.max(minLeftPos, Math.min(maxRightPos, proposedLeft));\n                // Apply snapping if enabled\n                if (state.isSnappingEnabled) {\n                    const currentTime = pixelsToTime(newLeft, zoom);\n                    const snapPoints = getAllSnapPoints(state.tracks, state.markers, currentTime, zoom);\n                    const nearestPoint = findNearestSnapPoint(currentTime, snapPoints, 0.1, ['playhead']);\n                    if (nearestPoint) {\n                        newLeft = timeToPixels(nearestPoint.time, zoom);\n                        logger.debug('Snapped trim start to point:', {\n                            type: nearestPoint.type,\n                            time: nearestPoint.time,\n                            source: nearestPoint.source\n                        });\n                    }\n                }\n                const newDuration = dragState.originalEndPixels - newLeft;\n                if (newDuration >= minDurationPixels) {\n                    clipRef.current.style.left = `${Math.round(newLeft)}px`;\n                    clipRef.current.style.width = `${Math.round(newDuration)}px`;\n                    dragStateRef.current.lastDeltaPixels = newLeft - dragState.originalStartPixels;\n                    setIsAtLimit(newLeft === minLeftPos);\n                }\n            }\n            else if (dragState.isTrimming === 'end') {\n                const minDurationPixels = timeToPixels(TimelineConstants.MIN_DURATION, zoom);\n                const minLeftPos = timeToPixels(clip.startTime + TimelineConstants.MIN_DURATION, zoom);\n                // In ripple mode, allow extending up to full media duration\n                const maxRightPos = timeToPixels(clip.mediaOffset + clip.mediaDuration, zoom);\n                // Calculate target position\n                const pointerDelta = e.clientX - TRACK_LABEL_WIDTH - dragState.pointerDownX;\n                const proposedRight = dragState.originalEndPixels + pointerDelta;\n                let newRight = Math.max(minLeftPos, Math.min(maxRightPos, proposedRight));\n                // Apply snapping if enabled\n                if (state.isSnappingEnabled) {\n                    const currentTime = pixelsToTime(newRight, zoom);\n                    const snapPoints = getAllSnapPoints(state.tracks, state.markers, currentTime, zoom);\n                    const nearestPoint = findNearestSnapPoint(currentTime, snapPoints, 0.1, ['playhead']);\n                    if (nearestPoint) {\n                        newRight = timeToPixels(nearestPoint.time, zoom);\n                        logger.debug('Snapped trim end to point:', {\n                            type: nearestPoint.type,\n                            time: nearestPoint.time,\n                            source: nearestPoint.source\n                        });\n                    }\n                }\n                const newWidth = newRight - dragState.originalStartPixels;\n                // Calculate time delta based on pixel movement\n                const deltaPixels = newRight - dragState.originalEndPixels;\n                const deltaTime = pixelsToTime(deltaPixels, zoom);\n                logger.debug('Trim move calculation:', {\n                    deltaPixels,\n                    deltaTime,\n                    zoom,\n                    newRight,\n                    newWidth,\n                    originalEndPixels: dragState.originalEndPixels,\n                    originalStartPixels: dragState.originalStartPixels\n                });\n                // Log values for debugging\n                logger.debug('Trim move:', {\n                    newRight,\n                    newWidth,\n                    originalEndPixels: dragState.originalEndPixels,\n                    originalStartPixels: dragState.originalStartPixels,\n                    zoom,\n                    time: pixelsToTime(newRight, zoom)\n                });\n                if (newWidth >= minDurationPixels) {\n                    clipRef.current.style.width = `${Math.round(newWidth)}px`;\n                    dragStateRef.current.lastDeltaPixels = newRight - dragState.originalEndPixels;\n                    setIsAtLimit(newRight === maxRightPos);\n                    // Let useRippleEdit handle ripple mode trimming\n                }\n            }\n            clipRef.current.style.transition = 'none';\n        }\n    }, [clip, zoom, state, trimMode]);\n    const handlePointerUp = useCallback((e) => {\n        const dragState = dragStateRef.current;\n        if (dragState.pointerId === -1)\n            return;\n        // Release pointer capture\n        if (clipRef.current) {\n            try {\n                clipRef.current.releasePointerCapture(dragState.pointerId);\n            }\n            catch (err) {\n                // Ignore errors if pointer capture was already released\n            }\n        }\n        if (dragState.isDragging) {\n            const deltaPixels = dragState.lastDeltaPixels;\n            const deltaTime = pixelsToTime(deltaPixels, zoom);\n            if (Math.abs(deltaTime) > 0.01) {\n                const newStartTime = clip.startTime + deltaTime;\n                const newEndTime = clip.endTime + deltaTime;\n                timeline.updateClip(track.id, clip.id, {\n                    startTime: newStartTime,\n                    endTime: newEndTime,\n                    mediaOffset: clip.mediaOffset + deltaTime\n                });\n            }\n        }\n        else if (dragState.isTrimming === 'start') {\n            const deltaPixels = dragState.lastDeltaPixels;\n            const deltaTime = pixelsToTime(deltaPixels, zoom);\n            if (Math.abs(deltaTime) > 0.01) {\n                const newStartTime = clip.startTime + deltaTime;\n                const newMediaOffset = clip.mediaOffset + deltaTime;\n                timeline.trimClip(clip.id, newStartTime, undefined, 1.0, {\n                    handles: {\n                        startPosition: newMediaOffset,\n                        endPosition: newMediaOffset + (clip.endTime - newStartTime)\n                    },\n                    ripple: trimMode === 'ripple'\n                });\n            }\n        }\n        else if (dragState.isTrimming === 'end') {\n            const deltaPixels = dragState.lastDeltaPixels;\n            const deltaTime = pixelsToTime(deltaPixels, zoom);\n            if (Math.abs(deltaTime) > 0.01) {\n                // Calculate target end time based on mode\n                const targetEndTime = clip.endTime + deltaTime;\n                // In ripple mode, constrain to media duration\n                if (trimMode === 'ripple') {\n                    const maxEndTime = clip.mediaOffset + clip.mediaDuration;\n                    const constrainedEndTime = Math.min(targetEndTime, maxEndTime);\n                    logger.debug('Trim end calculation:', {\n                        clipId: clip.id,\n                        deltaPixels,\n                        deltaTime,\n                        clipEndTime: clip.endTime,\n                        targetEndTime,\n                        constrainedEndTime,\n                        zoom,\n                        trimMode,\n                        ripple: true\n                    });\n                    timeline.trimClip(clip.id, undefined, constrainedEndTime, 1.0, {\n                        handles: {\n                            startPosition: clip.mediaOffset,\n                            endPosition: clip.mediaOffset + (constrainedEndTime - clip.startTime)\n                        },\n                        ripple: true\n                    });\n                }\n                else {\n                    // In normal mode, just use the delta\n                    logger.debug('Trim end calculation:', {\n                        clipId: clip.id,\n                        deltaPixels,\n                        deltaTime,\n                        clipEndTime: clip.endTime,\n                        targetEndTime,\n                        zoom,\n                        trimMode,\n                        ripple: false\n                    });\n                    timeline.trimClip(clip.id, undefined, targetEndTime, 1.0, {\n                        handles: {\n                            startPosition: clip.mediaOffset,\n                            endPosition: Math.min(clip.mediaOffset + clip.mediaDuration, clip.mediaOffset + (targetEndTime - clip.startTime))\n                        },\n                        ripple: false\n                    });\n                }\n            }\n        }\n        // Reset drag state\n        dragStateRef.current = {\n            isDragging: false,\n            isTrimming: null,\n            pointerDownX: 0,\n            originalStartPixels: 0,\n            originalEndPixels: 0,\n            pointerId: -1,\n            scrollX: 0,\n            lastDeltaPixels: 0,\n            maxExtension: 0,\n        };\n        // Reset clip styles\n        if (clipRef.current) {\n            clipRef.current.style.transition = '';\n            clipRef.current.style.transform = '';\n            clipRef.current.style.willChange = '';\n        }\n        setIsDragging(false);\n        setIsTrimming(null);\n        setIsAtLimit(false);\n        onDragEnd();\n        dispatch({\n            type: ActionTypes.SET_DRAGGING,\n            payload: {\n                isDragging: false,\n                dragStartX: 0,\n                dragStartY: 0,\n            },\n        });\n    }, [clip, track, zoom, timeline, onDragEnd, dispatch, trimMode]);\n    const handlePointerDown = useCallback((e, trimSide) => {\n        // Determine trim mode based on modifier keys\n        if (trimSide) {\n            logger.debug('Pointer down with modifiers:', {\n                altKey: e.altKey,\n                shiftKey: e.shiftKey,\n                trimSide\n            });\n            if (e.altKey) {\n                setTrimMode('ripple');\n                // Force ripple mode immediately\n                setTimeout(() => {\n                    setTrimMode('ripple');\n                }, 0);\n            }\n            else if (e.shiftKey) {\n                setTrimMode('slip');\n            }\n            else {\n                setTrimMode('normal');\n            }\n        }\n        e.preventDefault();\n        e.stopPropagation();\n        const target = e.currentTarget;\n        target.setPointerCapture(e.pointerId);\n        const isTrimmingMode = trimSide ? (trimSide === 'trim-start' ? 'start' : 'end') : null;\n        // Calculate initial positions based on clip state\n        const startPixels = timeToPixels(clip.startTime, zoom);\n        const endPixels = timeToPixels(clip.endTime, zoom);\n        // Store original positions for drag calculations\n        const originalStartPixels = startPixels;\n        const originalEndPixels = endPixels;\n        // Calculate maximum allowed movement based on source media bounds (used for trimming)\n        let maxExtension = 0;\n        if (isTrimmingMode === 'start') {\n            const distanceToSourceStart = clip.startTime - clip.mediaOffset;\n            maxExtension = timeToPixels(distanceToSourceStart, zoom);\n        }\n        else if (isTrimmingMode === 'end') {\n            const sourceEndTime = clip.mediaOffset + clip.mediaDuration;\n            const distanceToSourceEnd = sourceEndTime - clip.endTime;\n            maxExtension = timeToPixels(distanceToSourceEnd, zoom);\n        }\n        else {\n            const distanceToSourceStart = clip.startTime - clip.mediaOffset;\n            const distanceToSourceEnd = (clip.mediaOffset + clip.mediaDuration) - (clip.startTime + (clip.endTime - clip.startTime));\n            maxExtension = Math.min(timeToPixels(distanceToSourceStart, zoom), timeToPixels(distanceToSourceEnd, zoom));\n        }\n        dragStateRef.current = {\n            isDragging: !isTrimmingMode,\n            isTrimming: isTrimmingMode,\n            pointerDownX: e.clientX - TRACK_LABEL_WIDTH,\n            originalStartPixels,\n            originalEndPixels,\n            pointerId: e.pointerId,\n            scrollX: state.scrollX,\n            lastDeltaPixels: 0,\n            maxExtension,\n        };\n        if (clipRef.current) {\n            clipRef.current.style.transform = '';\n            clipRef.current.style.transition = 'none';\n        }\n        onSelect();\n        onDragStart();\n        setIsDragging(!isTrimmingMode);\n        setIsTrimming(isTrimmingMode);\n        setIsAtLimit(false);\n        dispatch({\n            type: ActionTypes.SET_DRAGGING,\n            payload: {\n                isDragging: true,\n                dragStartX: e.clientX - TRACK_LABEL_WIDTH,\n                dragStartY: e.clientY,\n            },\n        });\n    }, [onSelect, onDragStart, clip, state.scrollX, zoom, dispatch]);\n    // Handle modifier keys for trim mode switching\n    useEffect(() => {\n        const handleKeyDown = (e) => {\n            if (isTrimming) {\n                logger.debug('Key down in trim mode:', {\n                    altKey: e.altKey,\n                    shiftKey: e.shiftKey,\n                    key: e.key,\n                    code: e.code\n                });\n                if (e.altKey) {\n                    setTrimMode('ripple');\n                    // Force ripple mode immediately\n                    setTimeout(() => {\n                        setTrimMode('ripple');\n                    }, 0);\n                }\n                else if (e.shiftKey) {\n                    setTrimMode('slip');\n                }\n                else {\n                    setTrimMode('normal');\n                }\n            }\n        };\n        const handleKeyUp = (e) => {\n            if (isTrimming) {\n                logger.debug('Key up in trim mode:', {\n                    altKey: e.altKey,\n                    shiftKey: e.shiftKey,\n                    key: e.key,\n                    code: e.code\n                });\n                if (!e.altKey && !e.shiftKey) {\n                    setTrimMode('normal');\n                }\n                else if (e.altKey) {\n                    setTrimMode('ripple');\n                }\n                else if (e.shiftKey) {\n                    setTrimMode('slip');\n                }\n            }\n        };\n        window.addEventListener('keydown', handleKeyDown, { capture: true });\n        window.addEventListener('keyup', handleKeyUp, { capture: true });\n        return () => {\n            window.removeEventListener('keydown', handleKeyDown, { capture: true });\n            window.removeEventListener('keyup', handleKeyUp, { capture: true });\n        };\n    }, [isTrimming]);\n    // Handle window pointer events\n    useEffect(() => {\n        const handleWindowPointerMove = (e) => {\n            handlePointerMove(e);\n        };\n        const handleWindowPointerUp = (e) => {\n            handlePointerUp(e);\n        };\n        const handleWindowMouseUp = (e) => {\n            // Also handle mouseup to ensure cleanup happens\n            if (dragStateRef.current.pointerId !== -1) {\n                handlePointerUp(new PointerEvent('pointerup', {\n                    pointerId: dragStateRef.current.pointerId,\n                    clientX: e.clientX,\n                    clientY: e.clientY,\n                    bubbles: true,\n                    cancelable: true,\n                }));\n            }\n        };\n        window.addEventListener('pointermove', handleWindowPointerMove);\n        window.addEventListener('pointerup', handleWindowPointerUp);\n        window.addEventListener('mouseup', handleWindowMouseUp);\n        return () => {\n            window.removeEventListener('pointermove', handleWindowPointerMove);\n            window.removeEventListener('pointerup', handleWindowPointerUp);\n            window.removeEventListener('mouseup', handleWindowMouseUp);\n        };\n    }, [handlePointerMove, handlePointerUp]);\n    const moveClip = useCallback((frameOffset) => {\n        const frameDuration = 1 / fps;\n        const timeOffset = frameOffset * frameDuration;\n        const proposedStartTime = clip.startTime + timeOffset;\n        const minStartTime = 0;\n        const maxStartTime = timeline.duration - (clip.endTime - clip.startTime);\n        const newStartTime = Math.max(minStartTime, Math.min(maxStartTime, proposedStartTime));\n        const duration = clip.endTime - clip.startTime;\n        timeline.updateClip(track.id, clip.id, {\n            startTime: newStartTime,\n            endTime: newStartTime + duration,\n            mediaOffset: clip.mediaOffset + (newStartTime - clip.startTime)\n        });\n    }, [clip, track, fps, timeline]);\n    const handleKeyDown = useCallback((e) => {\n        // Update trim mode based on modifier keys or specific keys when trimming\n        if (isTrimming) {\n            logger.debug('Key down in clip:', {\n                key: e.key,\n                code: e.code,\n                altKey: e.altKey,\n                shiftKey: e.shiftKey,\n                isTrimming\n            });\n            if (e.key === 'r' || e.key === 'R') {\n                e.preventDefault();\n                e.stopPropagation();\n                setTrimMode('ripple');\n                // Force ripple mode immediately and ensure it stays in ripple mode\n                setTimeout(() => {\n                    setTrimMode('ripple');\n                    // Dispatch a custom event to ensure ripple mode is set\n                    window.dispatchEvent(new CustomEvent('trimModeChange', {\n                        detail: { mode: 'ripple' }\n                    }));\n                }, 0);\n            }\n            else if (e.altKey) {\n                setTrimMode('ripple');\n            }\n            else if (e.shiftKey) {\n                setTrimMode('slip');\n            }\n            else {\n                setTrimMode('normal');\n            }\n        }\n        switch (e.key) {\n            case 'Enter':\n            case ' ':\n                e.preventDefault();\n                onSelect();\n                break;\n            case 'Delete':\n            case 'Backspace':\n                e.preventDefault();\n                rippleDelete(clip, track);\n                break;\n            case 'm':\n                if (!isKeyboardDragging) {\n                    e.preventDefault();\n                    setIsKeyboardDragging(true);\n                    onDragStart();\n                }\n                break;\n            case 'ArrowLeft':\n                if (isKeyboardDragging) {\n                    e.preventDefault();\n                    moveClip(e.shiftKey ? -KEYBOARD_MOVE_FAST : -KEYBOARD_MOVE_STEP);\n                }\n                break;\n            case 'ArrowRight':\n                if (isKeyboardDragging) {\n                    e.preventDefault();\n                    moveClip(e.shiftKey ? KEYBOARD_MOVE_FAST : KEYBOARD_MOVE_STEP);\n                }\n                break;\n            case 'Escape':\n                if (isKeyboardDragging) {\n                    e.preventDefault();\n                    setIsKeyboardDragging(false);\n                    onDragEnd();\n                }\n                break;\n            case 'r':\n            case 'R':\n                if (isTrimming) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    setTrimMode('ripple');\n                    // Force ripple mode immediately\n                    setTimeout(() => {\n                        setTrimMode('ripple');\n                    }, 0);\n                }\n                break;\n            case 's':\n            case 'S':\n                if (isTrimming) {\n                    e.preventDefault();\n                    setTrimMode('slip');\n                }\n                else {\n                    e.preventDefault();\n                    dispatch({\n                        type: ActionTypes.SET_SNAPPING,\n                        payload: !state.isSnappingEnabled\n                    });\n                }\n                break;\n            case 'n':\n            case 'N':\n                if (isTrimming) {\n                    e.preventDefault();\n                    setTrimMode('normal');\n                }\n                break;\n        }\n    }, [isKeyboardDragging, onSelect, onDragStart, onDragEnd, moveClip, clip, track, rippleDelete, isTrimming]);\n    const renderClipContent = () => {\n        if (isVideoClip(clip)) {\n            return (React.createElement(VideoClipContent, { clip: clip, isSelected: state.selectedClipIds.includes(clip.id), zoom: zoom, fps: fps }));\n        }\n        if (isAudioClip(clip)) {\n            return (React.createElement(AudioClipContent, { clip: clip, isSelected: state.selectedClipIds.includes(clip.id), zoom: zoom, fps: fps }));\n        }\n        if (isCaptionClip(clip)) {\n            return (React.createElement(CaptionClipContent, { clip: clip, isSelected: state.selectedClipIds.includes(clip.id), zoom: zoom, fps: fps }));\n        }\n        return null;\n    };\n    const startTimeFormatted = formatTime(clip.startTime, { fps, showFrames: true });\n    const endTimeFormatted = formatTime(clip.endTime, { fps, showFrames: true });\n    const durationFormatted = formatTime(clip.endTime - clip.startTime, { fps, showFrames: true });\n    const clipDuration = clip.endTime - clip.startTime;\n    const sourceStart = clip.mediaOffset;\n    const sourceEnd = clip.mediaOffset + clip.mediaDuration;\n    const clipStart = Math.max(clip.startTime, sourceStart);\n    const clipEnd = Math.min(clip.endTime, sourceEnd);\n    // In ripple mode, allow the clip to extend beyond its media duration\n    const currentDuration = trimMode === 'ripple' ? clipDuration : Math.min(clipDuration, clip.mediaDuration);\n    const widthPixels = Math.max(0, Math.round(timeToPixels(currentDuration, zoom)));\n    if (clipDuration > clip.mediaDuration) {\n        logger.warn('Clip exceeds source media duration:', {\n            clipId: clip.id,\n            duration: clipDuration,\n            sourceStart,\n            sourceEnd,\n            mediaDuration: clip.mediaDuration\n        });\n    }\n    const initialLeft = timeToPixels(clip.startTime, zoom);\n    const clipStyle = {\n        position: 'absolute',\n        left: `${Math.round(initialLeft)}px`,\n        width: `${widthPixels}px`,\n        height: '100%',\n        cursor: isKeyboardDragging ? 'move' : dragStateRef.current.isTrimming ? 'col-resize' : isDragging ? 'grabbing' : 'grab',\n        top: style?.top,\n        willChange: isDragging ? 'transform' : undefined,\n        touchAction: 'none',\n        userSelect: 'none',\n        pointerEvents: 'auto',\n        zIndex: isDragging || isTrimming ? 100 : 1,\n        opacity: clipDuration > clip.mediaDuration ? 0.7 : 1\n    };\n    return (React.createElement(\"div\", { ref: clipRef, \"data-testid\": \"timeline-clip\", className: `timeline-clip ${clip.type} ${isKeyboardDragging ? 'keyboard-dragging' : ''} ${state.selectedClipIds.includes(clip.id) ? 'selected' : ''}`, style: clipStyle, onPointerDown: handlePointerDown, onKeyDown: handleKeyDown, role: \"listitem\", \"aria-label\": `${clip.name} clip from ${startTimeFormatted} to ${endTimeFormatted}, duration ${durationFormatted}`, \"aria-grabbed\": isKeyboardDragging, \"aria-dropeffect\": \"move\", tabIndex: tabIndex, \"aria-posinset\": posinset, \"aria-setsize\": setsize, \"data-clip-id\": clip.id, \"data-moving\": isDragging || isTrimming ? 'true' : undefined, \"data-trimming\": isTrimming || undefined, \"data-at-limit\": isAtLimit || (clip.endTime - clip.startTime) > clip.mediaDuration || undefined, \"data-trim-mode\": trimMode },\n        isTrimming && React.createElement(TrimModeTooltip, { mode: trimMode }),\n        React.createElement(\"div\", { className: \"clip-handle left clip-trim-start\", onPointerDown: (e) => {\n                e.stopPropagation();\n                handlePointerDown(e, 'trim-start');\n            }, style: {\n                position: 'absolute',\n                left: -8,\n                width: 16,\n                height: '100%',\n                cursor: 'col-resize',\n                zIndex: 10,\n                background: 'rgba(255, 255, 255, 0.1)',\n                opacity: 0,\n                transition: 'opacity 0.15s ease'\n            } }),\n        renderClipContent(),\n        React.createElement(\"div\", { className: \"clip-handle right clip-trim-end\", onPointerDown: (e) => {\n                e.stopPropagation();\n                handlePointerDown(e, 'trim-end');\n            }, style: {\n                position: 'absolute',\n                right: -8,\n                width: 16,\n                height: '100%',\n                cursor: 'col-resize',\n                zIndex: 10,\n                background: 'rgba(255, 255, 255, 0.1)',\n                opacity: 0,\n                transition: 'opacity 0.15s ease'\n            } }),\n        React.createElement(\"div\", { className: \"clip-duration\" },\n            durationFormatted,\n            clipDuration > clip.mediaDuration && (React.createElement(\"span\", { style: { fontSize: '0.8em', opacity: 0.7, marginLeft: '4px', color: '#ff6b6b' } },\n                \"(\",\n                formatTime(clip.mediaDuration, { fps, showFrames: true }),\n                \" source)\")))));\n};\n","__webpack_require__.h = () => (\"d18148fb9e18f2b3ef3f\")"],"names":[],"sourceRoot":""}
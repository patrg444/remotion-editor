{"version":3,"file":"renderer.b46896fbe93051c7f727.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAA0B;AACoC;AACA;AACK;AACtB;AACM;AACU;AACtD;AACP,YAAY,0DAAmB,CAAC,uEAAgB;AAChD,QAAQ,0DAAmB,CAAC,uEAAgB;AAC5C,YAAY,0DAAmB,UAAU,gEAAgE;AACzG,gBAAgB,0DAAmB,UAAU,0BAA0B;AACvE,oBAAoB,0DAAmB,CAAC,4DAAQ,IAAI,wBAAwB;AAC5E,gBAAgB,0DAAmB,UAAU,uBAAuB;AACpE,oBAAoB,0DAAmB,UAAU,sBAAsB;AACvE,wBAAwB,0DAAmB,UAAU,4BAA4B;AACjF,4BAA4B,0DAAmB,CAAC,4DAAS;AACzD,wBAAwB,0DAAmB,UAAU,0BAA0B;AAC/E,4BAA4B,0DAAmB,CAAC,sEAAc;AAC9D,oBAAoB,0DAAmB,UAAU,2BAA2B;AAC5E,wBAAwB,0DAAmB,CAAC,4EAAiB;AAC7D;AACA,iEAAe,GAAG,EAAC;;;;;;;;;;;ACtBN;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxRmC;AAC2B;AACvD;AACP,oBAAoB,iDAAU,CAAC,sEAAe;AAC9C;AACA;AACA;AACA;AACA;;;;;;;;;UCRA","sources":["webpack://remotion-editor/./src/renderer/App.tsx","webpack://remotion-editor/./src/renderer/contexts/TimelineContext.tsx","webpack://remotion-editor/./src/renderer/hooks/useTimelineContext.ts","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React from 'react';\nimport { TimelineProvider } from './contexts/TimelineContext';\nimport { MediaBinProvider } from './contexts/MediaBinContext';\nimport { TimelineContainer } from './components/TimelineContainer';\nimport MediaBin from './components/MediaBin';\nimport { Inspector } from './components/Inspector';\nimport { PreviewDisplay } from './components/PreviewDisplay';\nexport const App = () => {\n    return (React.createElement(TimelineProvider, null,\n        React.createElement(MediaBinProvider, null,\n            React.createElement(\"div\", { className: \"app-container app-root\", \"data-testid\": \"app-root\" },\n                React.createElement(\"div\", { className: \"app-sidebar\" },\n                    React.createElement(MediaBin, { className: \"media-bin\" })),\n                React.createElement(\"div\", { className: \"app-main\" },\n                    React.createElement(\"div\", { className: \"app-top\" },\n                        React.createElement(\"div\", { className: \"app-inspector\" },\n                            React.createElement(Inspector, null)),\n                        React.createElement(\"div\", { className: \"app-preview\" },\n                            React.createElement(PreviewDisplay, null))),\n                    React.createElement(\"div\", { className: \"app-timeline\" },\n                        React.createElement(TimelineContainer, null)))))));\n};\nexport default App;\n","\"use strict\";\n// ... (previous imports remain the same)\nconst timelineReducer = (state, action) => {\n    switch (action.type) {\n        case ActionTypes.CLEAR_STATE: {\n            return {\n                ...initialTimelineState,\n                history: {\n                    entries: [],\n                    currentIndex: -1\n                }\n            };\n        }\n        case ActionTypes.SET_STATE: {\n            return {\n                ...action.payload,\n                history: action.payload.history || state.history\n            };\n        }\n        case ActionTypes.UNDO: {\n            if (state.history.currentIndex > 0) {\n                const newIndex = state.history.currentIndex - 1;\n                const { inversePatches } = state.history.entries[newIndex];\n                // Create a fresh copy of state before applying patches\n                const stateCopy = JSON.parse(JSON.stringify(state));\n                const undone = applyPatches(stateCopy, inversePatches);\n                const finalState = {\n                    ...undone,\n                    history: {\n                        entries: state.history.entries,\n                        currentIndex: newIndex\n                    }\n                };\n                // Notify of undo completion\n                requestAnimationFrame(() => {\n                    window.dispatchEvent(new CustomEvent('timeline:undo-complete', {\n                        detail: {\n                            fromIndex: state.history.currentIndex,\n                            toIndex: newIndex,\n                            description: state.history.entries[newIndex].description\n                        }\n                    }));\n                });\n                return finalState;\n            }\n            return state;\n        }\n        case ActionTypes.REDO: {\n            if (state.history.currentIndex < state.history.entries.length - 1) {\n                const newIndex = state.history.currentIndex + 1;\n                const { patches } = state.history.entries[newIndex];\n                // Create a fresh copy of state before applying patches\n                const stateCopy = JSON.parse(JSON.stringify(state));\n                const redone = applyPatches(stateCopy, patches);\n                const finalState = {\n                    ...redone,\n                    history: {\n                        entries: state.history.entries,\n                        currentIndex: newIndex\n                    }\n                };\n                // Notify of redo completion\n                requestAnimationFrame(() => {\n                    window.dispatchEvent(new CustomEvent('timeline:redo-complete', {\n                        detail: {\n                            fromIndex: state.history.currentIndex,\n                            toIndex: newIndex,\n                            description: state.history.entries[newIndex].description\n                        }\n                    }));\n                });\n                return finalState;\n            }\n            return state;\n        }\n        default: {\n            const [nextState, patches, inversePatches] = produceWithPatches(state, draft => {\n                switch (action.type) {\n                    case ActionTypes.SET_DURATION:\n                        draft.duration = action.payload;\n                        break;\n                    case ActionTypes.SET_TRACKS:\n                        draft.tracks = action.payload;\n                        break;\n                    case ActionTypes.SET_CURRENT_TIME:\n                        draft.currentTime = action.payload;\n                        break;\n                    case ActionTypes.SET_PLAYING:\n                        draft.isPlaying = action.payload;\n                        break;\n                    case ActionTypes.SET_SCROLL_X:\n                        draft.scrollX = action.payload;\n                        break;\n                    case ActionTypes.SET_SCROLL_Y:\n                        draft.scrollY = action.payload;\n                        break;\n                    case ActionTypes.SET_ZOOM:\n                        draft.zoom = action.payload;\n                        break;\n                    case ActionTypes.SET_FPS:\n                        draft.fps = action.payload;\n                        break;\n                    case ActionTypes.SET_DRAGGING:\n                        draft.isDragging = action.payload.isDragging;\n                        draft.dragStartX = action.payload.dragStartX;\n                        draft.dragStartY = action.payload.dragStartY;\n                        break;\n                    case ActionTypes.SET_ERROR:\n                        draft.error = action.payload;\n                        break;\n                    case ActionTypes.ADD_TRACK:\n                        draft.tracks.push(action.payload.track);\n                        break;\n                    case ActionTypes.UPDATE_TRACK: {\n                        const trackIndex = draft.tracks.findIndex(t => t.id === action.payload.trackId);\n                        if (trackIndex !== -1) {\n                            draft.tracks[trackIndex] = {\n                                ...draft.tracks[trackIndex],\n                                ...action.payload.track\n                            };\n                        }\n                        break;\n                    }\n                    case ActionTypes.REMOVE_TRACK:\n                        draft.tracks = draft.tracks.filter(t => t.id !== action.payload.trackId);\n                        break;\n                    case ActionTypes.ADD_CLIP: {\n                        const trackToAddClip = draft.tracks.find(t => t.id === action.payload.trackId);\n                        if (trackToAddClip) {\n                            const newClip = {\n                                ...action.payload.clip,\n                                startTime: action.payload.clip.startTime ?? 0,\n                                endTime: action.payload.clip.endTime ?? (action.payload.clip.duration ?? 0)\n                            };\n                            trackToAddClip.clips.push(newClip);\n                            trackToAddClip.clips.sort((a, b) => a.startTime - b.startTime);\n                        }\n                        break;\n                    }\n                    case ActionTypes.UPDATE_CLIP: {\n                        const trackWithClip = draft.tracks.find(t => t.id === action.payload.trackId);\n                        if (trackWithClip) {\n                            const clipIndex = trackWithClip.clips.findIndex(c => c.id === action.payload.clipId);\n                            if (clipIndex !== -1) {\n                                trackWithClip.clips[clipIndex] = {\n                                    ...trackWithClip.clips[clipIndex],\n                                    ...action.payload.clip\n                                };\n                            }\n                        }\n                        break;\n                    }\n                    case ActionTypes.REMOVE_CLIP: {\n                        const trackToRemoveClip = draft.tracks.find(t => t.id === action.payload.trackId);\n                        if (trackToRemoveClip) {\n                            trackToRemoveClip.clips = trackToRemoveClip.clips.filter(c => c.id !== action.payload.clipId);\n                        }\n                        break;\n                    }\n                    case ActionTypes.SPLIT_CLIP: {\n                        const trackToSplit = draft.tracks.find(t => t.id === action.payload.trackId);\n                        if (trackToSplit) {\n                            const clipToSplit = trackToSplit.clips.find(c => c.id === action.payload.clipId);\n                            if (clipToSplit && action.payload.time > clipToSplit.startTime && action.payload.time < clipToSplit.endTime) {\n                                const splitPoint = action.payload.time;\n                                const firstDuration = splitPoint - clipToSplit.startTime;\n                                const originalMediaOffset = clipToSplit.mediaOffset ?? 0;\n                                const originalMediaDuration = clipToSplit.mediaDuration ?? (clipToSplit.endTime - clipToSplit.startTime);\n                                const firstMediaStart = originalMediaOffset;\n                                const firstMediaEnd = originalMediaOffset + firstDuration;\n                                const secondMediaStart = originalMediaOffset + firstDuration;\n                                const fullMediaDuration = originalMediaDuration;\n                                // Remove the original clip\n                                trackToSplit.clips = trackToSplit.clips.filter(c => c.id !== clipToSplit.id);\n                                // Create first clip\n                                const firstClip = {\n                                    ...clipToSplit,\n                                    id: `${clipToSplit.id}-1`,\n                                    startTime: clipToSplit.startTime,\n                                    endTime: splitPoint,\n                                    mediaOffset: firstMediaStart,\n                                    mediaDuration: fullMediaDuration,\n                                    handles: {\n                                        startPosition: firstMediaStart,\n                                        endPosition: firstMediaEnd\n                                    },\n                                    initialBounds: {\n                                        startTime: clipToSplit.startTime,\n                                        endTime: splitPoint,\n                                        mediaOffset: firstMediaStart,\n                                        mediaDuration: fullMediaDuration\n                                    }\n                                };\n                                // Create second clip\n                                const secondClip = {\n                                    ...clipToSplit,\n                                    id: `${clipToSplit.id}-2`,\n                                    startTime: splitPoint,\n                                    endTime: clipToSplit.endTime,\n                                    mediaOffset: secondMediaStart,\n                                    mediaDuration: fullMediaDuration,\n                                    handles: {\n                                        startPosition: secondMediaStart,\n                                        endPosition: secondMediaStart + (clipToSplit.endTime - splitPoint)\n                                    },\n                                    initialBounds: {\n                                        startTime: splitPoint,\n                                        endTime: clipToSplit.endTime,\n                                        mediaOffset: secondMediaStart,\n                                        mediaDuration: fullMediaDuration\n                                    }\n                                };\n                                // Add new clips\n                                trackToSplit.clips.push(firstClip, secondClip);\n                                trackToSplit.clips.sort((a, b) => a.startTime - b.startTime);\n                                // Update selection\n                                draft.selectedClipIds = [firstClip.id];\n                                // Notify of split completion\n                                requestAnimationFrame(() => {\n                                    window.dispatchEvent(new CustomEvent('timeline:clip-split', {\n                                        detail: {\n                                            trackId: trackToSplit.id,\n                                            originalClipId: clipToSplit.id,\n                                            splitTime: splitPoint,\n                                            firstClipId: firstClip.id,\n                                            secondClipId: secondClip.id,\n                                            firstClip: {\n                                                startTime: firstClip.startTime,\n                                                endTime: firstClip.endTime,\n                                                mediaOffset: firstClip.mediaOffset,\n                                                mediaDuration: firstClip.mediaDuration\n                                            },\n                                            secondClip: {\n                                                startTime: secondClip.startTime,\n                                                endTime: secondClip.endTime,\n                                                mediaOffset: secondClip.mediaOffset,\n                                                mediaDuration: secondClip.mediaDuration\n                                            }\n                                        }\n                                    }));\n                                });\n                            }\n                        }\n                        break;\n                    }\n                    case ActionTypes.SELECT_CLIPS:\n                        draft.selectedClipIds = action.payload.clipIds;\n                        break;\n                    case ActionTypes.SET_SELECTED_TRACK_ID:\n                        draft.selectedTrackId = action.payload;\n                        break;\n                }\n            });\n            if (isUndoable(action)) {\n                // Create a fresh copy of nextState before applying patches\n                const nextStateCopy = JSON.parse(JSON.stringify(nextState));\n                const finalState = produce(nextStateCopy, draft => {\n                    if (draft.history.currentIndex < draft.history.entries.length - 1) {\n                        draft.history.entries = draft.history.entries.slice(0, draft.history.currentIndex + 1);\n                    }\n                    const entry = {\n                        type: 'partial',\n                        timestamp: Date.now(),\n                        patches: JSON.parse(JSON.stringify(patches)),\n                        inversePatches: JSON.parse(JSON.stringify(inversePatches)),\n                        description: getHistoryDescription(action)\n                    };\n                    draft.history.entries.push(entry);\n                    draft.history.currentIndex++;\n                    if (draft.history.entries.length > TimelineConstants.History.MAX_HISTORY_SIZE) {\n                        draft.history.entries = draft.history.entries.slice(-TimelineConstants.History.MAX_HISTORY_SIZE);\n                        draft.history.currentIndex = draft.history.entries.length - 1;\n                    }\n                });\n                return finalState;\n            }\n            return nextState;\n        }\n    }\n};\n// ... (rest of the file remains the same)\n","import { useContext } from 'react';\nimport { TimelineContext } from '../contexts/TimelineContext';\nexport const useTimelineContext = () => {\n    const context = useContext(TimelineContext);\n    if (!context) {\n        throw new Error('useTimelineContext must be used within a TimelineProvider');\n    }\n    return context;\n};\n","__webpack_require__.h = () => (\"a2f53cb6b7f5309763c6\")"],"names":[],"sourceRoot":""}
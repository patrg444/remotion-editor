{"version":3,"file":"renderer.7d509ae62e8188a0068d.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAA8E;AAC5B;AACF;AACM;AACW;AACE;AACZ;AACM;AACpB;AACzC;AACO,iBAAiB,2CAAI,IAAI,oDAAoD;AACpF,YAAY,kBAAkB,EAAE,6EAAkB;AAClD,YAAY,eAAe,EAAE,+EAAmB;AAChD,yBAAyB,6CAAM;AAC/B,wBAAwB,6CAAM;AAC9B,4CAA4C,+CAAQ;AACpD,yBAAyB,6CAAM;AAC/B;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA,wBAAwB,4DAAW;AACnC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA,0BAA0B,wDAAW;AACrC;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,6BAA6B,kDAAW;AACxC,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kBAAkB,wDAAW;AAC7B;AACA,SAAS;AACT;AACA,KAAK;AACL,8BAA8B,kDAAW;AACzC;AACA,kBAAkB,wDAAW;AAC7B,uBAAuB;AACvB,SAAS;AACT,KAAK;AACL,6BAA6B,kDAAW;AACxC,QAAQ,iDAAM;AACd;AACA,kBAAkB,wDAAW;AAC7B,uBAAuB;AACvB,SAAS;AACT,KAAK;AACL,gCAAgC,kDAAW;AAC3C;AACA,kBAAkB,wDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,4BAA4B,kDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAW;AACjC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C,yCAAyC,OAAO;AAChD;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA,IAAI,gDAAS;AACb,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA,SAAS;AACT,KAAK;AACL,8BAA8B,kDAAW;AACzC;AACA,kBAAkB,wDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,8BAA8B,kDAAW;AACzC;AACA,kBAAkB,wDAAW;AAC7B,uBAAuB;AACvB,SAAS;AACT,KAAK;AACL,8BAA8B,kDAAW;AACzC;AACA,kBAAkB,wDAAW;AAC7B,uBAAuB;AACvB,SAAS;AACT,KAAK;AACL,4BAA4B,kDAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAW;AACjC;AACA,aAAa;AACb;AACA,KAAK;AACL,mCAAmC,kDAAW;AAC9C;AACA,kBAAkB,wDAAW;AAC7B;AACA;AACA,uCAAuC,uCAAuC;AAC9E;AACA,SAAS;AACT,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA,yBAAyB,kDAAW,CAAC,yDAAQ;AAC7C;AACA;AACA,KAAK,EAAE,qDAAQ;AACf;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA,KAAK;AACL;AACA,0BAA0B,kDAAW;AACrC;AACA;AACA;AACA;AACA,gBAAgB,iDAAM;AACtB;AACA,0BAA0B,wDAAW;AACrC,iBAAiB;AACjB;AACA;AACA,gBAAgB,iDAAM;AACtB;AACA,0BAA0B,wDAAW;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAM;AAC1B;AACA;AACA;AACA,qBAAqB;AACrB;AACA,oBAAoB,iDAAM;AAC1B;AACA,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,kDAAW;AACvC;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,0DAAmB,UAAU,kJAAkJ;AAC3L,QAAQ,0DAAmB,CAAC,yDAAa,IAAI,kNAAkN;AAC/P,QAAQ,0DAAmB,UAAU,4DAA4D;AACjG,YAAY,0DAAmB,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C,gBAAgB,0DAAmB,CAAC,+DAAgB,IAAI,gLAAgL;AACxO,gBAAgB,0DAAmB,CAAC,+DAAgB,IAAI,iLAAiL;AACzO,gBAAgB,0DAAmB,CAAC,2DAAc,IAAI,gaAAga;AACtd,CAAC;AACD;;;;;;;;;UC/SA","sources":["webpack://remotion-editor/./src/renderer/components/Timeline.tsx","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { useCallback, useRef, useEffect, useState, memo } from 'react';\nimport { TimelineTracks } from './TimelineTracks';\nimport { TimelineRuler } from './TimelineRuler';\nimport { TimelinePlayhead } from './TimelinePlayhead';\nimport { useTimelineContext } from '../hooks/useTimelineContext';\nimport { useTimelineViewport } from '../hooks/useTimelineViewport';\nimport { throttle, THROTTLE } from '../utils/throttle';\nimport { ActionTypes, isMediaClip } from '../types/timeline';\nimport { logger } from '../utils/logger';\nconst RULER_HEIGHT = 30;\nexport const Timeline = memo(({ containerWidth, scrollLeft, onScroll, onTimeUpdate }) => {\n    const { state, dispatch } = useTimelineContext();\n    const { timeToPixels } = useTimelineViewport();\n    const containerRef = useRef(null);\n    const timelineRef = useRef(null);\n    const [contentWidth, setContentWidth] = useState(0);\n    const lastStateRef = useRef(state);\n    // Update duration based on clips and media duration, but only when not dragging\n    useEffect(() => {\n        if (!state.isDragging) {\n            const maxEndTime = state.tracks.reduce((maxTime, track) => {\n                const trackEndTime = track.clips.reduce((trackMax, clip) => {\n                    const endTime = clip.endTime;\n                    const startTime = clip.startTime;\n                    if (isMediaClip(clip)) {\n                        const clipDuration = endTime - startTime;\n                        const availableDuration = clip.mediaDuration - clip.mediaOffset;\n                        return Math.max(trackMax, startTime + Math.min(clipDuration, availableDuration));\n                    }\n                    return Math.max(trackMax, endTime);\n                }, 0);\n                return Math.max(maxTime, trackEndTime);\n            }, 0);\n            // Only update if duration has changed significantly (>0.1s)\n            if (Math.abs(maxEndTime - state.duration) > 0.1) {\n                dispatch({\n                    type: ActionTypes.SET_DURATION,\n                    payload: Math.max(maxEndTime, 10) // Minimum 10 seconds duration\n                });\n            }\n        }\n    }, [state.tracks, dispatch, state.duration, state.isDragging]);\n    // Handle state updates and notify components\n    useEffect(() => {\n        const stateChanged = state !== lastStateRef.current;\n        lastStateRef.current = state;\n        if (stateChanged && containerRef.current) {\n            // Force reflow to ensure state changes are applied\n            void containerRef.current.offsetHeight;\n            // Notify that timeline state has changed\n            window.dispatchEvent(new CustomEvent('timeline:state-changed', {\n                detail: {\n                    tracks: state.tracks.map(t => ({\n                        id: t.id,\n                        clipCount: t.clips.length,\n                        clips: t.clips.map(c => ({\n                            id: c.id,\n                            startTime: c.startTime,\n                            endTime: c.endTime,\n                            layer: c.layer\n                        }))\n                    })),\n                    selectedClipIds: state.selectedClipIds,\n                    currentTime: state.currentTime,\n                    zoom: state.zoom\n                }\n            }));\n            // Wait for next frame to ensure DOM is updated\n            requestAnimationFrame(() => {\n                // Force another reflow to ensure all updates are applied\n                if (containerRef.current) {\n                    void containerRef.current.offsetHeight;\n                }\n            });\n        }\n    }, [state]);\n    // Memoize callback handlers to prevent unnecessary re-renders\n    const handleTimeChange = useCallback((time) => {\n        logger.debug('Time change in Timeline:', {\n            time,\n            zoom: state.zoom,\n            duration: state.duration,\n            scrollLeft,\n            containerWidth\n        });\n        dispatch({\n            type: ActionTypes.SET_CURRENT_TIME,\n            payload: time\n        });\n        onTimeUpdate(time);\n    }, [dispatch, onTimeUpdate, state.zoom, state.duration, scrollLeft, containerWidth]);\n    const handleSelectTrack = useCallback((trackId) => {\n        dispatch({\n            type: ActionTypes.SELECT_TRACK,\n            payload: { trackId }\n        });\n    }, [dispatch]);\n    const handleSelectClip = useCallback((clipId) => {\n        logger.debug('Selecting clip:', clipId);\n        dispatch({\n            type: ActionTypes.SELECT_CLIPS,\n            payload: { clipIds: [clipId] }\n        });\n    }, [dispatch]);\n    const handleClipDragStart = useCallback((clipId) => {\n        dispatch({\n            type: ActionTypes.SET_DRAGGING,\n            payload: {\n                isDragging: true,\n                dragStartX: 0,\n                dragStartY: 0\n            }\n        });\n    }, [dispatch]);\n    const handleSplitClip = useCallback((clipId, time) => {\n        const track = state.tracks.find(t => t.clips.some(c => c.id === clipId));\n        if (!track)\n            return;\n        const clip = track.clips.find(c => c.id === clipId);\n        if (!clip)\n            return;\n        // Only split if time is within clip bounds\n        if (time > clip.startTime && time < clip.endTime) {\n            dispatch({\n                type: ActionTypes.SPLIT_CLIP,\n                payload: {\n                    trackId: track.id,\n                    clipId,\n                    time\n                }\n            });\n            // Wait for next frame to ensure state is updated\n            requestAnimationFrame(() => {\n                // Notify that clip was split\n                window.dispatchEvent(new CustomEvent('timeline:clip-split', {\n                    detail: {\n                        trackId: track.id,\n                        originalClipId: clipId,\n                        splitTime: time,\n                        firstClipId: `${clipId}-1`,\n                        secondClipId: `${clipId}-2`\n                    }\n                }));\n            });\n        }\n    }, [state.tracks, dispatch]);\n    // Expose for testing\n    useEffect(() => {\n        logger.debug('Exposing timeline functions for testing');\n        const timelineFunctions = {\n            handleSelectClip,\n            handleSplitClip\n        };\n        window.timelineFunctions = timelineFunctions;\n        logger.debug('Timeline functions exposed:', {\n            isExposed: !!window.timelineFunctions,\n            functions: Object.keys(timelineFunctions)\n        });\n    }, [handleSelectClip, handleSplitClip]);\n    const handleClipDragEnd = useCallback(() => {\n        dispatch({\n            type: ActionTypes.SET_DRAGGING,\n            payload: {\n                isDragging: false,\n                dragStartX: 0,\n                dragStartY: 0\n            }\n        });\n    }, [dispatch]);\n    const handleUpdateTrack = useCallback((trackId, updates) => {\n        dispatch({\n            type: ActionTypes.UPDATE_TRACK,\n            payload: { trackId, track: updates }\n        });\n    }, [dispatch]);\n    const handleDeleteTrack = useCallback((trackId) => {\n        dispatch({\n            type: ActionTypes.REMOVE_TRACK,\n            payload: { trackId }\n        });\n    }, [dispatch]);\n    const handleMoveTrack = useCallback((trackId, direction) => {\n        const tracks = [...state.tracks];\n        const trackIndex = tracks.findIndex((track) => track.id === trackId);\n        if (trackIndex === -1)\n            return;\n        const newIndex = direction === 'up'\n            ? Math.max(0, trackIndex - 1)\n            : Math.min(tracks.length - 1, trackIndex + 1);\n        if (newIndex !== trackIndex) {\n            const [movedTrack] = tracks.splice(trackIndex, 1);\n            tracks.splice(newIndex, 0, movedTrack);\n            dispatch({\n                type: ActionTypes.SET_TRACKS,\n                payload: tracks\n            });\n        }\n    }, [dispatch, state.tracks]);\n    const handleToggleVisibility = useCallback((trackId) => {\n        dispatch({\n            type: ActionTypes.UPDATE_TRACK,\n            payload: {\n                trackId,\n                changes: (track) => ({ ...track, isVisible: !track.isVisible })\n            }\n        });\n    }, [dispatch]);\n    // Calculate content width based on duration and zoom, but only when not dragging\n    useEffect(() => {\n        if (!state.isDragging) {\n            const minWidth = containerWidth;\n            const durationWidth = state.duration * state.zoom * 100;\n            const newWidth = Math.max(minWidth, durationWidth);\n            setContentWidth(newWidth);\n            logger.debug('Timeline content width updated:', {\n                containerWidth,\n                durationWidth,\n                contentWidth: newWidth,\n                zoom: state.zoom,\n                duration: state.duration,\n                isDragging: state.isDragging\n            });\n        }\n    }, [containerWidth, state.duration, state.zoom, state.isDragging]);\n    // Handle scroll events with throttling\n    const handleScroll = useCallback(throttle((e) => {\n        const target = e.currentTarget;\n        onScroll(target.scrollLeft, target.scrollTop);\n    }, THROTTLE.SCROLL), [onScroll]);\n    // Sync scroll position from props\n    useEffect(() => {\n        if (containerRef.current && containerRef.current.scrollLeft !== scrollLeft) {\n            containerRef.current.scrollLeft = scrollLeft;\n        }\n    }, [scrollLeft]);\n    // Focus timeline on mount\n    useEffect(() => {\n        if (timelineRef.current) {\n            timelineRef.current.focus();\n        }\n    }, []);\n    // Handle keyboard shortcuts\n    const handleKeyDown = useCallback((e) => {\n        // Handle undo/redo shortcuts regardless of selection state\n        if (e.key === 'z' && (e.metaKey || e.ctrlKey)) {\n            e.preventDefault();\n            if (e.shiftKey) {\n                logger.debug('Redo shortcut pressed (Cmd/Ctrl + Shift + Z)');\n                dispatch({\n                    type: ActionTypes.REDO\n                });\n            }\n            else {\n                logger.debug('Undo shortcut pressed (Cmd/Ctrl + Z)');\n                dispatch({\n                    type: ActionTypes.UNDO\n                });\n            }\n            return;\n        }\n        // Only handle other shortcuts when a clip is selected\n        if (state.selectedClipIds.length === 1) {\n            switch (e.key) {\n                case 's':\n                case 'S':\n                    e.preventDefault();\n                    logger.debug('Split key pressed:', {\n                        selectedClipIds: state.selectedClipIds,\n                        currentTime: state.currentTime,\n                        tracks: state.tracks\n                    });\n                    handleSplitClip(state.selectedClipIds[0], state.currentTime);\n                    logger.debug('After split attempt:', {\n                        tracks: state.tracks\n                    });\n                    break;\n            }\n        }\n    }, [state.selectedClipIds, state.currentTime, handleSplitClip, dispatch]);\n    // Handle mouse events to maintain focus\n    const handleMouseDown = useCallback((e) => {\n        // Prevent focus loss when clicking inside timeline\n        if (timelineRef.current && !timelineRef.current.contains(document.activeElement)) {\n            timelineRef.current.focus();\n        }\n    }, []);\n    return (React.createElement(\"div\", { ref: timelineRef, className: \"timeline-wrapper\", \"data-testid\": \"timeline\", tabIndex: -1, onKeyDown: handleKeyDown, onMouseDown: handleMouseDown },\n        React.createElement(TimelineRuler, { currentTime: state.currentTime, duration: state.duration, zoom: state.zoom, fps: state.fps, onTimeChange: handleTimeChange, containerWidth: containerWidth, scrollLeft: scrollLeft, isDragging: state.isDragging }),\n        React.createElement(\"div\", { className: \"timeline-body\", \"data-testid\": \"timeline-body\" },\n            React.createElement(\"div\", { ref: containerRef, className: \"timeline-content\", \"data-testid\": \"timeline-content\", style: {\n                    width: contentWidth,\n                    minWidth: '100%',\n                    position: 'relative',\n                    overflow: 'visible',\n                    height: '100%',\n                    transform: 'none',\n                    transformOrigin: '0 0',\n                    willChange: 'transform'\n                }, onScroll: handleScroll },\n                React.createElement(TimelinePlayhead, { currentTime: state.currentTime, isPlaying: state.isPlaying, zoom: state.zoom, fps: state.fps, onTimeUpdate: handleTimeChange, className: \"ruler\", isDragging: state.isDragging }),\n                React.createElement(TimelinePlayhead, { currentTime: state.currentTime, isPlaying: state.isPlaying, zoom: state.zoom, fps: state.fps, onTimeUpdate: handleTimeChange, className: \"tracks\", isDragging: state.isDragging }),\n                React.createElement(TimelineTracks, { tracks: state.tracks, selectedTrackId: state.selectedTrackId, selectedClipIds: state.selectedClipIds, onSelectTrack: handleSelectTrack, onSelectClip: handleSelectClip, onClipDragStart: handleClipDragStart, onClipDragEnd: handleClipDragEnd, onUpdateTrack: handleUpdateTrack, onDeleteTrack: handleDeleteTrack, onMoveTrack: handleMoveTrack, onToggleVisibility: handleToggleVisibility, zoom: state.zoom, fps: state.fps })))));\n});\nTimeline.displayName = 'Timeline';\n","__webpack_require__.h = () => (\"74818fc6e3ab20aa03f1\")"],"names":[],"sourceRoot":""}
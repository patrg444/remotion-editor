{"version":3,"file":"renderer.c1d9909b0eec6e01c834.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAgF;AAChD;AACsC;AACf;AACQ;AACtB;AAC2B;AAC7D,wBAAwB,oDAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA,aAAa,wDAAW;AACxB;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,8CAAO;AAClB;AACA,4BAA4B,wDAAW;AACvC,mBAAmB,iEAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,YAAY,iDAAM;AAClB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,iEAAiE;AACjE;AACA;AACA;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA,iBAAiB,wDAAW;AAC5B;AACA;AACA;AACA;AACA,yBAAyB,mEAAe;AACxC;AACA,+CAA+C,uEAAiB;AAChE,qEAAqE,uEAAiB;AACtF;AACA;AACA;AACA,KAAK;AACL;AACO,4BAA4B,UAAU;AAC7C,8BAA8B,iDAAU,kBAAkB,iEAAoB;AAC9E,8CAA8C,qDAAc;AAC5D,IAAI,gDAAS;AACb;AACA,qCAAqC,gFAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,QAAQ;AACpF;AACA,+EAA+E,QAAQ;AACvF,aAAa;AACb,YAAY,iDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA,0BAA0B;AAC1B,aAAa;AACb;AACA,KAAK;AACL,YAAY,0DAAmB,6BAA6B,SAAS,mBAAmB;AACxF;AACO;AACP,oBAAoB,iDAAU;AAC9B;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9akC;AAC3B;AACP;AACA;AACA;AACA,QAAQ,2CAAM,0CAA0C,aAAa;AACrE;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,QAAQ,2CAAM,uCAAuC,+BAA+B;AACpF;AACA,0BAA0B;AAC1B;AACA,iBAAiB;AACjB;AACA;AACA,QAAQ,2CAAM;AACd;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oEAAoE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjQA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA,8CAA8C,OAAO;AACrD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;UChFA","sources":["webpack://remotion-editor/./src/renderer/contexts/TimelineContext.tsx","webpack://remotion-editor/./src/renderer/utils/historyDiff.ts","webpack://remotion-editor/./src/renderer/utils/timelineValidation.ts","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { createContext, useReducer, useContext, useEffect } from 'react';\nimport { produce } from 'immer';\nimport { ActionTypes, initialTimelineState } from '../types/timeline';\nimport { createStateDiff } from '../utils/historyDiff';\nimport { TimelineConstants } from '../utils/timelineConstants';\nimport { logger } from '../utils/logger';\nimport { validateTimelineState } from '../utils/timelineValidation';\nexport const TimelineContext = createContext(undefined);\nconst NON_UNDOABLE_ACTIONS = new Set([\n    'SET_CURRENT_TIME',\n    'SET_PLAYING',\n    'SET_SCROLL_X',\n    'SET_SCROLL_Y',\n    'SET_DRAGGING',\n    'SET_ERROR',\n    'RESTORE_SNAPSHOT',\n    'SET_IS_PLAYING',\n    'SET_IS_DRAGGING',\n    'SET_SELECTED_CLIP_IDS',\n    'SELECT_CLIPS',\n    'SET_SELECTED_TRACK_ID',\n    'SET_DURATION',\n    'CLEAR_STATE'\n]);\nconst CHECKPOINT_ACTIONS = new Set([\n    'ADD_TRACK',\n    'REMOVE_TRACK',\n    'ADD_CLIP',\n    'REMOVE_CLIP',\n    'SPLIT_CLIP',\n    'SET_TRACKS',\n    'MOVE_TRACK',\n    'MOVE_CLIP'\n]);\nconst getHistoryDescription = (action) => {\n    switch (action.type) {\n        case ActionTypes.ADD_TRACK:\n            return 'Add track';\n        case ActionTypes.REMOVE_TRACK:\n            return 'Remove track';\n        case ActionTypes.ADD_CLIP:\n            return 'Add clip';\n        case ActionTypes.REMOVE_CLIP:\n            return 'Remove clip';\n        case ActionTypes.MOVE_CLIP:\n            return 'Move clip';\n        case ActionTypes.SPLIT_CLIP:\n            return 'Split clip';\n        case ActionTypes.TRIM_CLIP:\n            return 'Trim clip';\n        case ActionTypes.SET_ZOOM:\n            return 'Change zoom';\n        case ActionTypes.SET_FPS:\n            return 'Change FPS';\n        default:\n            return action.type;\n    }\n};\nexport const timelineReducer = (state, action) => {\n    return produce(state, draft => {\n        // Add explicit handling for CLEAR_STATE\n        if (action.type === ActionTypes.CLEAR_STATE) {\n            return initialTimelineState;\n        }\n        let shouldCreateHistoryEntry = false;\n        let historyDescription = '';\n        let beforeState = state;\n        let isCheckpoint = false;\n        if (!NON_UNDOABLE_ACTIONS.has(action.type)) {\n            shouldCreateHistoryEntry = true;\n            historyDescription = getHistoryDescription(action);\n            beforeState = { ...state };\n            isCheckpoint = CHECKPOINT_ACTIONS.has(action.type);\n            logger.debug('Processing action:', {\n                type: action.type,\n                isCheckpoint,\n                description: historyDescription\n            });\n        }\n        switch (action.type) {\n            case ActionTypes.SET_STATE:\n                return action.payload;\n            case ActionTypes.SET_DURATION:\n                draft.duration = action.payload;\n                break;\n            case ActionTypes.SET_TRACKS:\n                draft.tracks = action.payload;\n                break;\n            case ActionTypes.SET_CURRENT_TIME:\n                draft.currentTime = action.payload.time;\n                break;\n            case ActionTypes.SET_PLAYING:\n                draft.isPlaying = action.payload;\n                break;\n            case ActionTypes.SET_SCROLL_X:\n                draft.scrollX = action.payload;\n                break;\n            case ActionTypes.SET_SCROLL_Y:\n                draft.scrollY = action.payload;\n                break;\n            case ActionTypes.SET_ZOOM:\n                draft.zoom = action.payload;\n                break;\n            case ActionTypes.SET_FPS:\n                draft.fps = action.payload;\n                break;\n            case ActionTypes.SET_DRAGGING:\n                draft.isDragging = action.payload.isDragging;\n                draft.dragStartX = action.payload.dragStartX;\n                draft.dragStartY = action.payload.dragStartY;\n                break;\n            case ActionTypes.SET_ERROR:\n                draft.error = action.payload;\n                break;\n            case ActionTypes.ADD_TRACK:\n                draft.tracks.push(action.payload.track);\n                break;\n            case ActionTypes.UPDATE_TRACK:\n                {\n                    const trackIndex = draft.tracks.findIndex(t => t.id === action.payload.trackId);\n                    if (trackIndex !== -1) {\n                        draft.tracks[trackIndex] = {\n                            ...draft.tracks[trackIndex],\n                            ...action.payload.track\n                        };\n                    }\n                }\n                break;\n            case ActionTypes.REMOVE_TRACK:\n                draft.tracks = draft.tracks.filter(t => t.id !== action.payload.trackId);\n                break;\n            case ActionTypes.ADD_CLIP:\n                {\n                    const trackToAddClip = draft.tracks.find(t => t.id === action.payload.trackId);\n                    if (trackToAddClip) {\n                        trackToAddClip.clips = trackToAddClip.clips.filter(c => c.id !== action.payload.clip.id);\n                        const newClip = {\n                            ...action.payload.clip,\n                            startTime: action.payload.clip.startTime ?? 0,\n                            endTime: action.payload.clip.endTime ?? (action.payload.clip.duration ?? 0),\n                            initialBounds: action.payload.clip.initialBounds || {\n                                startTime: action.payload.clip.startTime ?? 0,\n                                endTime: action.payload.clip.endTime ?? (action.payload.clip.duration ?? 0),\n                                mediaOffset: action.payload.clip.mediaOffset ?? 0,\n                                mediaDuration: action.payload.clip.mediaDuration ?? ((action.payload.clip.endTime ?? 0) - (action.payload.clip.startTime ?? 0))\n                            }\n                        };\n                        if (!trackToAddClip.clips.some(c => c.id === newClip.id)) {\n                            trackToAddClip.clips.push(newClip);\n                            trackToAddClip.clips.sort((a, b) => a.startTime - b.startTime);\n                        }\n                    }\n                }\n                break;\n            case ActionTypes.UPDATE_CLIP:\n                {\n                    const trackWithClip = draft.tracks.find(t => t.id === action.payload.trackId);\n                    if (trackWithClip) {\n                        const clipIndex = trackWithClip.clips.findIndex(c => c.id === action.payload.clipId);\n                        if (clipIndex !== -1) {\n                            trackWithClip.clips[clipIndex] = {\n                                ...trackWithClip.clips[clipIndex],\n                                ...action.payload.clip\n                            };\n                        }\n                    }\n                }\n                break;\n            case ActionTypes.REMOVE_CLIP:\n                {\n                    const trackToRemoveClip = draft.tracks.find(t => t.id === action.payload.trackId);\n                    if (trackToRemoveClip) {\n                        trackToRemoveClip.clips = trackToRemoveClip.clips.filter(c => c.id !== action.payload.clipId);\n                    }\n                }\n                break;\n            case ActionTypes.MOVE_CLIP:\n                {\n                    const sourceTrack = draft.tracks.find(t => t.id === action.payload.sourceTrackId);\n                    const targetTrack = draft.tracks.find(t => t.id === action.payload.targetTrackId);\n                    if (sourceTrack && targetTrack) {\n                        const clipToMove = sourceTrack.clips.find(c => c.id === action.payload.clipId);\n                        if (clipToMove) {\n                            const desiredStart = Math.max(0, action.payload.newTime);\n                            const delta = desiredStart - clipToMove.startTime;\n                            const newStartTime = clipToMove.startTime + delta;\n                            const newEndTime = clipToMove.endTime + delta;\n                            const updatedClip = {\n                                ...clipToMove,\n                                startTime: newStartTime,\n                                endTime: newEndTime,\n                                mediaOffset: clipToMove.mediaOffset + delta,\n                                handles: {\n                                    startPosition: (clipToMove.handles?.startPosition ?? clipToMove.mediaOffset) + delta,\n                                    endPosition: (clipToMove.handles?.endPosition ?? (clipToMove.mediaOffset + (clipToMove.endTime - clipToMove.startTime))) + delta\n                                },\n                                initialBounds: {\n                                    ...clipToMove.initialBounds,\n                                    startTime: newStartTime,\n                                    endTime: newEndTime,\n                                    mediaOffset: (clipToMove.initialBounds?.mediaOffset ?? clipToMove.mediaOffset) + delta,\n                                    mediaDuration: clipToMove.initialBounds?.mediaDuration ?? clipToMove.mediaDuration\n                                }\n                            };\n                            if (sourceTrack.id === targetTrack.id) {\n                                const clipIndex = sourceTrack.clips.findIndex(c => c.id === clipToMove.id);\n                                if (clipIndex !== -1) {\n                                    sourceTrack.clips[clipIndex] = updatedClip;\n                                }\n                            }\n                            else {\n                                sourceTrack.clips = sourceTrack.clips.filter(c => c.id !== clipToMove.id);\n                                targetTrack.clips.push(updatedClip);\n                            }\n                        }\n                    }\n                }\n                break;\n            case ActionTypes.TRIM_CLIP:\n                {\n                    for (const track of draft.tracks) {\n                        const clipToTrim = track.clips.find(c => c.id === action.payload.clipId);\n                        if (clipToTrim) {\n                            const oldEndTime = clipToTrim.endTime;\n                            const clipIndex = track.clips.findIndex(c => c.id === clipToTrim.id);\n                            const effectiveMax = ((clipToTrim.initialBounds?.mediaOffset ?? clipToTrim.mediaOffset) + (clipToTrim.initialBounds?.mediaDuration ?? clipToTrim.mediaDuration)) - clipToTrim.mediaOffset;\n                            const maxEndTime = clipToTrim.startTime + effectiveMax;\n                            const minEndTime = clipToTrim.startTime + 0.1;\n                            let newEndTime = oldEndTime;\n                            if (action.payload.ripple) {\n                                const dragTargetEndTime = action.payload.endTime ?? oldEndTime;\n                                const dragDirection = Math.sign(dragTargetEndTime - oldEndTime);\n                                const currentDuration = oldEndTime - clipToTrim.startTime;\n                                const isInitialState = Math.abs(currentDuration - 2) < 0.01;\n                                if (!draft.rippleState) {\n                                    draft.rippleState = {};\n                                }\n                                if (!(clipToTrim.id in draft.rippleState)) {\n                                    draft.rippleState[clipToTrim.id] = { initialExtensionDone: false };\n                                }\n                                if (dragDirection > 0) {\n                                    if (isInitialState && !draft.rippleState[clipToTrim.id].initialExtensionDone) {\n                                        newEndTime = Math.min(dragTargetEndTime, maxEndTime);\n                                        if (newEndTime > oldEndTime) {\n                                            draft.rippleState[clipToTrim.id].initialExtensionDone = true;\n                                        }\n                                    }\n                                    else if (draft.rippleState[clipToTrim.id].initialExtensionDone || !isInitialState) {\n                                        newEndTime = Math.min(dragTargetEndTime, maxEndTime);\n                                    }\n                                }\n                                else {\n                                    newEndTime = Math.max(dragTargetEndTime, minEndTime);\n                                }\n                            }\n                            else {\n                                newEndTime = action.payload.endTime !== undefined\n                                    ? Math.min(action.payload.endTime, maxEndTime)\n                                    : clipToTrim.endTime;\n                            }\n                            track.clips[clipIndex] = {\n                                ...clipToTrim,\n                                endTime: newEndTime,\n                                handles: action.payload.handles || {\n                                    startPosition: clipToTrim.mediaOffset,\n                                    endPosition: clipToTrim.mediaOffset + (newEndTime - clipToTrim.startTime)\n                                }\n                            };\n                            if (action.payload.ripple) {\n                                const deltaTime = newEndTime - oldEndTime;\n                                const subsequentClips = track.clips\n                                    .slice(clipIndex + 1)\n                                    .filter(c => c.startTime >= oldEndTime);\n                                subsequentClips.forEach((clipToMove) => {\n                                    const idx = track.clips.findIndex(c => c.id === clipToMove.id);\n                                    if (idx !== -1) {\n                                        const duration = clipToMove.endTime - clipToMove.startTime;\n                                        const newStart = clipToMove.startTime + deltaTime;\n                                        track.clips[idx] = {\n                                            ...clipToMove,\n                                            startTime: newStart,\n                                            endTime: newStart + duration,\n                                            mediaOffset: clipToMove.mediaOffset + deltaTime,\n                                            handles: {\n                                                startPosition: (clipToMove.handles?.startPosition ?? clipToMove.mediaOffset) + deltaTime,\n                                                endPosition: (clipToMove.handles?.endPosition ?? (clipToMove.mediaOffset + duration)) + deltaTime\n                                            },\n                                            initialBounds: {\n                                                ...clipToMove.initialBounds,\n                                                startTime: newStart,\n                                                endTime: newStart + duration,\n                                                mediaOffset: (clipToMove.initialBounds?.mediaOffset ?? clipToMove.mediaOffset) + deltaTime,\n                                                mediaDuration: clipToMove.initialBounds?.mediaDuration ?? clipToMove.mediaDuration\n                                            }\n                                        };\n                                    }\n                                });\n                                track.clips.sort((a, b) => a.startTime - b.startTime);\n                            }\n                        }\n                    }\n                }\n                break;\n            case ActionTypes.SPLIT_CLIP:\n                {\n                    const trackToSplit = draft.tracks.find(t => t.id === action.payload.trackId);\n                    if (trackToSplit) {\n                        const clipToSplit = trackToSplit.clips.find(c => c.id === action.payload.clipId);\n                        if (clipToSplit && action.payload.time > clipToSplit.startTime && action.payload.time < clipToSplit.endTime) {\n                            const splitPoint = action.payload.time;\n                            const firstDuration = splitPoint - clipToSplit.startTime;\n                            const originalMediaOffset = clipToSplit.initialBounds?.mediaOffset ?? clipToSplit.mediaOffset;\n                            const originalMediaDuration = clipToSplit.initialBounds?.mediaDuration ?? clipToSplit.mediaDuration;\n                            const firstMediaStart = originalMediaOffset;\n                            const firstMediaEnd = originalMediaOffset + firstDuration;\n                            const secondMediaStart = originalMediaOffset + firstDuration;\n                            const fullMediaDuration = originalMediaDuration;\n                            const firstClip = {\n                                ...clipToSplit,\n                                id: `${clipToSplit.id}-1`,\n                                endTime: splitPoint,\n                                mediaDuration: fullMediaDuration,\n                                mediaOffset: firstMediaStart,\n                                handles: {\n                                    startPosition: firstMediaStart,\n                                    endPosition: firstMediaEnd\n                                },\n                                initialBounds: {\n                                    startTime: clipToSplit.startTime,\n                                    endTime: splitPoint,\n                                    mediaOffset: firstMediaStart,\n                                    mediaDuration: fullMediaDuration\n                                }\n                            };\n                            const secondClip = {\n                                ...clipToSplit,\n                                id: `${clipToSplit.id}-2`,\n                                startTime: splitPoint,\n                                mediaOffset: secondMediaStart,\n                                mediaDuration: fullMediaDuration,\n                                handles: {\n                                    startPosition: secondMediaStart,\n                                    endPosition: secondMediaStart + (clipToSplit.endTime - splitPoint)\n                                },\n                                initialBounds: {\n                                    startTime: splitPoint,\n                                    endTime: clipToSplit.endTime,\n                                    mediaOffset: secondMediaStart,\n                                    mediaDuration: fullMediaDuration\n                                }\n                            };\n                            trackToSplit.clips = trackToSplit.clips.filter(c => c.id !== clipToSplit.id);\n                            trackToSplit.clips.push(firstClip, secondClip);\n                            trackToSplit.clips.sort((a, b) => a.startTime - b.startTime);\n                            draft.selectedClipIds = [firstClip.id, secondClip.id];\n                            if (!draft.rippleState) {\n                                draft.rippleState = {};\n                            }\n                            draft.rippleState[firstClip.id] = { initialExtensionDone: false };\n                            draft.rippleState[secondClip.id] = { initialExtensionDone: false };\n                        }\n                    }\n                }\n                break;\n            case ActionTypes.SELECT_CLIPS:\n                draft.selectedClipIds = action.payload.clipIds;\n                break;\n            case ActionTypes.SET_SELECTED_CLIP_IDS:\n                draft.selectedClipIds = action.payload;\n                break;\n            case ActionTypes.SET_SELECTED_TRACK_ID:\n                draft.selectedTrackId = action.payload;\n                break;\n        }\n        if (shouldCreateHistoryEntry) {\n            const diff = createStateDiff(beforeState, draft, historyDescription, isCheckpoint);\n            draft.history.entries.push(diff);\n            if (draft.history.entries.length > TimelineConstants.History.MAX_HISTORY_SIZE) {\n                draft.history.entries = draft.history.entries.slice(-TimelineConstants.History.MAX_HISTORY_SIZE);\n            }\n            draft.history.currentIndex = draft.history.entries.length - 1;\n        }\n    });\n};\nexport const TimelineProvider = ({ children }) => {\n    const [state, dispatch] = useReducer(timelineReducer, initialTimelineState);\n    const [isInitialized, setIsInitialized] = React.useState(false);\n    useEffect(() => {\n        try {\n            const validationErrors = validateTimelineState(state);\n            window.timelineState = {\n                ...state,\n                dispatch\n            };\n            window.timelineDispatch = dispatch;\n            setIsInitialized(true);\n            window.timelineReady = true;\n            const detail = {\n                state,\n                dispatch,\n                isValid: validationErrors.length === 0,\n                errors: validationErrors\n            };\n            window.dispatchEvent(new CustomEvent('timeline:initializing', { detail }));\n            requestAnimationFrame(() => {\n                window.dispatchEvent(new CustomEvent('timeline:initialized', { detail }));\n            });\n            logger.debug('[Timeline] Initialization complete:', detail);\n            return () => {\n                window.timelineReady = false;\n                window.timelineState = undefined;\n                window.timelineDispatch = undefined;\n            };\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            logger.error('[Timeline] Initialization failed:', new Error(errorMessage));\n            window.dispatchEvent(new CustomEvent('timeline:error', {\n                detail: { error: new Error(errorMessage), state }\n            }));\n        }\n    }, [state, dispatch]);\n    return (React.createElement(TimelineContext.Provider, { value: { state, dispatch } }, children));\n};\nexport const useTimelineContext = () => {\n    const context = useContext(TimelineContext);\n    if (!context) {\n        throw new Error('useTimelineContext must be used within a TimelineProvider');\n    }\n    return context;\n};\n","import { logger } from './logger';\nexport const createStateDiff = (before, after, description, isCheckpoint = false) => {\n    const timestamp = Date.now();\n    // For checkpoint actions, store full state snapshot\n    if (isCheckpoint) {\n        logger.debug('Creating checkpoint snapshot:', { description });\n        return {\n            type: 'full',\n            snapshot: { ...after },\n            timestamp,\n            description\n        };\n    }\n    const changes = {};\n    // Compare tracks\n    if (before.tracks !== after.tracks) {\n        changes.tracks = {\n            added: after.tracks?.filter(track => !before.tracks?.find(t => t.id === track.id)) || [],\n            removed: (before.tracks || [])\n                .filter(track => !after.tracks?.find(t => t.id === track.id))\n                .map(track => track.id),\n            modified: (before.tracks || [])\n                .filter(track => after.tracks?.find(t => t.id === track.id))\n                .map(track => {\n                const afterTrack = after.tracks.find(t => t.id === track.id);\n                const clipChanges = {\n                    added: afterTrack.clips.filter(clip => !track.clips.find(c => c.id === clip.id)),\n                    removed: track.clips\n                        .filter(clip => !afterTrack.clips.find(c => c.id === clip.id))\n                        .map(clip => clip.id),\n                    modified: track.clips\n                        .filter(clip => afterTrack.clips.find(c => c.id === clip.id))\n                        .map(clip => {\n                        const afterClip = afterTrack.clips.find(c => c.id === clip.id);\n                        return {\n                            id: clip.id,\n                            before: getDiffProperties(clip, afterClip),\n                            after: getDiffProperties(afterClip, clip)\n                        };\n                    })\n                        .filter(diff => Object.keys(diff.before).length > 0 ||\n                        Object.keys(diff.after).length > 0)\n                };\n                return {\n                    id: track.id,\n                    clips: clipChanges\n                };\n            })\n                .filter(trackDiff => trackDiff.clips.added?.length ||\n                trackDiff.clips.removed?.length ||\n                trackDiff.clips.modified?.length)\n        };\n    }\n    // Compare scalar properties\n    if (before.currentTime !== after.currentTime)\n        changes.currentTime = after.currentTime;\n    if (before.duration !== after.duration)\n        changes.duration = after.duration;\n    if (before.zoom !== after.zoom)\n        changes.zoom = after.zoom;\n    if (before.fps !== after.fps)\n        changes.fps = after.fps;\n    // Compare markers\n    if (before.markers !== after.markers) {\n        changes.markers = {\n            added: after.markers.filter(marker => !before.markers.find(m => m.id === marker.id)),\n            removed: before.markers\n                .filter(marker => !after.markers.find(m => m.id === marker.id))\n                .map(marker => marker.id),\n            modified: before.markers\n                .filter(marker => after.markers.find(m => m.id === marker.id))\n                .map(marker => {\n                const afterMarker = after.markers.find(m => m.id === marker.id);\n                return {\n                    id: marker.id,\n                    before: {\n                        time: marker.time,\n                        label: marker.label\n                    },\n                    after: {\n                        time: afterMarker.time,\n                        label: afterMarker.label\n                    }\n                };\n            })\n                .filter(diff => diff.before.time !== diff.after.time ||\n                diff.before.label !== diff.after.label)\n        };\n    }\n    return {\n        type: 'partial',\n        changes,\n        timestamp,\n        description\n    };\n};\nexport const applyStateDiff = (state, diff, reverse = false) => {\n    // For checkpoint diffs, directly use the snapshot\n    if (diff.type === 'full' && diff.snapshot) {\n        logger.debug('Restoring from checkpoint:', { description: diff.description });\n        if (reverse) {\n            return state; // Keep current state when undoing a checkpoint\n        }\n        return { ...diff.snapshot };\n    }\n    if (!diff.changes) {\n        logger.warn('Invalid diff: no changes or snapshot found');\n        return state;\n    }\n    const newState = { ...state };\n    // Apply track changes\n    if (diff.changes.tracks) {\n        const tracks = [...state.tracks];\n        const { added, removed, modified } = diff.changes.tracks;\n        if (reverse) {\n            // Remove added tracks\n            if (added) {\n                const addedIds = new Set(added.map(track => track.id));\n                newState.tracks = tracks.filter(track => !addedIds.has(track.id));\n            }\n            // Restore removed tracks\n            if (removed) {\n                const removedTracks = tracks.filter(track => removed.includes(track.id));\n                newState.tracks = [...newState.tracks, ...removedTracks];\n            }\n        }\n        else {\n            // Add new tracks\n            if (added)\n                newState.tracks = [...tracks, ...added];\n            // Remove tracks\n            if (removed) {\n                const removedIds = new Set(removed);\n                newState.tracks = tracks.filter(track => !removedIds.has(track.id));\n            }\n        }\n        // Apply track modifications\n        if (modified) {\n            modified.forEach(trackDiff => {\n                const track = newState.tracks.find(t => t.id === trackDiff.id);\n                if (!track)\n                    return;\n                const clips = [...track.clips];\n                const { added: addedClips, removed: removedClips, modified: modifiedClips } = trackDiff.clips;\n                if (reverse) {\n                    // Remove added clips\n                    if (addedClips) {\n                        const addedIds = new Set(addedClips.map(clip => clip.id));\n                        track.clips = clips.filter(clip => !addedIds.has(clip.id));\n                    }\n                    // Restore removed clips\n                    if (removedClips) {\n                        const removedClipsList = clips.filter(clip => removedClips.includes(clip.id));\n                        track.clips = [...track.clips, ...removedClipsList];\n                    }\n                }\n                else {\n                    // Add new clips\n                    if (addedClips)\n                        track.clips = [...clips, ...addedClips];\n                    // Remove clips\n                    if (removedClips) {\n                        const removedIds = new Set(removedClips);\n                        track.clips = clips.filter(clip => !removedIds.has(clip.id));\n                    }\n                }\n                // Apply clip modifications\n                if (modifiedClips) {\n                    modifiedClips.forEach(clipDiff => {\n                        const clip = track.clips.find(c => c.id === clipDiff.id);\n                        if (!clip)\n                            return;\n                        if (reverse) {\n                            Object.assign(clip, clipDiff.before);\n                        }\n                        else {\n                            Object.assign(clip, clipDiff.after);\n                        }\n                    });\n                }\n            });\n        }\n    }\n    // Apply scalar changes\n    if (reverse) {\n        if (diff.changes.currentTime !== undefined)\n            newState.currentTime = state.currentTime;\n        if (diff.changes.duration !== undefined)\n            newState.duration = state.duration;\n        if (diff.changes.zoom !== undefined)\n            newState.zoom = state.zoom;\n        if (diff.changes.fps !== undefined)\n            newState.fps = state.fps;\n    }\n    else {\n        if (diff.changes.currentTime !== undefined)\n            newState.currentTime = diff.changes.currentTime;\n        if (diff.changes.duration !== undefined)\n            newState.duration = diff.changes.duration;\n        if (diff.changes.zoom !== undefined)\n            newState.zoom = diff.changes.zoom;\n        if (diff.changes.fps !== undefined)\n            newState.fps = diff.changes.fps;\n    }\n    // Apply marker changes\n    if (diff.changes.markers) {\n        const markers = [...state.markers];\n        const { added, removed, modified } = diff.changes.markers;\n        if (reverse) {\n            // Remove added markers\n            if (added) {\n                const addedIds = new Set(added.map(marker => marker.id));\n                newState.markers = markers.filter(marker => !addedIds.has(marker.id));\n            }\n            // Restore removed markers\n            if (removed) {\n                const removedMarkers = markers.filter(marker => removed.includes(marker.id));\n                newState.markers = [...newState.markers, ...removedMarkers];\n            }\n        }\n        else {\n            // Add new markers\n            if (added)\n                newState.markers = [...markers, ...added];\n            // Remove markers\n            if (removed) {\n                const removedIds = new Set(removed);\n                newState.markers = markers.filter(marker => !removedIds.has(marker.id));\n            }\n        }\n        // Apply marker modifications\n        if (modified) {\n            modified.forEach(markerDiff => {\n                const marker = newState.markers.find(m => m.id === markerDiff.id);\n                if (!marker)\n                    return;\n                if (reverse) {\n                    marker.time = markerDiff.before.time;\n                    marker.label = markerDiff.before.label;\n                }\n                else {\n                    marker.time = markerDiff.after.time;\n                    marker.label = markerDiff.after.label;\n                }\n            });\n        }\n    }\n    return newState;\n};\nconst getDiffProperties = (obj1, obj2) => {\n    const diff = {};\n    for (const key in obj1) {\n        if (obj1[key] !== obj2[key]) {\n            diff[key] = obj1[key];\n        }\n    }\n    return diff;\n};\n","/**\n * Validates the timeline state structure and returns any validation errors\n */\nexport function validateTimelineState(state) {\n    const errors = [];\n    // Check required properties\n    if (!state) {\n        errors.push('Timeline state is undefined');\n        return errors;\n    }\n    // Check tracks array\n    if (!Array.isArray(state.tracks)) {\n        errors.push('Tracks must be an array');\n    }\n    else {\n        // Validate each track\n        state.tracks.forEach((track, index) => {\n            if (!track.id) {\n                errors.push(`Track at index ${index} is missing id`);\n            }\n            if (!track.name) {\n                errors.push(`Track at index ${index} is missing name`);\n            }\n            if (!track.type) {\n                errors.push(`Track at index ${index} is missing type`);\n            }\n            if (!Array.isArray(track.clips)) {\n                errors.push(`Track at index ${index} clips must be an array`);\n            }\n        });\n    }\n    // Check numeric properties\n    if (typeof state.currentTime !== 'number') {\n        errors.push('currentTime must be a number');\n    }\n    if (typeof state.duration !== 'number') {\n        errors.push('duration must be a number');\n    }\n    if (typeof state.zoom !== 'number') {\n        errors.push('zoom must be a number');\n    }\n    if (typeof state.fps !== 'number') {\n        errors.push('fps must be a number');\n    }\n    if (typeof state.scrollX !== 'number') {\n        errors.push('scrollX must be a number');\n    }\n    if (typeof state.scrollY !== 'number') {\n        errors.push('scrollY must be a number');\n    }\n    // Check boolean properties\n    if (typeof state.isPlaying !== 'boolean') {\n        errors.push('isPlaying must be a boolean');\n    }\n    if (typeof state.isDragging !== 'boolean') {\n        errors.push('isDragging must be a boolean');\n    }\n    // Check arrays\n    if (!Array.isArray(state.selectedClipIds)) {\n        errors.push('selectedClipIds must be an array');\n    }\n    if (!Array.isArray(state.selectedCaptionIds)) {\n        errors.push('selectedCaptionIds must be an array');\n    }\n    if (!Array.isArray(state.markers)) {\n        errors.push('markers must be an array');\n    }\n    // Check history\n    if (!state.history) {\n        errors.push('history is missing');\n    }\n    else {\n        if (!Array.isArray(state.history.entries)) {\n            errors.push('history.entries must be an array');\n        }\n        if (typeof state.history.currentIndex !== 'number') {\n            errors.push('history.currentIndex must be a number');\n        }\n    }\n    return errors;\n}\n","__webpack_require__.h = () => (\"2751d811dc1208249360\")"],"names":[],"sourceRoot":""}
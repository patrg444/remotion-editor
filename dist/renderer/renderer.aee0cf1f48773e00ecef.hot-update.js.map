{"version":3,"file":"renderer.aee0cf1f48773e00ecef.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,kBAAkB,iEAAiB;AACnC;AACA;AACA;AACA;AACO;AACP;AACA;AACA,qBAAqB,iEAAiB;AACtC;AACA;AACA;AACA;AACO;AACP,WAAW,iEAAiB;AAC5B;AACA;AACA;AACA;AACO;AACP,WAAW,iEAAiB;AAC5B;AACA;AACA;AACA;AACO;AACP,wCAAwC,iEAAiB,2BAA2B,iEAAiB;AACrG;AACA;AACA;AACA;AACO;AACP,mBAAmB,iEAAiB;AACpC;AACA;AACA;AACA;AACO;AACP,sBAAsB,iEAAiB;AACvC;AACA;AACA;AACA;AACO;AACP,+BAA+B,iEAAiB,uBAAuB,iEAAiB;AACxF;AACA;AACA;AACA;AACA;AACO;AACP,sCAAsC,iEAAiB;AACvD,mCAAmC,iEAAiB,kBAAkB,iEAAiB;AACvF;AACA;AACA;AACA;AACO;AACP,mCAAmC,iEAAiB,kBAAkB,iEAAiB;AACvF;;;;;;;;;UCrEA","sources":["webpack://remotion-editor/./src/renderer/utils/timelineScale.ts","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import { TimelineConstants } from './timelineConstants';\n/**\n * Timeline scale utilities for consistent coordinate/time conversions\n */\n/**\n * Convert time to pixels based on zoom level\n */\nexport const timeToPixels = (time, zoom) => {\n    // Normalize zoom level since test uses zoom: 50\n    const normalizedZoom = zoom / 50;\n    return time * TimelineConstants.Scale.PIXELS_PER_SECOND * normalizedZoom;\n};\n/**\n * Convert pixels to time based on zoom level\n */\nexport const pixelsToTime = (pixels, zoom) => {\n    // Normalize zoom level since test uses zoom: 50\n    const normalizedZoom = zoom / 50;\n    return pixels / (TimelineConstants.Scale.PIXELS_PER_SECOND * normalizedZoom);\n};\n/**\n * Get current pixels per second based on zoom level\n */\nexport const getPixelsPerSecond = (zoom) => {\n    return TimelineConstants.Scale.getScale(zoom);\n};\n/**\n * Get current pixels per frame based on zoom level and fps\n */\nexport const getPixelsPerFrame = (zoom, fps) => {\n    return TimelineConstants.Scale.getScale(zoom) / fps;\n};\n/**\n * Calculate minimum zoom level to fit duration in width\n */\nexport const getMinZoomLevel = (duration, width) => {\n    return Math.max(width / (duration * TimelineConstants.Scale.PIXELS_PER_SECOND), TimelineConstants.Scale.MIN_ZOOM);\n};\n/**\n * Calculate visible duration at current zoom level and width\n */\nexport const getVisibleDuration = (width, zoom) => {\n    return width / TimelineConstants.Scale.getScale(zoom);\n};\n/**\n * Calculate content width for duration at zoom level\n */\nexport const getContentWidth = (duration, zoom) => {\n    return duration * TimelineConstants.Scale.getScale(zoom);\n};\n/**\n * Calculate minimum width needed to display duration at zoom level\n */\nexport const getMinWidth = (duration, zoom) => {\n    return Math.max(duration * TimelineConstants.Scale.getScale(zoom), TimelineConstants.UI.MIN_TRACK_WIDTH);\n};\n/**\n * Calculate optimal zoom level for a given duration and width\n * with optional padding factor (1.0 = no padding, 1.1 = 10% padding)\n */\nexport const getOptimalZoom = (duration, width, padding = 1.0) => {\n    const zoom = (width / (duration * TimelineConstants.Scale.PIXELS_PER_SECOND)) / padding;\n    return Math.min(Math.max(zoom, TimelineConstants.Scale.MIN_ZOOM), TimelineConstants.Scale.MAX_ZOOM);\n};\n/**\n * Clamp zoom level to valid range\n */\nexport const clampZoom = (zoom) => {\n    return Math.min(Math.max(zoom, TimelineConstants.Scale.MIN_ZOOM), TimelineConstants.Scale.MAX_ZOOM);\n};\n","__webpack_require__.h = () => (\"f8be8ca38727cf8fe45f\")"],"names":[],"sourceRoot":""}
{"version":3,"file":"renderer.45b2478d3f6909d93fcb.hot-update.js","mappings":";;;;;;;;;;;;;;AAAA;AACO,4BAA4B,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,aAAa;AACb;AACA,KAAK,OAAO;AACZ;AACA,QAAQ,IAAuE;AAC/E;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4DAA4D,SAAS,mBAAmB;AACxF;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;UClEA","sources":["webpack://remotion-editor/./src/renderer/contexts/TimelineContext.tsx","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["// ... (previous code remains the same until TimelineProvider)\nexport const TimelineProvider = ({ children }) => {\n    console.log('[TimelineProvider] Mounting...');\n    const [state, dispatch] = useReducer(timelineReducer, {\n        ...initialTimelineState,\n        history: {\n            entries: [],\n            currentIndex: -1\n        }\n    });\n    const [isInitialized, setIsInitialized] = React.useState(false);\n    // One-time initialization effect\n    useEffect(() => {\n        console.log('[TimelineProvider] Mounting (one-time)...');\n        try {\n            // Step 1: Dispatch initializing event\n            window.dispatchEvent(new CustomEvent('timeline:initializing'));\n            // Step 2: Set up window properties\n            window.timelineDispatch = dispatch;\n            window.timelineState = state;\n            // Step 3: Dispatch ready event\n            window.dispatchEvent(new CustomEvent('timeline:dispatchReady'));\n            // Step 4: Set ready flag and dispatch initialized event\n            window.timelineReady = true;\n            window.dispatchEvent(new CustomEvent('timeline:initialized'));\n            setIsInitialized(true);\n            logger.debug('[Timeline] Initialization complete');\n            // No cleanup to avoid race conditions\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            logger.error('[TimelineProvider] Error initializing timeline:', new Error(errorMessage));\n            window.dispatchEvent(new CustomEvent('timeline:error', {\n                detail: { error: new Error(errorMessage) }\n            }));\n        }\n    }, []); // Empty deps array for one-time initialization\n    // Optional sync effect for development/testing\n    if (process.env.NODE_ENV !== 'production' || process.env.CYPRESS === 'true') {\n        useEffect(() => {\n            // Keep window.timelineState and window.timelineDispatch separate\n            window.timelineState = state;\n            window.timelineDispatch = dispatch;\n        }, [state, dispatch]);\n    }\n    // Separate effect for state validation\n    useEffect(() => {\n        try {\n            const validationErrors = validateTimelineState(state);\n            if (validationErrors.length > 0) {\n                logger.warn('[Timeline] State validation errors:', validationErrors);\n            }\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            logger.error('[Timeline] State validation failed:', new Error(errorMessage));\n        }\n    }, [state]);\n    return (React.createElement(TimelineContext.Provider, { value: { state, dispatch } }, children));\n};\nexport const useTimelineContext = () => {\n    const context = useContext(TimelineContext);\n    if (!context) {\n        throw new Error('useTimelineContext must be used within a TimelineProvider');\n    }\n    return context;\n};\n","__webpack_require__.h = () => (\"30778020738abb89a6ca\")"],"names":[],"sourceRoot":""}
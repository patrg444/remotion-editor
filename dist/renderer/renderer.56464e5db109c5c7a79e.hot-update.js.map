{"version":3,"file":"renderer.56464e5db109c5c7a79e.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;AAAiD;AACU;AACV;AAC1C,8BAA8B,wDAAwD;AAC7F,sBAAsB,6CAAM;AAC5B,kBAAkB,6CAAM;AACxB,uBAAuB,6CAAM;AAC7B,YAAY,aAAa,EAAE,uEAAe;AAC1C;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA,wCAAwC,4DAAW;AACnD;AACA;AACA;AACA,8BAA8B,4DAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,OAAO;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,0DAAmB,aAAa,uDAAuD,+BAA+B,sCAAsC;AACxK;AACA,iEAAe,kBAAkB,EAAC;;;;;;;;;;;;;;;;;AC1Q+B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qCAAqC;AAC5C,kBAAkB,6CAAM,GAAG;AAC3B,8CAA8C,+CAAQ,GAAG;AACzD,gCAAgC,+CAAQ,GAAG;AAC3C,uBAAuB,6CAAM;AAC7B,+BAA+B,6CAAM;AACrC;AACA;AACA;AACA;AACA,oBAAoB,kDAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA,+BAA+B;AAC/B;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,kDAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,gCAAgC;AACxH,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,gCAAgC;AACzH;AACA;AACA;AACA;AACA,8EAA8E,IAAI;AAClF;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA,+BAA+B;AAC/B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD,wCAAwC,uBAAuB;AAC/D;AACA;AACA,KAAK;AACL,uBAAuB,kDAAW;AAClC;AACA,2BAA2B;AAC3B,oBAAoB;AACpB,KAAK;AACL,2BAA2B,kDAAW;AACtC;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,SAAS;AACT;AACA,2BAA2B;AAC3B;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChOqD;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AAC+E;AAC/E;AACA,KAAK,6DAAc;AACnB;AACA,cAAc,6DAAc;AAC5B;AACA;AACA;AACA,sBAAsB,8DAAW;AACjC,yBAAyB,kEAAe;AACxC,uBAAuB,kEAAe;AACtC;AACA,KAAK;AACL,KAAK,6DAAc;AACnB;AACA,cAAc,6DAAc;AAC5B;AACA;AACA;AACA,sBAAsB,8DAAW;AACjC,yBAAyB,kEAAe;AACxC,uBAAuB,kEAAe;AACtC;AACA,KAAK;AACL,KAAK,6DAAc;AACnB;AACA,cAAc,6DAAc;AAC5B;AACA;AACA;AACA,sBAAsB,8DAAW;AACjC,yBAAyB,kEAAe;AACxC,uBAAuB,kEAAe;AACtC,uBAAuB,6DAAU;AACjC;AACA,KAAK;AACL,KAAK,6DAAc;AACnB;AACA,cAAc,6DAAc;AAC5B;AACA;AACA;AACA,sBAAsB,8DAAW;AACjC,yBAAyB,kEAAe;AACxC,uBAAuB,kEAAe;AACtC,uBAAuB,6DAAU;AACjC;AACA,KAAK;AACL,KAAK,6DAAc;AACnB;AACA,cAAc,6DAAc;AAC5B;AACA;AACA;AACA,sBAAsB,8DAAW;AACjC,yBAAyB,kEAAe;AACxC,uBAAuB,kEAAe;AACtC;AACA,KAAK;AACL,KAAK,6DAAc;AACnB;AACA,cAAc,6DAAc;AAC5B;AACA;AACA;AACA,sBAAsB,8DAAW;AACjC,yBAAyB,kEAAe;AACxC,uBAAuB,kEAAe;AACtC;AACA,KAAK;AACL,KAAK,6DAAc;AACnB;AACA,cAAc,6DAAc;AAC5B;AACA;AACA;AACA,sBAAsB,8DAAW;AACjC,yBAAyB,kEAAe;AACxC,uBAAuB,kEAAe;AACtC,uBAAuB,6DAAU;AACjC;AACA;AACA;AACA,iEAAe,WAAW,EAAC;;;;;;;;;UCjN3B","sources":["webpack://remotion-editor/./src/renderer/components/TransitionRenderer.tsx","webpack://remotion-editor/./src/renderer/hooks/useTextureCache.ts","webpack://remotion-editor/./src/renderer/transitions/shaders.ts","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\nimport { useTextureCache } from '../hooks/useTextureCache';\nimport transitions from '../transitions/shaders';\nexport const TransitionRenderer = ({ transition, fromClip, toClip, progress, width, height, }) => {\n    const canvasRef = useRef(null);\n    const glRef = useRef(null);\n    const programRef = useRef(null);\n    const { getTexture } = useTextureCache();\n    // Initialize WebGL context and handle context loss/restore\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        if (!canvas)\n            return;\n        const gl = canvas.getContext('webgl2', {\n            powerPreference: 'high-performance',\n            alpha: true,\n            depth: false,\n            stencil: false,\n            antialias: false,\n            preserveDrawingBuffer: true,\n            premultipliedAlpha: false\n        });\n        if (!gl) {\n            console.error('WebGL2 not supported');\n            return;\n        }\n        if (!gl) {\n            console.error('WebGL2 not supported');\n            return;\n        }\n        // Enable alpha blending\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        glRef.current = gl;\n        // Handle context loss\n        const handleContextLost = (e) => {\n            e.preventDefault();\n            console.log('WebGL context lost');\n            if (programRef.current) {\n                gl.deleteProgram(programRef.current);\n                programRef.current = null;\n            }\n        };\n        // Handle context restore\n        const handleContextRestored = (e) => {\n            console.log('WebGL context restored');\n            // Context will be reinitialized on next render\n        };\n        // Add event listeners with proper type casting\n        canvas.addEventListener('webglcontextlost', handleContextLost);\n        canvas.addEventListener('webglcontextrestored', handleContextRestored);\n        // Clean up\n        return () => {\n            canvas.removeEventListener('webglcontextlost', handleContextLost);\n            canvas.removeEventListener('webglcontextrestored', handleContextRestored);\n            // Clean up WebGL resources\n            if (gl) {\n                // Delete any active textures\n                const maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n                for (let i = 0; i < maxTextureUnits; i++) {\n                    gl.activeTexture(gl.TEXTURE0 + i);\n                    gl.bindTexture(gl.TEXTURE_2D, null);\n                }\n                // Delete program if it exists\n                if (programRef.current) {\n                    gl.deleteProgram(programRef.current);\n                    programRef.current = null;\n                }\n                // Reset state\n                gl.bindBuffer(gl.ARRAY_BUFFER, null);\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                gl.useProgram(null);\n            }\n        };\n    }, []);\n    // Render transition\n    useEffect(() => {\n        const gl = glRef.current;\n        if (!gl || !transition.type || !transitions[transition.type]) {\n            console.error('Invalid transition type:', transition.type);\n            return;\n        }\n        const transitionDef = transitions[transition.type];\n        const renderFrame = async () => {\n            try {\n                // Load images with error handling\n                const [fromImage, toImage] = await Promise.all([\n                    fromClip.thumbnail ? getTexture(fromClip.thumbnail).catch(err => {\n                        console.error('Failed to load fromClip texture:', err);\n                        return null;\n                    }) : null,\n                    toClip.thumbnail ? getTexture(toClip.thumbnail).catch(err => {\n                        console.error('Failed to load toClip texture:', err);\n                        return null;\n                    }) : null,\n                ]);\n                if (!fromImage || !toImage) {\n                    throw new Error('Failed to load one or both textures');\n                }\n                // Create WebGL textures from images\n                const fromTexture = gl.createTexture();\n                const toTexture = gl.createTexture();\n                if (!fromTexture || !toTexture)\n                    return;\n                // Load first texture\n                gl.activeTexture(gl.TEXTURE0);\n                gl.bindTexture(gl.TEXTURE_2D, fromTexture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, fromImage);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                // Load second texture\n                gl.activeTexture(gl.TEXTURE1);\n                gl.bindTexture(gl.TEXTURE_2D, toTexture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, toImage);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                // Create and compile shaders\n                const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n                if (!vertexShader || !fragmentShader)\n                    return;\n                gl.shaderSource(vertexShader, transitionDef.vertexShader);\n                gl.shaderSource(fragmentShader, transitionDef.fragmentShader);\n                // Compile vertex shader\n                gl.compileShader(vertexShader);\n                const vertexSuccess = gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS);\n                if (!vertexSuccess) {\n                    const log = gl.getShaderInfoLog(vertexShader);\n                    console.error('Vertex shader compilation failed:', log);\n                    window.dispatchEvent(new CustomEvent('timeline:shader-error', {\n                        detail: { type: 'vertex', error: log }\n                    }));\n                    return;\n                }\n                // Compile fragment shader\n                gl.compileShader(fragmentShader);\n                const fragmentSuccess = gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS);\n                if (!fragmentSuccess) {\n                    const log = gl.getShaderInfoLog(fragmentShader);\n                    console.error('Fragment shader compilation failed:', log);\n                    window.dispatchEvent(new CustomEvent('timeline:shader-error', {\n                        detail: { type: 'fragment', error: log }\n                    }));\n                    return;\n                }\n                // Create and link program\n                const program = gl.createProgram();\n                if (!program)\n                    return;\n                gl.attachShader(program, vertexShader);\n                gl.attachShader(program, fragmentShader);\n                gl.linkProgram(program);\n                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                    console.error('Program linking failed:', gl.getProgramInfoLog(program));\n                    return;\n                }\n                gl.useProgram(program);\n                programRef.current = program;\n                // Enable alpha blending\n                gl.enable(gl.BLEND);\n                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n                // Set up uniforms\n                Object.entries(transitionDef.uniforms).forEach(([name, uniform]) => {\n                    const location = gl.getUniformLocation(program, name);\n                    if (!location)\n                        return;\n                    switch (name) {\n                        case 'progress':\n                            gl.uniform1f(location, progress);\n                            break;\n                        case 'fromTexture':\n                            gl.uniform1i(location, 0);\n                            break;\n                        case 'toTexture':\n                            gl.uniform1i(location, 1);\n                            break;\n                        case 'direction':\n                            const dir = transition.params?.direction || 'right';\n                            let vec;\n                            switch (dir) {\n                                case 'right':\n                                    vec = [1, 0];\n                                    break;\n                                case 'left':\n                                    vec = [-1, 0];\n                                    break;\n                                case 'up':\n                                    vec = [0, -1];\n                                    break;\n                                case 'down':\n                                    vec = [0, 1];\n                                    break;\n                                default:\n                                    vec = [1, 0]; // Default to right\n                            }\n                            gl.uniform2fv(location, new Float32Array(vec));\n                            break;\n                        case 'scale':\n                            if (transition.params?.scale) {\n                                gl.uniform1f(location, transition.params.scale);\n                            }\n                            break;\n                    }\n                });\n                // Set up attributes\n                const positionBuffer = gl.createBuffer();\n                const positions = new Float32Array([\n                    -1, -1,\n                    1, -1,\n                    -1, 1,\n                    1, 1,\n                ]);\n                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n                const positionLocation = gl.getAttribLocation(program, 'position');\n                gl.enableVertexAttribArray(positionLocation);\n                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n                // Clear and draw\n                gl.clearColor(0, 0, 0, 0);\n                gl.clear(gl.COLOR_BUFFER_BIT);\n                gl.viewport(0, 0, width, height);\n                // Create and bind framebuffer\n                const framebuffer = gl.createFramebuffer();\n                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n                // Create and attach texture to framebuffer\n                const renderTexture = gl.createTexture();\n                gl.bindTexture(gl.TEXTURE_2D, renderTexture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);\n                // Check framebuffer status\n                const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n                if (status !== gl.FRAMEBUFFER_COMPLETE) {\n                    throw new Error(`Framebuffer is not complete: ${status}`);\n                }\n                gl.viewport(0, 0, width, height);\n                gl.clearColor(0, 0, 0, 0);\n                gl.clear(gl.COLOR_BUFFER_BIT);\n                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n                // Force a flush to ensure pixels are written\n                gl.flush();\n                gl.finish();\n                // Clean up\n                gl.deleteBuffer(positionBuffer);\n                gl.deleteShader(vertexShader);\n                gl.deleteShader(fragmentShader);\n                gl.deleteTexture(fromTexture);\n                gl.deleteTexture(toTexture);\n                gl.deleteFramebuffer(framebuffer);\n                gl.deleteTexture(renderTexture);\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            }\n            catch (error) {\n                console.error('Error rendering transition:', error);\n            }\n        };\n        renderFrame();\n    }, [transition, fromClip, toClip, progress, width, height, getTexture]);\n    return (React.createElement(\"canvas\", { ref: canvasRef, width: width, height: height, style: { width: '100%', height: '100%' }, \"data-testid\": \"transition-canvas\" }));\n};\nexport default TransitionRenderer;\n","import { useCallback, useRef, useState, useEffect } from 'react';\nconst DEFAULT_OPTIONS = {\n    maxCacheSize: 100,\n    expirationTime: 5 * 60 * 1000,\n    maxTextureSize: 4096, // Default max texture size\n};\nfunction isValidImageData(data) {\n    if (!data)\n        return false;\n    try {\n        // Check if it has required properties\n        const hasValidProps = 'width' in data &&\n            'height' in data &&\n            'data' in data &&\n            typeof data.width === 'number' &&\n            typeof data.height === 'number' &&\n            data.width > 0 &&\n            data.height > 0 &&\n            data.data instanceof Uint8ClampedArray;\n        if (!hasValidProps)\n            return false;\n        // Check data length\n        const expectedLength = data.width * data.height * 4;\n        return data.data.length === expectedLength;\n    }\n    catch (error) {\n        console.error('ImageData validation error:', error);\n        return false;\n    }\n}\nexport function useTextureCache(options = {}) {\n    const cache = useRef({});\n    const [loadingStates, setLoadingStates] = useState({});\n    const [errors, setErrors] = useState({});\n    const cleanupRef = useRef();\n    const initialCleanupDone = useRef(false);\n    const effectiveOptions = {\n        ...DEFAULT_OPTIONS,\n        ...options,\n    };\n    const cleanup = useCallback(() => {\n        const now = Date.now();\n        const entries = Object.entries(cache.current);\n        console.log('Cleanup - Initial cache size:', entries.length);\n        console.log('Cleanup - Cache entries:', entries.map(([key, entry]) => ({\n            key,\n            lastUsed: entry.lastUsed,\n            timeSinceLastUse: now - entry.lastUsed\n        })));\n        // Sort by last used time (most recently used first)\n        entries.sort(([, a], [, b]) => b.lastUsed - a.lastUsed);\n        // Keep track of removed entries\n        const removedKeys = [];\n        // First, remove expired entries\n        for (const [key, entry] of entries) {\n            if (now - entry.lastUsed > effectiveOptions.expirationTime) {\n                console.log('Cleanup - Removing expired entry:', key);\n                delete cache.current[key];\n                removedKeys.push(key);\n            }\n        }\n        // Then, if we're still over maxCacheSize, remove oldest entries\n        const remainingEntries = Object.entries(cache.current);\n        console.log('Cleanup - Remaining entries before size check:', remainingEntries.length);\n        if (remainingEntries.length > effectiveOptions.maxCacheSize) {\n            // Re-sort remaining entries by last used time\n            remainingEntries.sort(([, a], [, b]) => b.lastUsed - a.lastUsed);\n            // Keep only the most recently used entries up to maxCacheSize\n            const entriesToRemove = remainingEntries.slice(effectiveOptions.maxCacheSize);\n            console.log('Cleanup - Entries to remove due to size limit:', entriesToRemove.length);\n            for (const [key] of entriesToRemove) {\n                console.log('Cleanup - Removing entry due to size limit:', key);\n                delete cache.current[key];\n                removedKeys.push(key);\n            }\n        }\n        // Update loading states and errors if any entries were removed\n        if (removedKeys.length > 0) {\n            setLoadingStates(prev => {\n                const next = { ...prev };\n                removedKeys.forEach(key => {\n                    delete next[key];\n                });\n                return next;\n            });\n            setErrors(prev => {\n                const next = { ...prev };\n                removedKeys.forEach(key => {\n                    delete next[key];\n                });\n                return next;\n            });\n        }\n        console.log('Cleanup - Final cache size:', Object.keys(cache.current).length);\n    }, [effectiveOptions.maxCacheSize, effectiveOptions.expirationTime]);\n    // Clean up expired textures\n    useEffect(() => {\n        if (options.disableAutoCleanup) {\n            return;\n        }\n        // Clear any existing interval\n        if (cleanupRef.current) {\n            clearInterval(cleanupRef.current);\n        }\n        // Set up new interval\n        cleanupRef.current = setInterval(cleanup, 60000); // Run cleanup every minute\n        // Run cleanup immediately only once\n        if (!initialCleanupDone.current) {\n            cleanup();\n            initialCleanupDone.current = true;\n        }\n        return () => {\n            if (cleanupRef.current) {\n                clearInterval(cleanupRef.current);\n            }\n        };\n    }, [cleanup, options.disableAutoCleanup]);\n    const getTexture = useCallback(async (source) => {\n        const key = source instanceof ImageData ? source.data.toString() : source;\n        console.log('getTexture - Current cache size:', Object.keys(cache.current).length);\n        console.log('getTexture - Loading texture:', key);\n        // Check texture size limits first\n        if (source instanceof ImageData) {\n            if (source.width > effectiveOptions.maxTextureSize || source.height > effectiveOptions.maxTextureSize) {\n                const error = new Error(`Texture size exceeds maximum allowed size of ${effectiveOptions.maxTextureSize}px`);\n                setErrors(prev => ({ ...prev, [key]: error }));\n                throw error;\n            }\n            // Then validate ImageData\n            if (!isValidImageData(source)) {\n                const error = new Error('Invalid ImageData provided');\n                setErrors(prev => ({ ...prev, [key]: error }));\n                throw error;\n            }\n        }\n        // Update last used time if in cache\n        if (cache.current[key]) {\n            console.log('getTexture - Found in cache:', key);\n            cache.current[key].lastUsed = Date.now();\n            return cache.current[key].image;\n        }\n        // Set loading state\n        setLoadingStates(prev => ({ ...prev, [key]: true }));\n        try {\n            let dataUrl = '';\n            if (source instanceof ImageData) {\n                const canvas = document.createElement('canvas');\n                canvas.width = source.width;\n                canvas.height = source.height;\n                const ctx = canvas.getContext('2d');\n                if (!ctx)\n                    throw new Error('Could not get canvas context');\n                ctx.putImageData(source, 0, 0);\n                dataUrl = canvas.toDataURL();\n            }\n            else {\n                dataUrl = source;\n            }\n            // Create and load the image\n            const img = new Image();\n            await new Promise((resolve, reject) => {\n                img.onload = () => {\n                    // Check texture size limits for loaded image\n                    if (img.width > effectiveOptions.maxTextureSize || img.height > effectiveOptions.maxTextureSize) {\n                        reject(new Error(`Texture size exceeds maximum allowed size of ${effectiveOptions.maxTextureSize}px`));\n                        return;\n                    }\n                    resolve();\n                };\n                img.onerror = () => reject(new Error(`Failed to load image: ${key}`));\n                img.src = dataUrl;\n            });\n            // Cache the loaded image\n            cache.current[key] = {\n                image: img,\n                lastUsed: Date.now(),\n                isLoading: false,\n            };\n            console.log('getTexture - Added to cache:', key);\n            console.log('getTexture - New cache size:', Object.keys(cache.current).length);\n            setLoadingStates(prev => ({ ...prev, [key]: false }));\n            setErrors(prev => {\n                const next = { ...prev };\n                delete next[key];\n                return next;\n            });\n            return img;\n        }\n        catch (error) {\n            const err = error instanceof Error ? error : new Error('Unknown error loading texture');\n            setErrors(prev => ({ ...prev, [key]: err }));\n            setLoadingStates(prev => ({ ...prev, [key]: false }));\n            throw err;\n        }\n    }, []);\n    const clearCache = useCallback(() => {\n        cache.current = {};\n        setLoadingStates({});\n        setErrors({});\n    }, []);\n    const refreshTexture = useCallback(async (source) => {\n        const key = source instanceof ImageData ? source.data.toString() : source;\n        delete cache.current[key];\n        setLoadingStates(prev => {\n            const next = { ...prev };\n            delete next[key];\n            return next;\n        });\n        setErrors(prev => {\n            const next = { ...prev };\n            delete next[key];\n            return next;\n        });\n        return getTexture(source);\n    }, [getTexture]);\n    return {\n        getTexture,\n        clearCache,\n        refreshTexture,\n        isLoading: loadingStates,\n        errors,\n        getCacheSize: () => Object.keys(cache.current).length,\n        _cleanup: cleanup, // Expose for testing\n    };\n}\n","import { TransitionType } from '../types/transition';\n// Common vertex shader (pass-through)\nconst commonVertexShader = `#version 300 es\nin vec2 position;\nout vec2 vUv;\n\nvoid main() {\n    vUv = position * 0.5 + 0.5;\n    gl_Position = vec4(position, 0.0, 1.0);\n}`;\n// Core fragment shaders\nconst dissolveShader = `#version 300 es\nprecision highp float;\n\nuniform sampler2D fromTexture;\nuniform sampler2D toTexture;\nuniform float progress;\n\nin vec2 vUv;\nout vec4 fragColor;\n\nvoid main() {\n    vec4 fromColor = texture(fromTexture, vUv);\n    vec4 toColor = texture(toTexture, vUv);\n    fragColor = mix(fromColor, toColor, progress);\n}`;\nconst fadeShader = `#version 300 es\nprecision highp float;\n\nuniform sampler2D fromTexture;\nuniform sampler2D toTexture;\nuniform float progress;\n\nin vec2 vUv;\nout vec4 fragColor;\n\nvoid main() {\n    vec4 fromColor = texture(fromTexture, vUv);\n    vec4 toColor = texture(toTexture, vUv);\n    fromColor.a = 1.0 - progress;\n    toColor.a = progress;\n    fragColor = mix(fromColor, toColor, progress);\n}`;\nconst slideShader = `#version 300 es\nprecision highp float;\n\nuniform sampler2D fromTexture;\nuniform sampler2D toTexture;\nuniform float progress;\nuniform vec2 direction;\n\nin vec2 vUv;\nout vec4 fragColor;\n\nvoid main() {\n    vec2 p = vUv + progress * direction;\n    vec2 f = clamp(p, 0.0, 1.0);\n    vec2 t = clamp(p - direction, 0.0, 1.0);\n    \n    vec4 fromColor = texture(fromTexture, f);\n    vec4 toColor = texture(toTexture, t);\n    \n    fragColor = mix(fromColor, toColor, step(0.0, progress * 2.0 - 1.0));\n}`;\nconst zoomShader = `#version 300 es\nprecision highp float;\n\nuniform sampler2D fromTexture;\nuniform sampler2D toTexture;\nuniform float progress;\n\nin vec2 vUv;\nout vec4 fragColor;\n\nvoid main() {\n    vec2 center = vec2(0.5, 0.5);\n    vec2 fromCoord = center + (vUv - center) * (1.0 - progress);\n    vec2 toCoord = center + (vUv - center) * progress;\n    \n    vec4 fromColor = texture(fromTexture, fromCoord);\n    vec4 toColor = texture(toTexture, toCoord);\n    \n    fragColor = mix(fromColor, toColor, progress);\n}`;\nconst pushShader = `#version 300 es\nprecision highp float;\n\nuniform sampler2D fromTexture;\nuniform sampler2D toTexture;\nuniform float progress;\nuniform vec2 direction;\n\nin vec2 vUv;\nout vec4 fragColor;\n\nvoid main() {\n    vec2 p = vUv - progress * direction;\n    vec2 f = clamp(p, 0.0, 1.0);\n    vec2 t = clamp(p + direction, 0.0, 1.0);\n    \n    vec4 fromColor = texture(fromTexture, f);\n    vec4 toColor = texture(toTexture, t);\n    \n    fragColor = mix(fromColor, toColor, step(1.0, p.x + p.y));\n}`;\nconst wipeShader = `#version 300 es\nprecision highp float;\n\nuniform sampler2D fromTexture;\nuniform sampler2D toTexture;\nuniform float progress;\nuniform vec2 direction;\n\nin vec2 vUv;\nout vec4 fragColor;\n\nvoid main() {\n    vec4 fromColor = texture(fromTexture, vUv);\n    vec4 toColor = texture(toTexture, vUv);\n    \n    float threshold = dot(vUv - 0.5, normalize(direction));\n    float edge = smoothstep(-0.1, 0.1, threshold - progress + 0.5);\n    \n    fragColor = mix(toColor, fromColor, edge);\n}`;\n// Import helper functions from types/transition\nimport { createFloat, createSampler2D, createVec2 } from '../types/transition';\nconst transitions = {\n    [TransitionType.Dissolve]: {\n        name: 'Dissolve',\n        type: TransitionType.Dissolve,\n        vertexShader: commonVertexShader,\n        fragmentShader: dissolveShader,\n        uniforms: {\n            progress: createFloat('progress'),\n            fromTexture: createSampler2D('fromTexture'),\n            toTexture: createSampler2D('toTexture')\n        }\n    },\n    [TransitionType.Fade]: {\n        name: 'Fade',\n        type: TransitionType.Fade,\n        vertexShader: commonVertexShader,\n        fragmentShader: fadeShader,\n        uniforms: {\n            progress: createFloat('progress'),\n            fromTexture: createSampler2D('fromTexture'),\n            toTexture: createSampler2D('toTexture')\n        }\n    },\n    [TransitionType.Wipe]: {\n        name: 'Wipe',\n        type: TransitionType.Wipe,\n        vertexShader: commonVertexShader,\n        fragmentShader: wipeShader,\n        uniforms: {\n            progress: createFloat('progress'),\n            fromTexture: createSampler2D('fromTexture'),\n            toTexture: createSampler2D('toTexture'),\n            direction: createVec2('direction')\n        }\n    },\n    [TransitionType.Slide]: {\n        name: 'Slide',\n        type: TransitionType.Slide,\n        vertexShader: commonVertexShader,\n        fragmentShader: slideShader,\n        uniforms: {\n            progress: createFloat('progress'),\n            fromTexture: createSampler2D('fromTexture'),\n            toTexture: createSampler2D('toTexture'),\n            direction: createVec2('direction')\n        }\n    },\n    [TransitionType.Crossfade]: {\n        name: 'Crossfade',\n        type: TransitionType.Crossfade,\n        vertexShader: commonVertexShader,\n        fragmentShader: dissolveShader,\n        uniforms: {\n            progress: createFloat('progress'),\n            fromTexture: createSampler2D('fromTexture'),\n            toTexture: createSampler2D('toTexture')\n        }\n    },\n    [TransitionType.Zoom]: {\n        name: 'Zoom',\n        type: TransitionType.Zoom,\n        vertexShader: commonVertexShader,\n        fragmentShader: zoomShader,\n        uniforms: {\n            progress: createFloat('progress'),\n            fromTexture: createSampler2D('fromTexture'),\n            toTexture: createSampler2D('toTexture')\n        }\n    },\n    [TransitionType.Push]: {\n        name: 'Push',\n        type: TransitionType.Push,\n        vertexShader: commonVertexShader,\n        fragmentShader: pushShader,\n        uniforms: {\n            progress: createFloat('progress'),\n            fromTexture: createSampler2D('fromTexture'),\n            toTexture: createSampler2D('toTexture'),\n            direction: createVec2('direction')\n        }\n    }\n};\nexport default transitions;\n","__webpack_require__.h = () => (\"ec33db9634f962eaaa1a\")"],"names":[],"sourceRoot":""}
{"version":3,"file":"renderer.8b6fa213c664bdd5cded.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAmD;AACS;AACK;AACnB;AACmB;AACxB;AACsB;AACxD,yBAAyB,0JAA0J;AAC1L,yBAAyB,6CAAM;AAC/B,YAAY,2CAA2C,EAAE,6EAAkB;AAC3E,YAAY,kBAAkB,EAAE,6EAAkB;AAClD;AACA,4BAA4B,kDAAW;AACvC;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL,6BAA6B,kDAAW;AACxC;AACA;AACA;AACA,KAAK;AACL,4BAA4B,kDAAW;AACvC;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,2BAA2B,kDAAW;AACtC;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,4BAA4B,kDAAW;AACvC;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,uBAAuB,kDAAW;AAClC;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA,YAAY,iDAAM;AAClB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kCAAkC,uEAAiB;AACnD,oFAAoF;AACpF,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,0CAA0C,2DAAU;AACpD;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA,yBAAyB;AACzB,iCAAiC;AACjC;AACA;AACA;AACA,0CAA0C,2DAAU;AACpD;AACA;AACA;AACA;AACA,yBAAyB;AACzB,iCAAiC;AACjC;AACA;AACA;AACA,4CAA4C,2DAAU;AACtD;AACA;AACA;AACA,yBAAyB;AACzB,iCAAiC;AACjC;AACA;AACA;AACA,kEAAkE,UAAU;AAC5E;AACA,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA,kCAAkC,wDAAW;AAC7C;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iDAAiD,WAAW,8BAA8B,UAAU;AACpG;AACA;AACA,gBAAgB,iDAAM;AACtB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,kDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI,iDAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,YAAY,0DAAmB,UAAU,iFAAiF,8BAA8B,EAAE,YAAY,EAAE,oCAAoC,yFAAyF,YAAY;AACjT;AACA,WAAW;AACX,QAAQ,0DAAmB,UAAU,oGAAoG,WAAW;AACpJ;AACA;AACA;AACA,aAAa;AACb,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA;AACA,2BAA2B,uEAAiB;AAC5C,iBAAiB;AACjB,eAAe;AACf,YAAY,iDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,oBAAoB,0DAAmB,CAAC,uDAAY,IAAI;AACxD;AACA,mBAAmB;AACnB,SAAS;AACT;;;;;;;;;UC9RA","sources":["webpack://remotion-editor/./src/renderer/components/TimelineTrack.tsx","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { useCallback, useRef } from 'react';\nimport { ActionTypes, createClip } from '../types/timeline';\nimport { useTimelineContext } from '../hooks/useTimelineContext';\nimport { TimelineClip } from './TimelineClip';\nimport { useLayerManagement } from '../hooks/useLayerManagement';\nimport { logger } from '../utils/logger';\nimport { TimelineConstants } from '../utils/timelineConstants';\nexport const TimelineTrack = ({ track, isSelected, zoom, fps, onSelectTrack, onSelectClip, onClipDragStart, onClipDragEnd, onToggleVisibility, onUpdateTrack, onDeleteTrack, onMoveTrack }) => {\n    const containerRef = useRef(null);\n    const { assignLayers, getTrackHeight, getClipTop } = useLayerManagement();\n    const { state, dispatch } = useTimelineContext();\n    // Get clips with optimized layer assignments\n    const clipsWithLayers = useCallback(() => {\n        const layeredClips = assignLayers(track.clips, track);\n        logger.debug('[TimelineTrack] Clips with layers:', {\n            trackId: track.id,\n            clips: layeredClips.map(c => ({\n                id: c.id,\n                layer: c.layer,\n                start: c.startTime,\n                end: c.endTime,\n                mediaOffset: c.mediaOffset,\n                mediaDuration: c.mediaDuration\n            }))\n        });\n        return layeredClips;\n    }, [track, assignLayers]);\n    const handleTrackClick = useCallback((e) => {\n        if (e.currentTarget === e.target) {\n            onSelectTrack(track.id);\n        }\n    }, [track.id, onSelectTrack]);\n    const handleDragEnter = useCallback((e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        logger.debug('Track drag enter:', {\n            target: e.target,\n            currentTarget: e.currentTarget,\n            className: e.currentTarget.className\n        });\n        e.currentTarget.classList.add('drag-over');\n    }, []);\n    const handleDragOver = useCallback((e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        logger.debug('Track drag over:', {\n            target: e.target,\n            currentTarget: e.currentTarget,\n            className: e.currentTarget.className\n        });\n        e.currentTarget.classList.add('drag-over');\n    }, []);\n    const handleDragLeave = useCallback((e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        logger.debug('Track drag leave:', {\n            target: e.target,\n            currentTarget: e.currentTarget,\n            className: e.currentTarget.className\n        });\n        e.currentTarget.classList.remove('drag-over');\n    }, []);\n    const handleDrop = useCallback((e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        e.currentTarget.classList.remove('drag-over');\n        try {\n            logger.debug('Drop event:', {\n                types: e.dataTransfer.types,\n                data: e.dataTransfer.getData('application/json'),\n                target: e.currentTarget.className,\n                currentTarget: e.currentTarget.className,\n                clientX: e.clientX,\n                clientY: e.clientY\n            });\n            const jsonData = e.dataTransfer.getData('application/json');\n            if (!jsonData) {\n                logger.error('No JSON data in drop event');\n                return;\n            }\n            const data = JSON.parse(jsonData);\n            logger.debug('Parsed drop data:', data);\n            // Log track state\n            logger.debug('Track state:', {\n                id: track.id,\n                type: track.type,\n                clips: track.clips?.length || 0\n            });\n            if (data) {\n                // Calculate time position based on drop coordinates\n                const trackRect = e.currentTarget.getBoundingClientRect();\n                const dropX = e.clientX - trackRect.left;\n                const timeScale = TimelineConstants.Scale.getScale(state.zoom);\n                const startTime = Math.max(0, (dropX + state.scrollX) / timeScale); // Convert to time, accounting for scroll\n                logger.debug('Time calculations:', {\n                    dropX,\n                    timeScale,\n                    startTime,\n                    trackRect: {\n                        left: trackRect.left,\n                        width: trackRect.width\n                    },\n                    zoom: state.zoom\n                });\n                // Create clip using helper\n                let clip;\n                // Create clip with proper duration properties\n                const initialDuration = data.duration;\n                const baseProps = {\n                    name: data.name,\n                    startTime,\n                    endTime: startTime + initialDuration,\n                    mediaOffset: 0,\n                    mediaDuration: initialDuration,\n                    originalDuration: initialDuration,\n                    initialDuration: initialDuration,\n                    effects: []\n                };\n                logger.debug('Creating clip with duration:', {\n                    duration: initialDuration,\n                    mediaDuration: initialDuration,\n                    originalDuration: initialDuration,\n                    startTime,\n                    endTime: startTime + initialDuration,\n                    maxAllowedDuration: initialDuration\n                });\n                switch (data.type) {\n                    case 'video': {\n                        const videoClip = createClip('video', {\n                            ...baseProps,\n                            src: data.path,\n                            transform: {\n                                scale: 1,\n                                rotation: 0,\n                                position: { x: 0, y: 0 },\n                                opacity: 1\n                            }\n                        });\n                        clip = { ...videoClip, layer: 0 };\n                        break;\n                    }\n                    case 'audio': {\n                        const audioClip = createClip('audio', {\n                            ...baseProps,\n                            src: data.path,\n                            volume: 1,\n                            isMuted: false\n                        });\n                        clip = { ...audioClip, layer: 0 };\n                        break;\n                    }\n                    case 'caption': {\n                        const captionClip = createClip('caption', {\n                            ...baseProps,\n                            text: '',\n                            captions: []\n                        });\n                        clip = { ...captionClip, layer: 0 };\n                        break;\n                    }\n                    default:\n                        throw new Error(`Unsupported clip type: ${data.type}`);\n                }\n                logger.debug('Created clip:', {\n                    ...clip,\n                    currentDuration: clip.endTime - clip.startTime,\n                    mediaDuration: clip.mediaDuration,\n                    mediaOffset: clip.mediaOffset,\n                    originalDuration: clip.originalDuration,\n                    maxAllowedDuration: clip.originalDuration || clip.mediaDuration,\n                    startTime: clip.startTime,\n                    endTime: clip.endTime\n                });\n                // Ensure track type matches clip type\n                if ((track.type === 'video' && data.type === 'video') ||\n                    (track.type === 'audio' && data.type === 'audio') ||\n                    (track.type === 'caption' && data.type === 'caption')) {\n                    // Update track with new clip\n                    const updatedClips = [...(track.clips || []), clip];\n                    onUpdateTrack(track.id, { clips: updatedClips });\n                    // Update timeline duration if needed\n                    const maxEndTime = Math.max(...updatedClips.map(c => c.endTime));\n                    if (maxEndTime > state.duration) {\n                        dispatch({\n                            type: ActionTypes.SET_DURATION,\n                            payload: Math.max(maxEndTime, 10)\n                        });\n                    }\n                }\n                else {\n                    console.error(`Track type (${track.type}) does not match clip type (${data.type})`);\n                    return;\n                }\n                logger.debug('Updated timeline:', {\n                    clipEndTime: clip.endTime,\n                    currentDuration: state.duration\n                });\n            }\n        }\n        catch (error) {\n            console.error('Error handling drop:', error);\n        }\n    }, [track.id, track.clips, onUpdateTrack, state, dispatch, state.zoom]);\n    const handleKeyDown = useCallback((e) => {\n        switch (e.key) {\n            case 'Enter':\n            case ' ':\n                e.preventDefault();\n                onSelectTrack(track.id);\n                break;\n            case 'ArrowUp':\n                e.preventDefault();\n                // Focus previous track\n                const prevTrack = containerRef.current?.previousElementSibling;\n                if (prevTrack instanceof HTMLElement) {\n                    prevTrack.focus();\n                }\n                break;\n            case 'ArrowDown':\n                e.preventDefault();\n                // Focus next track\n                const nextTrack = containerRef.current?.nextElementSibling;\n                if (nextTrack instanceof HTMLElement) {\n                    nextTrack.focus();\n                }\n                break;\n            case 'Tab':\n                // Let default tab behavior work, but ensure clips are in tab order\n                if (e.shiftKey && isSelected) {\n                    // When shift+tab on selected track, focus last clip\n                    const clips = containerRef.current?.querySelectorAll('.timeline-clip');\n                    const lastClip = clips?.[clips.length - 1];\n                    if (lastClip instanceof HTMLElement) {\n                        e.preventDefault();\n                        lastClip.focus();\n                    }\n                }\n                break;\n        }\n    }, [track.id, onSelectTrack, isSelected]);\n    const layeredClips = clipsWithLayers();\n    const trackHeight = getTrackHeight(layeredClips);\n    // Log track state before rendering\n    logger.debug('[TimelineTrack] Rendering track:', {\n        trackId: track.id,\n        clipCount: layeredClips.length,\n        trackHeight,\n        clips: layeredClips.map(clip => ({\n            id: clip.id,\n            startTime: clip.startTime,\n            endTime: clip.endTime,\n            layer: clip.layer,\n            mediaOffset: clip.mediaOffset,\n            mediaDuration: clip.mediaDuration\n        }))\n    });\n    return (React.createElement(\"div\", { ref: containerRef, \"data-testid\": \"timeline-track\", className: `timeline-track ${isSelected ? 'selected' : ''} ${track.type} ${!track.clips?.length ? 'empty' : ''}`, onClick: handleTrackClick, onKeyDown: handleKeyDown, role: \"region\", \"aria-label\": `${track.name} track`, \"aria-selected\": isSelected, tabIndex: 0, style: {\n            opacity: track.isVisible ? 1 : 0.5\n        } },\n        React.createElement(\"div\", { \"data-testid\": \"track-content\", className: \"track-content\", role: \"list\", \"aria-label\": `Clips in ${track.name}`, onDragEnter: handleDragEnter, onDragOver: handleDragOver, onDragLeave: handleDragLeave, onDrop: handleDrop, onMouseDown: (e) => {\n                if (e.target === e.currentTarget) {\n                    handleTrackClick(e);\n                }\n            }, onMouseMove: (e) => {\n                logger.debug('[TimelineTrack] Mouse move:', {\n                    clientX: e.clientX,\n                    offsetX: e.nativeEvent.offsetX,\n                    trackId: track.id,\n                    zoom: state.zoom,\n                    scale: TimelineConstants.Scale.getScale(state.zoom)\n                });\n            } }, layeredClips.map((clip, index) => {\n            logger.debug('[TimelineTrack] Rendering clip:', {\n                clipId: clip.id,\n                index,\n                startTime: clip.startTime,\n                endTime: clip.endTime,\n                layer: clip.layer,\n                mediaOffset: clip.mediaOffset,\n                mediaDuration: clip.mediaDuration,\n                top: getClipTop(clip.layer)\n            });\n            return (React.createElement(TimelineClip, { key: clip.id, clip: clip, track: track, layer: clip.layer, zoom: state.zoom, fps: state.fps, onSelect: () => onSelectClip(clip.id), onDragStart: () => onClipDragStart(clip.id), onDragEnd: onClipDragEnd, tabIndex: isSelected ? 0 : -1, \"aria-posinset\": index + 1, \"aria-setsize\": layeredClips.length, style: {\n                    top: getClipTop(clip.layer)\n                } }));\n        }))));\n};\n","__webpack_require__.h = () => (\"902a2778f17ddf24a92c\")"],"names":[],"sourceRoot":""}
{"version":3,"file":"renderer.2f75313aea73cd52b107.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;AAAiD;AACU;AACV;AAC1C,8BAA8B,wDAAwD;AAC7F,sBAAsB,6CAAM;AAC5B,kBAAkB,6CAAM;AACxB,uBAAuB,6CAAM;AAC7B,YAAY,aAAa,EAAE,uEAAe;AAC1C;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,gDAAS;AACb;AACA,wCAAwC,4DAAW;AACnD;AACA;AACA;AACA,8BAA8B,4DAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,0DAAmB,aAAa,uDAAuD,+BAA+B,sCAAsC;AACxK;AACA,iEAAe,kBAAkB,EAAC;;;;;;;;;UChOlC","sources":["webpack://remotion-editor/./src/renderer/components/TransitionRenderer.tsx","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\nimport { useTextureCache } from '../hooks/useTextureCache';\nimport transitions from '../transitions/shaders';\nexport const TransitionRenderer = ({ transition, fromClip, toClip, progress, width, height, }) => {\n    const canvasRef = useRef(null);\n    const glRef = useRef(null);\n    const programRef = useRef(null);\n    const { getTexture } = useTextureCache();\n    // Initialize WebGL context and handle context loss/restore\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        if (!canvas)\n            return;\n        const gl = canvas.getContext('webgl2', {\n            powerPreference: 'high-performance',\n            alpha: true,\n            depth: false,\n            stencil: false,\n            antialias: false,\n            preserveDrawingBuffer: true,\n            premultipliedAlpha: false\n        });\n        if (!gl) {\n            console.error('WebGL2 not supported');\n            return;\n        }\n        if (!gl) {\n            console.error('WebGL2 not supported');\n            return;\n        }\n        // Enable alpha blending\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n        glRef.current = gl;\n        // Handle context loss\n        const handleContextLost = (e) => {\n            e.preventDefault();\n            console.log('WebGL context lost');\n            if (programRef.current) {\n                gl.deleteProgram(programRef.current);\n                programRef.current = null;\n            }\n        };\n        // Handle context restore\n        const handleContextRestored = (e) => {\n            console.log('WebGL context restored');\n            // Context will be reinitialized on next render\n        };\n        // Add event listeners with proper type casting\n        canvas.addEventListener('webglcontextlost', handleContextLost);\n        canvas.addEventListener('webglcontextrestored', handleContextRestored);\n        // Clean up\n        return () => {\n            canvas.removeEventListener('webglcontextlost', handleContextLost);\n            canvas.removeEventListener('webglcontextrestored', handleContextRestored);\n            if (programRef.current) {\n                gl.deleteProgram(programRef.current);\n            }\n        };\n    }, []);\n    // Render transition\n    useEffect(() => {\n        const gl = glRef.current;\n        if (!gl || !transition.type || !transitions[transition.type]) {\n            console.error('Invalid transition type:', transition.type);\n            return;\n        }\n        const transitionDef = transitions[transition.type];\n        const renderFrame = async () => {\n            try {\n                // Load images\n                const [fromImage, toImage] = await Promise.all([\n                    fromClip.thumbnail ? getTexture(fromClip.thumbnail) : null,\n                    toClip.thumbnail ? getTexture(toClip.thumbnail) : null,\n                ]);\n                if (!fromImage || !toImage)\n                    return;\n                // Create WebGL textures from images\n                const fromTexture = gl.createTexture();\n                const toTexture = gl.createTexture();\n                if (!fromTexture || !toTexture)\n                    return;\n                // Load first texture\n                gl.activeTexture(gl.TEXTURE0);\n                gl.bindTexture(gl.TEXTURE_2D, fromTexture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, fromImage);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                // Load second texture\n                gl.activeTexture(gl.TEXTURE1);\n                gl.bindTexture(gl.TEXTURE_2D, toTexture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, toImage);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                // Create and compile shaders\n                const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n                if (!vertexShader || !fragmentShader)\n                    return;\n                gl.shaderSource(vertexShader, transitionDef.vertexShader);\n                gl.shaderSource(fragmentShader, transitionDef.fragmentShader);\n                // Compile vertex shader\n                gl.compileShader(vertexShader);\n                const vertexSuccess = gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS);\n                if (!vertexSuccess) {\n                    const log = gl.getShaderInfoLog(vertexShader);\n                    console.error('Vertex shader compilation failed:', log);\n                    window.dispatchEvent(new CustomEvent('timeline:shader-error', {\n                        detail: { type: 'vertex', error: log }\n                    }));\n                    return;\n                }\n                // Compile fragment shader\n                gl.compileShader(fragmentShader);\n                const fragmentSuccess = gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS);\n                if (!fragmentSuccess) {\n                    const log = gl.getShaderInfoLog(fragmentShader);\n                    console.error('Fragment shader compilation failed:', log);\n                    window.dispatchEvent(new CustomEvent('timeline:shader-error', {\n                        detail: { type: 'fragment', error: log }\n                    }));\n                    return;\n                }\n                // Create and link program\n                const program = gl.createProgram();\n                if (!program)\n                    return;\n                gl.attachShader(program, vertexShader);\n                gl.attachShader(program, fragmentShader);\n                gl.linkProgram(program);\n                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                    console.error('Program linking failed:', gl.getProgramInfoLog(program));\n                    return;\n                }\n                gl.useProgram(program);\n                programRef.current = program;\n                // Enable alpha blending\n                gl.enable(gl.BLEND);\n                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n                // Set up uniforms\n                Object.entries(transitionDef.uniforms).forEach(([name, uniform]) => {\n                    const location = gl.getUniformLocation(program, name);\n                    if (!location)\n                        return;\n                    switch (name) {\n                        case 'progress':\n                            gl.uniform1f(location, progress);\n                            break;\n                        case 'fromTexture':\n                            gl.uniform1i(location, 0);\n                            break;\n                        case 'toTexture':\n                            gl.uniform1i(location, 1);\n                            break;\n                        case 'direction':\n                            const dir = transition.params?.direction || 'right';\n                            let vec;\n                            switch (dir) {\n                                case 'right':\n                                    vec = [1, 0];\n                                    break;\n                                case 'left':\n                                    vec = [-1, 0];\n                                    break;\n                                case 'up':\n                                    vec = [0, -1];\n                                    break;\n                                case 'down':\n                                    vec = [0, 1];\n                                    break;\n                                default:\n                                    vec = [1, 0]; // Default to right\n                            }\n                            gl.uniform2fv(location, new Float32Array(vec));\n                            break;\n                        case 'scale':\n                            if (transition.params?.scale) {\n                                gl.uniform1f(location, transition.params.scale);\n                            }\n                            break;\n                    }\n                });\n                // Set up attributes\n                const positionBuffer = gl.createBuffer();\n                const positions = new Float32Array([\n                    -1, -1,\n                    1, -1,\n                    -1, 1,\n                    1, 1,\n                ]);\n                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);\n                const positionLocation = gl.getAttribLocation(program, 'position');\n                gl.enableVertexAttribArray(positionLocation);\n                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n                // Clear and draw\n                gl.clearColor(0, 0, 0, 0);\n                gl.clear(gl.COLOR_BUFFER_BIT);\n                gl.viewport(0, 0, width, height);\n                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n                // Force a flush to ensure pixels are written\n                gl.flush();\n                gl.finish();\n                // Clean up\n                // Clean up\n                gl.deleteBuffer(positionBuffer);\n                gl.deleteShader(vertexShader);\n                gl.deleteShader(fragmentShader);\n                gl.deleteTexture(fromTexture);\n                gl.deleteTexture(toTexture);\n            }\n            catch (error) {\n                console.error('Error rendering transition:', error);\n            }\n        };\n        renderFrame();\n    }, [transition, fromClip, toClip, progress, width, height, getTexture]);\n    return (React.createElement(\"canvas\", { ref: canvasRef, width: width, height: height, style: { width: '100%', height: '100%' }, \"data-testid\": \"transition-canvas\" }));\n};\nexport default TransitionRenderer;\n","__webpack_require__.h = () => (\"94354ef4d95f874df254\")"],"names":[],"sourceRoot":""}
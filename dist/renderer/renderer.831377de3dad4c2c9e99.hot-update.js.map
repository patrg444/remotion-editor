{"version":3,"file":"renderer.831377de3dad4c2c9e99.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAwE;AACI;AAChB;AACA;AACI;AACZ;AACE;AACS;AACR;AACU;AACd;AACI;AACH;AACpD;AACA;AACA;AACA;AACO,wBAAwB,0IAA0I;AACzK,wDAAwD,+CAAQ;AAChE,sCAAsC,+CAAQ;AAC9C,wCAAwC,+CAAQ;AAChD,wCAAwC,+CAAQ;AAChD,oCAAoC,+CAAQ;AAC5C,YAAY,2BAA2B,EAAE,mEAAa;AACtD,YAAY,kBAAkB,EAAE,6EAAkB;AAClD,qBAAqB,gEAAW;AAChC,YAAY,yCAAyC,EAAE,oEAAa;AACpE,oBAAoB,6CAAM;AAC1B;AACA,0BAA0B,6CAAM;AAChC,yBAAyB,6CAAM,GAAG,sEAAsE;AACxG;AACA,+BAA+B,gEAAU,mBAAmB,uBAAuB;AACnF,6BAA6B,gEAAU,iBAAiB,uBAAuB;AAC/E,8BAA8B,gEAAU,kCAAkC,uBAAuB;AACjG;AACA;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAY;AACrC,0BAA0B,kEAAY;AACtC,gCAAgC,uEAAiB;AACjD;AACA;AACA,4CAA4C,iBAAiB;AAC7D,6CAA6C,kBAAkB;AAC/D,2CAA2C,IAAI;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,8BAA8B,kDAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,kDAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,4DAAW;AACvB,oBAAoB,0DAAmB,CAAC,qEAAgB,IAAI,uFAAuF;AACnJ;AACA,YAAY,4DAAW;AACvB,oBAAoB,0DAAmB,CAAC,qEAAgB,IAAI,uFAAuF;AACnJ;AACA,YAAY,8DAAa;AACzB,oBAAoB,0DAAmB,CAAC,yEAAkB,IAAI,uFAAuF;AACrJ;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW,kEAAY,wBAAwB;AAChE,kBAAkB,WAAW,kEAAY,uCAAuC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAmB,UAAU,0EAA0E,WAAW,EAAE,+CAA+C,EAAE,0DAA0D,oHAAoH,WAAW,YAAY,oBAAoB,KAAK,iBAAiB,aAAa,kBAAkB,wYAAwY;AACv0B,sBAAsB,0DAAmB,CAAC,8DAAe,IAAI,gBAAgB;AAC7E,QAAQ,0DAAmB,UAAU;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,QAAQ,0DAAmB,UAAU;AACrC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,QAAQ,0DAAmB,UAAU,4BAA4B;AACjE;AACA,kDAAkD,0DAAmB,WAAW,SAAS,wEAAwE;AACjK;AACA,gBAAgB,gEAAU,uBAAuB,uBAAuB;AACxE;AACA;;;;;;;;;;;;;;;;;AC1L0B;AACnB,4BAA4B,6BAA6B;AAChE,YAAY,0DAAmB,UAAU,iCAAiC,6BAA6B,GAAG;AAC1G,QAAQ,0DAAmB,UAAU,yBAAyB;AAC9D,oCAAoC,0DAAmB,UAAU,2BAA2B,8BAA8B,0DAAmB,UAAU,qCAAqC,wCAAwC,GAAG;AACvO,iCAAiC,0DAAmB,UAAU,4CAA4C,WAAW;AACrH,uDAAuD,0DAAmB,UAAU,0CAA0C,YAAY;AAC1I,QAAQ,0DAAmB,UAAU,mCAAmC;AACxE;;;;;;;;;;;;;;;;;ACR0B;AACnB,8BAA8B,6BAA6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAmB,UAAU,mCAAmC,6BAA6B,GAAG;AAC5G,QAAQ,0DAAmB,UAAU,6BAA6B;AAClE,YAAY,0DAAmB,WAAW,4BAA4B;AACtE,QAAQ,0DAAmB,UAAU,2BAA2B,mCAAmC,0DAAmB,UAAU,6EAA6E;AAC7M,YAAY,0DAAmB,WAAW,2BAA2B;AACrE;AACA;AACA,YAAY,0DAAmB,WAAW,2BAA2B;AACrE;;;;;;;;;;;;;;;;;AC3B0B;AACnB,4BAA4B,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAmB,UAAU,iCAAiC,6BAA6B,GAAG;AAC1G,QAAQ,0DAAmB,UAAU,0BAA0B;AAC/D,YAAY,0DAAmB,WAAW,yBAAyB;AACnE,wCAAwC,0DAAmB,UAAU,gCAAgC,8BAA8B,0DAAmB,WAAW,+CAA+C,+BAA+B,aAAa,aAAa,GAAG,wCAAwC,IAAI;AACxT,2BAA2B,0DAAmB,UAAU,6BAA6B;AACrF,YAAY,0DAAmB,UAAU,qCAAqC;AAC9E;;;;;;;;;UC1BA","sources":["webpack://remotion-editor/./src/renderer/components/TimelineClip.tsx","webpack://remotion-editor/./src/renderer/components/clips/AudioClipContent.tsx","webpack://remotion-editor/./src/renderer/components/clips/CaptionClipContent.tsx","webpack://remotion-editor/./src/renderer/components/clips/VideoClipContent.tsx","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import React, { useCallback, useState, useRef, useEffect } from 'react';\nimport { isVideoClip, isAudioClip, isCaptionClip } from '../types/timeline';\nimport { VideoClipContent } from './clips/VideoClipContent';\nimport { AudioClipContent } from './clips/AudioClipContent';\nimport { CaptionClipContent } from './clips/CaptionClipContent';\nimport { formatTime } from '../utils/timelineUnits';\nimport { timeToPixels } from '../utils/timelineScale';\nimport { TimelineConstants } from '../utils/timelineConstants';\nimport { useRippleEdit } from '../hooks/useRippleEdit';\nimport { useTimelineContext } from '../hooks/useTimelineContext';\nimport { useTimeline } from '../hooks/useTimeline';\nimport { useSnapPoints } from '../hooks/useSnapPoints';\nimport { TrimModeTooltip } from './TrimModeTooltip';\nconst KEYBOARD_MOVE_STEP = 1;\nconst KEYBOARD_MOVE_FAST = 10;\nconst TRACK_LABEL_WIDTH = 160;\nconst SNAP_THRESHOLD = 5;\nexport const TimelineClip = ({ clip, track, layer, zoom, fps, onSelect, onDragStart, onDragEnd, tabIndex = 0, 'aria-posinset': posinset, 'aria-setsize': setsize, style }) => {\n    const [isKeyboardDragging, setIsKeyboardDragging] = useState(false);\n    const [isAtLimit, setIsAtLimit] = useState(false);\n    const [isDragging, setIsDragging] = useState(false);\n    const [isTrimming, setIsTrimming] = useState(null);\n    const [trimMode, setTrimMode] = useState('normal');\n    const { rippleDelete, rippleTrim } = useRippleEdit();\n    const { state, dispatch } = useTimelineContext();\n    const timeline = useTimeline();\n    const { getAllSnapPoints, findNearestSnapPoint } = useSnapPoints(fps);\n    const clipRef = useRef(null);\n    // Track emissions to handle Strict Mode double-mounting\n    const hasEmittedRef = useRef(false);\n    const lastPropsRef = useRef({ id: clip.id, startTime: clip.startTime, endTime: clip.endTime, layer });\n    // Format times for display\n    const startTimeFormatted = formatTime(clip.startTime, { fps, showFrames: true });\n    const endTimeFormatted = formatTime(clip.endTime, { fps, showFrames: true });\n    const durationFormatted = formatTime(clip.endTime - clip.startTime, { fps, showFrames: true });\n    const clipDuration = clip.endTime - clip.startTime;\n    // Emit clip events when mounted, positioned, or updated\n    useEffect(() => {\n        const propsChanged = lastPropsRef.current.id !== clip.id ||\n            lastPropsRef.current.startTime !== clip.startTime ||\n            lastPropsRef.current.endTime !== clip.endTime ||\n            lastPropsRef.current.layer !== layer;\n        if (propsChanged) {\n            hasEmittedRef.current = false;\n            lastPropsRef.current = { id: clip.id, startTime: clip.startTime, endTime: clip.endTime, layer };\n        }\n        if (!hasEmittedRef.current && clipRef.current) {\n            // Force a reflow to ensure styles are applied\n            void clipRef.current.offsetHeight;\n            // Calculate position and dimensions\n            const left = timeToPixels(clip.startTime, zoom);\n            const width = timeToPixels(clip.endTime - clip.startTime, zoom);\n            const top = layer * TimelineConstants.UI.TRACK_HEIGHT;\n            // Update styles\n            clipRef.current.style.transition = 'none';\n            clipRef.current.style.left = `${Math.round(left)}px`;\n            clipRef.current.style.width = `${Math.round(width)}px`;\n            clipRef.current.style.top = `${top}px`;\n            // Force another reflow\n            void clipRef.current.offsetHeight;\n            clipRef.current.style.transition = '';\n            // Dispatch rendered event\n            window.dispatchEvent(new CustomEvent('clip:rendered', {\n                detail: {\n                    clipId: clip.id,\n                    startTime: clip.startTime,\n                    endTime: clip.endTime,\n                    layer,\n                    left,\n                    width,\n                    top\n                }\n            }));\n            // Wait for next frame to ensure styles are applied\n            requestAnimationFrame(() => {\n                if (!clipRef.current)\n                    return;\n                // Get final position after styles are applied\n                const rect = clipRef.current.getBoundingClientRect();\n                // Dispatch positioned event\n                window.dispatchEvent(new CustomEvent('clip:positioned', {\n                    detail: {\n                        clipId: clip.id,\n                        left: rect.left,\n                        width: rect.width,\n                        top: rect.top\n                    }\n                }));\n                hasEmittedRef.current = true;\n            });\n        }\n        return () => {\n            // Reset emission flag on cleanup only if props changed\n            if (propsChanged) {\n                hasEmittedRef.current = false;\n            }\n        };\n    }, [clip.id, clip.startTime, clip.endTime, layer, zoom]);\n    const handlePointerDown = useCallback((e, trimSide) => {\n        e.preventDefault();\n        e.stopPropagation();\n        const target = e.currentTarget;\n        target.setPointerCapture(e.pointerId);\n        const isTrimmingMode = trimSide ? (trimSide === 'trim-start' ? 'start' : 'end') : null;\n        setIsDragging(!isTrimmingMode);\n        setIsTrimming(isTrimmingMode);\n        onSelect();\n        onDragStart();\n    }, [onSelect, onDragStart]);\n    const handleKeyDown = useCallback((e) => {\n        switch (e.key) {\n            case 'Enter':\n            case ' ':\n                e.preventDefault();\n                onSelect();\n                break;\n            case 'Delete':\n            case 'Backspace':\n                e.preventDefault();\n                rippleDelete(clip, track);\n                break;\n        }\n    }, [onSelect, rippleDelete, clip, track]);\n    const renderClipContent = () => {\n        if (isVideoClip(clip)) {\n            return (React.createElement(VideoClipContent, { clip: clip, isSelected: state.selectedClipIds.includes(clip.id), zoom: zoom, fps: fps }));\n        }\n        if (isAudioClip(clip)) {\n            return (React.createElement(AudioClipContent, { clip: clip, isSelected: state.selectedClipIds.includes(clip.id), zoom: zoom, fps: fps }));\n        }\n        if (isCaptionClip(clip)) {\n            return (React.createElement(CaptionClipContent, { clip: clip, isSelected: state.selectedClipIds.includes(clip.id), zoom: zoom, fps: fps }));\n        }\n        return null;\n    };\n    const clipStyle = {\n        position: 'absolute',\n        left: `${Math.round(timeToPixels(clip.startTime, zoom))}px`,\n        width: `${Math.round(timeToPixels(clip.endTime - clip.startTime, zoom))}px`,\n        height: '100%',\n        cursor: isKeyboardDragging ? 'move' : isDragging ? 'grabbing' : 'grab',\n        top: style?.top,\n        willChange: isDragging ? 'transform' : undefined,\n        touchAction: 'none',\n        userSelect: 'none',\n        pointerEvents: 'auto',\n        zIndex: isDragging || isTrimming ? 100 : 1,\n        opacity: clipDuration > clip.mediaDuration ? 0.7 : 1\n    };\n    return (React.createElement(\"div\", { ref: clipRef, \"data-testid\": \"timeline-clip\", className: `timeline-clip ${clip.type} ${isKeyboardDragging ? 'keyboard-dragging' : ''} ${state.selectedClipIds.includes(clip.id) ? 'selected' : ''}`, style: clipStyle, onPointerDown: handlePointerDown, onKeyDown: handleKeyDown, role: \"listitem\", \"aria-label\": `${clip.name} clip from ${startTimeFormatted} to ${endTimeFormatted}, duration ${durationFormatted}`, \"aria-grabbed\": isKeyboardDragging, \"aria-dropeffect\": \"move\", tabIndex: tabIndex, \"aria-posinset\": posinset, \"aria-setsize\": setsize, \"data-clip-id\": clip.id, \"data-moving\": isDragging || isTrimming ? 'true' : undefined, \"data-trimming\": isTrimming || undefined, \"data-at-limit\": isAtLimit || (clip.endTime - clip.startTime) > clip.mediaDuration || undefined, \"data-trim-mode\": trimMode },\n        isTrimming && React.createElement(TrimModeTooltip, { mode: trimMode }),\n        React.createElement(\"div\", { className: \"clip-handle left clip-trim-start\", onPointerDown: (e) => {\n                e.stopPropagation();\n                handlePointerDown(e, 'trim-start');\n            }, style: {\n                position: 'absolute',\n                left: -8,\n                width: 16,\n                height: '100%',\n                cursor: 'col-resize',\n                zIndex: 10,\n                background: 'rgba(255, 255, 255, 0.1)',\n                opacity: 0,\n                transition: 'opacity 0.15s ease'\n            } }),\n        renderClipContent(),\n        React.createElement(\"div\", { className: \"clip-handle right clip-trim-end\", onPointerDown: (e) => {\n                e.stopPropagation();\n                handlePointerDown(e, 'trim-end');\n            }, style: {\n                position: 'absolute',\n                right: -8,\n                width: 16,\n                height: '100%',\n                cursor: 'col-resize',\n                zIndex: 10,\n                background: 'rgba(255, 255, 255, 0.1)',\n                opacity: 0,\n                transition: 'opacity 0.15s ease'\n            } }),\n        React.createElement(\"div\", { className: \"clip-duration\" },\n            durationFormatted,\n            clipDuration > clip.mediaDuration && (React.createElement(\"span\", { style: { fontSize: '0.8em', opacity: 0.7, marginLeft: '4px', color: '#ff6b6b' } },\n                \"(\",\n                formatTime(clip.mediaDuration, { fps, showFrames: true }),\n                \" source)\")))));\n};\n","import React from 'react';\nexport const AudioClipContent = ({ clip, isSelected, zoom, fps }) => {\n    return (React.createElement(\"div\", { className: `audio-clip-content ${isSelected ? 'selected' : ''}` },\n        React.createElement(\"div\", { className: \"clip-label\" }, clip.name),\n        clip.effects.length > 0 && (React.createElement(\"div\", { className: \"clip-effects\" }, clip.effects.map(effect => (React.createElement(\"div\", { key: effect.id, className: `effect ${effect.enabled ? 'enabled' : 'disabled'}` }, effect.type))))),\n        clip.mediaOffset > 0 && (React.createElement(\"div\", { className: \"trim-indicator start\", style: { left: 0 } })),\n        clip.mediaDuration < clip.originalDuration && (React.createElement(\"div\", { className: \"trim-indicator end\", style: { right: 0 } })),\n        React.createElement(\"div\", { className: \"waveform-placeholder\" })));\n};\n","import React from 'react';\nexport const CaptionClipContent = ({ clip, isSelected, zoom, fps }) => {\n    // Get speaker style for a caption\n    const getSpeakerStyle = (caption) => {\n        if (!clip.speakerStyles?.speakers || !caption.speakerId)\n            return {};\n        const style = clip.speakerStyles.speakers[caption.speakerId];\n        return style ? {\n            color: style.color,\n            borderColor: style.color\n        } : {};\n    };\n    // Get speaker name for a caption\n    const getSpeakerName = (caption) => {\n        if (!clip.speakerStyles?.speakers || !caption.speakerId)\n            return 'Unknown';\n        const style = clip.speakerStyles.speakers[caption.speakerId];\n        return style ? style.name : 'Unknown';\n    };\n    return (React.createElement(\"div\", { className: `caption-clip-content ${isSelected ? 'selected' : ''}` },\n        React.createElement(\"div\", { className: \"caption-header\" },\n            React.createElement(\"span\", { className: \"caption-title\" }, clip.name)),\n        React.createElement(\"div\", { className: \"caption-body\" }, clip.captions?.map((caption) => (React.createElement(\"div\", { key: caption.id, className: \"caption-item\", style: getSpeakerStyle(caption) },\n            React.createElement(\"span\", { className: \"speaker-name\" },\n                getSpeakerName(caption),\n                \":\"),\n            React.createElement(\"span\", { className: \"caption-text\" }, caption.text)))))));\n};\n","import React from 'react';\nexport const VideoClipContent = ({ clip, isSelected, zoom, fps }) => {\n    // Check if effect is active at current time\n    const isEffectActive = (effect, currentTime) => {\n        if (!effect.enabled)\n            return false;\n        // If no time range is specified, effect is always active\n        if (!effect.startTime && !effect.endTime)\n            return true;\n        // If only start time is specified, effect is active from that point on\n        if (effect.startTime && !effect.endTime) {\n            return currentTime >= effect.startTime;\n        }\n        // If only end time is specified, effect is active until that point\n        if (!effect.startTime && effect.endTime) {\n            return currentTime <= effect.endTime;\n        }\n        // Both start and end times are specified\n        return currentTime >= (effect.startTime || 0) && currentTime <= (effect.endTime || Infinity);\n    };\n    return (React.createElement(\"div\", { className: `video-clip-content ${isSelected ? 'selected' : ''}` },\n        React.createElement(\"div\", { className: \"clip-header\" },\n            React.createElement(\"span\", { className: \"clip-title\" }, clip.name),\n            clip.effects.length > 0 && (React.createElement(\"div\", { className: \"effect-indicators\" }, clip.effects.map(effect => (React.createElement(\"span\", { key: effect.id, className: `effect-indicator ${effect.enabled ? 'active' : ''}`, title: `${effect.type} (${effect.enabled ? 'Enabled' : 'Disabled'})` })))))),\n        clip.thumbnail && (React.createElement(\"div\", { className: \"clip-thumbnail\" },\n            React.createElement(\"img\", { src: clip.thumbnail, alt: clip.name })))));\n};\n","__webpack_require__.h = () => (\"633cb876b8980c771787\")"],"names":[],"sourceRoot":""}
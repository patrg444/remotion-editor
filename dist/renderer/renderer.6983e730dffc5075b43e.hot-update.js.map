{"version":3,"file":"renderer.6983e730dffc5075b43e.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;AAAoC;AACQ;AACc;AACV;AACP;AAClC;AACP,qBAAqB,yDAAW;AAChC,YAAY,WAAW,EAAE,uEAAkB;AAC3C,oCAAoC,kDAAW;AAC/C;AACA,kBAAkB,wDAAW;AAC7B;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,yBAAyB,kDAAW;AACpC;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY,iDAAM,oCAAoC,oCAAoC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,SAAS;AACT,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,yBAAyB,kDAAW;AACpC;AACA;AACA;AACA,YAAY,iDAAM,gCAAgC,YAAY;AAC9D;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAW;AAC7B,uBAAuB;AACvB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,SAAS;AACT,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,uBAAuB,kDAAW;AAClC;AACA;AACA;AACA,kCAAkC;AAClC,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAM;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,wBAAwB,kDAAW;AACnC;AACA,iCAAiC;AACjC;AACA;AACA,YAAY,iDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAM,oCAAoC,oCAAoC;AAC1F;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAQ,iDAAM;AACd;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;UCpTA","sources":["webpack://remotion-editor/./src/renderer/hooks/useRippleEdit.ts","webpack://remotion-editor/webpack/runtime/getFullHash"],"sourcesContent":["import { useCallback } from 'react';\nimport { useTimeline } from './useTimeline';\nimport { useTimelineContext } from './useTimelineContext';\nimport { ActionTypes } from '../types/timeline';\nimport { logger } from '../utils/logger';\nexport const useRippleEdit = () => {\n    const timeline = useTimeline();\n    const { dispatch } = useTimelineContext();\n    const createHistoryCheckpoint = useCallback((description) => {\n        dispatch({\n            type: ActionTypes.PUSH_HISTORY,\n            payload: {\n                description,\n                isCheckpoint: true\n            }\n        });\n    }, [dispatch]);\n    /**\n     * Ripple delete a clip and shift all subsequent clips left\n     */\n    const rippleDelete = useCallback((clip, track) => {\n        const duration = clip.endTime - clip.startTime;\n        const deleteTime = clip.startTime;\n        logger.debug('Ripple delete:', {\n            clipId: clip.id,\n            trackId: track.id,\n            deleteTime,\n            duration\n        });\n        // Sort clips by start time and find the clip to delete\n        const sortedClips = [...track.clips].sort((a, b) => a.startTime - b.startTime);\n        const clipIndex = sortedClips.findIndex(c => c.id === clip.id);\n        if (clipIndex === -1) {\n            logger.warn('Clip not found in track:', { clipId: clip.id, trackId: track.id });\n            return;\n        }\n        // Calculate gaps between subsequent clips to maintain spacing\n        const subsequentClips = sortedClips.slice(clipIndex + 1);\n        const initialGaps = subsequentClips.map((c, i) => {\n            const prevClip = i === 0 ? clip : subsequentClips[i - 1];\n            return {\n                clipId: c.id,\n                gap: c.startTime - prevClip.endTime\n            };\n        });\n        // Create checkpoint before ripple operation\n        createHistoryCheckpoint('Ripple delete clip');\n        // First remove the clip\n        timeline.removeClip(track.id, clip.id);\n        // Then shift subsequent clips while maintaining gaps\n        subsequentClips.forEach((c, i) => {\n            const gap = initialGaps[i].gap;\n            const newStartTime = i === 0 ?\n                deleteTime + gap : // First subsequent clip starts after gap\n                subsequentClips[i - 1].endTime + gap; // Other clips maintain gaps\n            timeline.moveClip(c.id, track.id, track.id, newStartTime);\n        });\n        logger.debug('Ripple delete complete:', {\n            deletedClip: {\n                id: clip.id,\n                startTime: deleteTime,\n                duration\n            },\n            subsequentClips: subsequentClips.map(c => ({\n                id: c.id,\n                startTime: c.startTime,\n                endTime: c.endTime\n            }))\n        });\n    }, [timeline, createHistoryCheckpoint]);\n    /**\n     * Ripple insert a clip and shift all subsequent clips right\n     */\n    const rippleInsert = useCallback((clip, track, insertTime) => {\n        const duration = clip.endTime - clip.startTime;\n        // Validate insert time\n        if (insertTime < 0) {\n            logger.warn('Invalid insert time:', { insertTime });\n            return;\n        }\n        logger.debug('Ripple insert:', {\n            clipId: clip.id,\n            trackId: track.id,\n            insertTime,\n            duration\n        });\n        // Sort clips by start time\n        const sortedClips = [...track.clips].sort((a, b) => a.startTime - b.startTime);\n        // Find insertion point and calculate gaps\n        const insertIndex = sortedClips.findIndex(c => c.startTime > insertTime);\n        const subsequentClips = insertIndex === -1 ? [] : sortedClips.slice(insertIndex);\n        // Calculate initial gaps between existing clips\n        const initialGaps = subsequentClips.map((c, i) => {\n            const prevClip = i === 0 ?\n                (insertIndex > 0 ? sortedClips[insertIndex - 1] : null) :\n                subsequentClips[i - 1];\n            return {\n                clipId: c.id,\n                gap: prevClip ? c.startTime - prevClip.endTime : 0\n            };\n        });\n        // Create checkpoint before ripple operation\n        createHistoryCheckpoint('Ripple insert clip');\n        // First add the new clip\n        const newClip = {\n            ...clip,\n            startTime: insertTime,\n            endTime: insertTime + duration\n        };\n        dispatch({\n            type: ActionTypes.ADD_CLIP,\n            payload: { trackId: track.id, clip: newClip }\n        });\n        // Then shift subsequent clips while maintaining gaps\n        subsequentClips.forEach((c, i) => {\n            const gap = initialGaps[i].gap;\n            const newStartTime = i === 0 ?\n                insertTime + duration + gap : // First subsequent clip starts after inserted clip + gap\n                subsequentClips[i - 1].endTime + gap; // Other clips maintain gaps\n            timeline.moveClip(c.id, track.id, track.id, newStartTime);\n        });\n        logger.debug('Ripple insert complete:', {\n            insertedClip: {\n                id: clip.id,\n                startTime: insertTime,\n                duration\n            },\n            subsequentClips: subsequentClips.map(c => ({\n                id: c.id,\n                startTime: c.startTime,\n                endTime: c.endTime\n            }))\n        });\n    }, [timeline, createHistoryCheckpoint]);\n    /**\n     * Ripple trim a clip and shift all subsequent clips\n     */\n    const rippleTrim = useCallback((clip, track, trimType, newTime) => {\n        const oldStartTime = clip.startTime;\n        const oldEndTime = clip.endTime;\n        const oldDuration = oldEndTime - oldStartTime;\n        const MIN_DURATION = 0.1; // Minimum duration constant\n        logger.debug('Ripple trim:', {\n            clipId: clip.id,\n            trackId: track.id,\n            trimType,\n            oldTime: trimType === 'in' ? oldStartTime : oldEndTime,\n            newTime,\n            oldDuration,\n            mediaDuration: clip.mediaDuration\n        });\n        // Calculate valid time boundaries\n        const maxEndTime = clip.startTime + clip.mediaDuration;\n        const minStartTime = oldStartTime - clip.mediaOffset;\n        // Validate and clamp new time based on trim type\n        let validatedTime = newTime;\n        if (trimType === 'in') {\n            const maxInPoint = oldEndTime - MIN_DURATION;\n            validatedTime = Math.max(minStartTime, Math.min(maxInPoint, newTime));\n        }\n        else {\n            const minOutPoint = oldStartTime + MIN_DURATION;\n            validatedTime = Math.max(minOutPoint, Math.min(maxEndTime, newTime));\n        }\n        if (validatedTime !== newTime) {\n            logger.debug('Adjusted trim time to valid bounds:', {\n                original: newTime,\n                validated: validatedTime\n            });\n        }\n        // Create checkpoint before ripple operation\n        createHistoryCheckpoint('Ripple trim clip');\n        // Sort clips by start time to ensure proper ripple order\n        const sortedClips = [...track.clips].sort((a, b) => a.startTime - b.startTime);\n        const clipIndex = sortedClips.findIndex(c => c.id === clip.id);\n        const subsequentClips = sortedClips.slice(clipIndex + 1);\n        // Calculate gaps between clips to maintain\n        const initialGaps = subsequentClips.map((c, i) => {\n            const prevClip = i === 0 ? clip : subsequentClips[i - 1];\n            return {\n                clipId: c.id,\n                gap: Math.max(0, c.startTime - prevClip.endTime)\n            };\n        });\n        if (trimType === 'in') {\n            // Calculate new media offset for in trim\n            const startDelta = validatedTime - oldStartTime;\n            const newMediaOffset = clip.mediaOffset + startDelta;\n            // First trim the current clip\n            dispatch({\n                type: ActionTypes.TRIM_CLIP,\n                payload: {\n                    trackId: track.id,\n                    clipId: clip.id,\n                    startTime: validatedTime,\n                    endTime: clip.endTime,\n                    speed: 1.0,\n                    handles: {\n                        startPosition: newMediaOffset,\n                        endPosition: newMediaOffset + (clip.endTime - validatedTime)\n                    },\n                    ripple: true\n                }\n            });\n            // Shift subsequent clips to maintain gaps\n            const shift = validatedTime - oldStartTime;\n            subsequentClips.forEach((c, i) => {\n                const gap = initialGaps[i].gap;\n                const newStartTime = i === 0 ?\n                    clip.endTime + gap + shift :\n                    subsequentClips[i - 1].endTime + gap;\n                timeline.moveClip(c.id, track.id, track.id, newStartTime);\n            });\n        }\n        else {\n            // For out trim, directly use the validated time\n            const newDuration = validatedTime - clip.startTime;\n            // Dispatch trim action\n            dispatch({\n                type: ActionTypes.TRIM_CLIP,\n                payload: {\n                    trackId: track.id,\n                    clipId: clip.id,\n                    startTime: clip.startTime,\n                    endTime: validatedTime,\n                    speed: 1.0,\n                    handles: {\n                        startPosition: clip.mediaOffset,\n                        endPosition: clip.mediaOffset + newDuration\n                    },\n                    ripple: true,\n                    maintainGaps: true\n                }\n            });\n            // Shift subsequent clips to maintain gaps\n            subsequentClips.forEach((c, i) => {\n                const gap = initialGaps[i].gap;\n                const newStartTime = i === 0 ?\n                    validatedTime + gap :\n                    subsequentClips[i - 1].endTime + gap;\n                timeline.moveClip(c.id, track.id, track.id, newStartTime);\n            });\n        }\n        logger.debug('Ripple trim complete:', {\n            clipId: clip.id,\n            newStartTime: trimType === 'in' ? validatedTime : clip.startTime,\n            newEndTime: trimType === 'out' ? validatedTime : clip.endTime,\n            subsequentClips: subsequentClips.map(c => ({\n                id: c.id,\n                startTime: c.startTime,\n                endTime: c.endTime\n            }))\n        });\n    }, [timeline, createHistoryCheckpoint]);\n    /**\n     * Ripple split a clip at the given time\n     */\n    const rippleSplit = useCallback((clip, track, splitTime) => {\n        // Validate split time with minimum segment duration\n        const minDuration = 0.1; // Minimum duration of 0.1s for each segment\n        if (splitTime <= clip.startTime + minDuration ||\n            splitTime >= clip.endTime - minDuration) {\n            logger.warn('Invalid split time:', {\n                clipId: clip.id,\n                splitTime,\n                clipStart: clip.startTime,\n                clipEnd: clip.endTime,\n                minDuration,\n                leftSegmentDuration: splitTime - clip.startTime,\n                rightSegmentDuration: clip.endTime - splitTime\n            });\n            return;\n        }\n        // Sort clips to ensure proper order\n        const sortedClips = [...track.clips].sort((a, b) => a.startTime - b.startTime);\n        const clipIndex = sortedClips.findIndex(c => c.id === clip.id);\n        if (clipIndex === -1) {\n            logger.warn('Clip not found in track:', { clipId: clip.id, trackId: track.id });\n            return;\n        }\n        logger.debug('Ripple split:', {\n            clipId: clip.id,\n            trackId: track.id,\n            splitTime,\n            clipDuration: clip.endTime - clip.startTime,\n            leftSegmentDuration: splitTime - clip.startTime,\n            rightSegmentDuration: clip.endTime - splitTime\n        });\n        // Create checkpoint before ripple operation\n        createHistoryCheckpoint('Ripple split clip');\n        // Split the clip\n        timeline.splitClip(track.id, clip.id, splitTime);\n        // No need to shift other clips since split maintains total duration\n        logger.debug('Ripple split complete:', {\n            originalClip: {\n                id: clip.id,\n                startTime: clip.startTime,\n                endTime: clip.endTime\n            },\n            splitPoint: splitTime\n        });\n    }, [timeline, createHistoryCheckpoint]);\n    return {\n        rippleDelete,\n        rippleInsert,\n        rippleTrim,\n        rippleSplit\n    };\n};\n","__webpack_require__.h = () => (\"ea3b2a31153feb191b0f\")"],"names":[],"sourceRoot":""}
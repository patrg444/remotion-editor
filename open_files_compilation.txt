=====================================
FILE: src/renderer/types/components.ts
=====================================
import { TimelineState } from './timeline';

export interface TimelineDisplayProps {
  currentTime: number;
  duration: number;
  fps: number;
}

export interface PlaybackControlsProps {
  isPlaying: boolean;
  onPlayPause: () => void;
  onStepForward?: () => void;
  onStepBackward?: () => void;
  onTimeChange?: (time: number) => void;
  currentTime: number;
  duration: number;
}

export interface TimelineRulerProps {
  scale: number;
  duration: number;
  currentTime: number;
  onTimeChange: (time: number) => void;
  zoom: number;
  fps: number;
  containerWidth: number;
  scrollLeft: number;
  type?: 'main' | 'mini';
}

export interface TimelinePlayheadProps {
  currentTime: number;
  scale: number;
  onTimeChange: (time: number) => void;
  isPlaying: boolean;
}

export interface TimelinePointProps {
  time: number;
  scale: number;
  type: 'marker' | 'clip' | 'playhead';
  label?: string;
  color?: string;
  isSelected?: boolean;
  zoom: number;
  onClick?: (time: number) => void;
  onDoubleClick?: (e: React.MouseEvent) => void;
  onContextMenu?: (e: React.MouseEvent) => void;
}

export interface TimelineTransitionHandleProps {
  position: number;
  onPositionChange: (position: number) => void;
  onDragStart?: () => void;
  onDragEnd?: () => void;
  snapThreshold?: number;
}

export interface TimelineContextMenuProps {
  x: number;
  y: number;
  onClose: () => void;
  items: {
    label: string;
    action: () => void;
    disabled?: boolean;
    shortcut?: string;
  }[];
}

export interface TimelineShortcutsHelpProps {
  onClose: () => void;
  shortcuts: {
    key: string;
    description: string;
    category: string;
  }[];
}

export interface TimelineHeaderProps {
  zoom: number;
  onZoomChange: (zoom: number) => void;
  fps: number;
  onFpsChange: (fps: number) => void;
  currentTime: number;
  duration: number;
  isPlaying: boolean;
  onPlayPause: () => void;
  onStepForward: () => void;
  onStepBackward: () => void;
}

export interface TimelineClipContentProps {
  clip: TimelineState['tracks'][0]['clips'][0];
  scale: number;
  isSelected: boolean;
}

export interface TimelineTrackProps {
  track: TimelineState['tracks'][0];
  selectedClipIds: string[];
  onSelectClip: (clipId: string) => void;
  onClipDragStart: (clipId: string) => void;
  onClipDragEnd: () => void;
  scale: number;
  fps: number;
}

export interface TimelineTracksProps {
  tracks: TimelineState['tracks'];
  selectedTrackId?: string;
  selectedClipIds: string[];
  onTrackSelect: (trackId: string) => void;
  onClipSelect: (clipId: string) => void;
  onClipDragStart: (clipId: string) => void;
  onClipDragEnd: () => void;
  scale: number;
  fps: number;
}

=====================================
FILE: src/renderer/App.tsx
=====================================
import React from 'react';
import { TimelineProvider } from './contexts/TimelineContext';
import { TimelineContainer } from './components/TimelineContainer';

export const App: React.FC = () => {
  return (
    <TimelineProvider>
      <div className="app-container">
        <TimelineContainer />
      </div>
    </TimelineProvider>
  );
};

=====================================
FILE: src/renderer/types/timeline.ts
=====================================
import { StateDiff } from '../utils/historyDiff';

export type Effect = {
  id: string;
  type: string;
  params: Record<string, any>;
  enabled?: boolean;
  startTime?: number;
  endTime?: number;
  keyframes?: {
    time: number;
    value: any;
  }[];
};

export type Transition = {
  id: string;
  type: string;
  duration: number;
  params: Record<string, any>;
  keyframes?: {
    time: number;
    value: any;
  }[];
};

export type Layer = {
  id: string;
  index: number;
  visible: boolean;
  locked: boolean;
};

export type WaveformData = {
  peaks: number[];
  resolution: number;
  sampleRate: number;
  loaded: boolean;
  error?: string;
};

export type VideoClip = {
  id: string;
  type: 'video';
  name: string;
  startTime: number;
  endTime: number;
  src: string;
  originalDuration: number;
  effects: Effect[];
  thumbnail?: string;
  trimStart?: number;
  trimEnd?: number;
  layer?: number; // For future: support multiple layers within track
  transition?: {
    in?: Transition;
    out?: Transition;
  };
  transform?: {
    scale: number;
    rotation: number;
    position: { x: number; y: number };
    opacity: number;
  };
};

export type AudioClip = {
  id: string;
  type: 'audio';
  name: string;
  startTime: number;
  endTime: number;
  src: string;
  originalDuration: number;
  effects: Effect[];
  trimStart?: number;
  trimEnd?: number;
  volume?: number;
  isMuted?: boolean;
  waveform?: WaveformData;
  layer?: number;
  transition?: {
    in?: Transition;
    out?: Transition;
  };
};

export type Speaker = {
  id: string;
  name: string;
  color: string;
  avatar?: string;
};

export type Caption = {
  id: string;
  text: string;
  start: number;
  end: number;
  startTime?: number;
  endTime?: number;
  speakerId?: string;
};

export type CaptionClip = {
  id: string;
  type: 'caption';
  name: string;
  startTime: number;
  endTime: number;
  text: string;
  effects: Effect[];
  captions?: Caption[];
  speakerStyles?: {
    color?: string;
    fontSize?: number;
    fontFamily?: string;
    speakers?: Record<string, Speaker>;
  };
  layer?: number;
};

export type Clip = VideoClip | AudioClip | CaptionClip;
export type ClipWithLayer = Clip & { layer: number };

export type TrackType = 'video' | 'audio' | 'caption';

export type Track = {
  id: string;
  name: string;
  type: TrackType;
  clips: ClipWithLayer[];
  isLocked?: boolean;
  isVisible?: boolean;
  layers?: Layer[]; // For future: support multiple layers within track
  allowOverlap?: boolean; // For future: control if clips can overlap
  height?: number; // For future: custom track heights
  color?: string; // For future: track color coding
};

export type Marker = {
  id: string;
  time: number;
  label: string;
  color?: string;
  type?: string;
};

export type TimelineState = {
  tracks: Track[];
  currentTime: number;
  duration: number;
  zoom: number;
  fps: number;
  isPlaying: boolean;
  isDragging: boolean;
  scrollX: number;
  scrollY: number;
  selectedClipIds: string[];
  selectedTrackId?: string;
  markers: Marker[];
  dragStartX?: number;
  dragStartY?: number;
  error?: string;
  history: {
    entries: StateDiff[];
    currentIndex: number;
  };
  // For future features
  snapToGrid?: boolean;
  gridSize?: number;
  showWaveforms?: boolean;
  showKeyframes?: boolean;
  showTransitions?: boolean;
  showEffects?: boolean;
  renderQuality?: 'draft' | 'preview' | 'full';
};

export const ActionTypes = {
  // Timeline state
  SET_STATE: 'SET_STATE',
  SET_CURRENT_TIME: 'SET_CURRENT_TIME',
  SET_DURATION: 'SET_DURATION',
  SET_ZOOM: 'SET_ZOOM',
  SET_FPS: 'SET_FPS',
  SET_IS_PLAYING: 'SET_IS_PLAYING',
  SET_IS_DRAGGING: 'SET_IS_DRAGGING',
  SET_SCROLL_X: 'SET_SCROLL_X',
  SET_SCROLL_Y: 'SET_SCROLL_Y',
  SET_ERROR: 'SET_ERROR',

  // Selection
  SET_SELECTED_CLIP_IDS: 'SET_SELECTED_CLIP_IDS',
  SET_SELECTED_TRACK_ID: 'SET_SELECTED_TRACK_ID',
  SELECT_TRACK: 'SELECT_TRACK',
  SELECT_CLIPS: 'SELECT_CLIPS',

  // Tracks
  SET_TRACKS: 'SET_TRACKS',
  ADD_TRACK: 'ADD_TRACK',
  UPDATE_TRACK: 'UPDATE_TRACK',
  REMOVE_TRACK: 'REMOVE_TRACK',
  MOVE_TRACK: 'MOVE_TRACK',

  // Clips
  ADD_CLIP: 'ADD_CLIP',
  UPDATE_CLIP: 'UPDATE_CLIP',
  REMOVE_CLIP: 'REMOVE_CLIP',
  MOVE_CLIP: 'MOVE_CLIP',
  SPLIT_CLIP: 'SPLIT_CLIP',
  TRIM_CLIP: 'TRIM_CLIP',

  // Effects and Transitions
  ADD_EFFECT: 'ADD_EFFECT',
  UPDATE_EFFECT: 'UPDATE_EFFECT',
  REMOVE_EFFECT: 'REMOVE_EFFECT',
  ADD_TRANSITION: 'ADD_TRANSITION',
  UPDATE_TRANSITION: 'UPDATE_TRANSITION',
  REMOVE_TRANSITION: 'REMOVE_TRANSITION',

  // Markers
  SET_MARKERS: 'SET_MARKERS',
  ADD_MARKER: 'ADD_MARKER',
  UPDATE_MARKER: 'UPDATE_MARKER',
  REMOVE_MARKER: 'REMOVE_MARKER',

  // History
  PUSH_HISTORY: 'PUSH_HISTORY',
  SET_HISTORY_INDEX: 'SET_HISTORY_INDEX',
  CLEAR_HISTORY: 'CLEAR_HISTORY',
  UNDO: 'UNDO',
  REDO: 'REDO',
  RESTORE_SNAPSHOT: 'RESTORE_SNAPSHOT',

  // UI State
  SET_PLAYING: 'SET_PLAYING',
  SET_DRAGGING: 'SET_DRAGGING',
  SET_SHOW_WAVEFORMS: 'SET_SHOW_WAVEFORMS',
  SET_SHOW_KEYFRAMES: 'SET_SHOW_KEYFRAMES',
  SET_SHOW_TRANSITIONS: 'SET_SHOW_TRANSITIONS',
  SET_SHOW_EFFECTS: 'SET_SHOW_EFFECTS',
  SET_RENDER_QUALITY: 'SET_RENDER_QUALITY'
} as const;

export type ActionTypes = typeof ActionTypes[keyof typeof ActionTypes];

export type TimelineAction = {
  type: ActionTypes;
  payload?: any;
};

export type TimelineContextType = {
  state: TimelineState;
  dispatch: (action: TimelineAction) => void;
};

export const isVideoClip = (clip: Clip): clip is VideoClip => clip.type === 'video';
export const isAudioClip = (clip: Clip): clip is AudioClip => clip.type === 'audio';
export const isCaptionClip = (clip: Clip): clip is CaptionClip => clip.type === 'caption';
export const isMediaClip = (clip: Clip): clip is VideoClip | AudioClip => 
  clip.type === 'video' || clip.type === 'audio';

export const createLayeredClip = <T extends Clip>(clip: T, layer: number): T & { layer: number } => ({
  ...clip,
  layer
});

export const initialTimelineState: TimelineState = {
  tracks: [],
  currentTime: 0,
  duration: 0,
  zoom: 1,
  fps: 30,
  isPlaying: false,
  isDragging: false,
  scrollX: 0,
  scrollY: 0,
  selectedClipIds: [],
  markers: [],
  history: {
    entries: [],
    currentIndex: -1
  },
  snapToGrid: true,
  gridSize: 10,
  showWaveforms: true,
  showKeyframes: true,
  showTransitions: true,
  showEffects: true,
  renderQuality: 'preview'
};

=====================================
FILE: src/renderer/utils/timelineConstants.ts
=====================================
/**
 * Timeline constants and configuration
 */

// Scale and zoom constants
export const PIXELS_PER_SECOND = 100; // Base scale at zoom level 1.0
export const MIN_ZOOM = 0.1;
export const MAX_ZOOM = 10;
export const DEFAULT_ZOOM = 1;

// Time formatting defaults
export const DEFAULT_FPS = 30;
export const DEFAULT_TIME_FORMAT = 'standard' as const;
export const DEFAULT_TIME_OPTIONS = {
  fps: DEFAULT_FPS,
  showFrames: true,
  showMilliseconds: false,
  padHours: false,
  compact: false,
  format: DEFAULT_TIME_FORMAT
} as const;

// Clip duration handling
export const getDuration = (startTime: number, endTime: number): number => {
  return endTime - startTime;
};

export const getEndTime = (startTime: number, duration: number): number => {
  return startTime + duration;
};

// Scale conversion helpers
export const getScale = (zoom: number): number => {
  return PIXELS_PER_SECOND * zoom;
};

export const getZoom = (scale: number): number => {
  return scale / PIXELS_PER_SECOND;
};

// Frame conversion constants
export const FRAME_RATE_OPTIONS = [
  23.976,
  24,
  25,
  29.97,
  30,
  50,
  59.94,
  60
] as const;

// Snap point thresholds
export const SNAP_THRESHOLD = 5; // pixels
export const MIN_FRAME_SNAP_SPACING = 10; // minimum pixels between frame snap points
export const MAX_FRAME_SNAP_ZOOM = 4; // maximum zoom level for frame snapping

// Virtual scroll constants
export const VIRTUAL_SCROLL_BUFFER = 2.0; // buffer multiplier for virtual scrolling
export const MIN_CLIP_WIDTH = 10; // minimum width in pixels to render a clip
export const MAX_VISIBLE_CLIPS = 1000; // maximum number of clips to render at once

// History constants
export const MAX_HISTORY_SIZE = 100; // maximum number of history entries

// Performance constants
export const SCROLL_THROTTLE = 16; // ms (~ 1 frame at 60fps)
export const PLAYBACK_UPDATE_INTERVAL = 16; // ms
export const WAVEFORM_RESOLUTION = 2048; // samples per waveform chunk

// UI constants
export const TRACK_HEIGHT = 50; // pixels
export const HEADER_HEIGHT = 40; // pixels
export const RULER_HEIGHT = 30; // pixels
export const MIN_TRACK_WIDTH = 800; // pixels

// Layer constants
export const MAX_LAYERS = 10; // maximum number of layers per track
export const MIN_LAYER_HEIGHT = 25; // minimum height for a layer
export const LAYER_SPACING = 2; // pixels between layers

// Transition constants
export const MIN_TRANSITION_DURATION = 0.5; // seconds
export const MAX_TRANSITION_DURATION = 5.0; // seconds
export const DEFAULT_TRANSITION_DURATION = 1.0; // seconds
export const TRANSITION_HANDLE_SIZE = 10; // pixels

// Effect constants
export const MAX_EFFECTS_PER_CLIP = 10;
export const EFFECT_PREVIEW_RESOLUTION = 0.5; // 50% resolution for effect previews

// Waveform constants
export const WAVEFORM_HEIGHT = 30; // pixels
export const WAVEFORM_COLOR = '#4a9eff';
export const WAVEFORM_BACKGROUND = '#2a2a2a';
export const WAVEFORM_CHUNK_SIZE = 1024; // samples per chunk for streaming
export const WAVEFORM_MAX_CHUNKS = 100; // maximum chunks to keep in memory

// Render quality settings
export const RENDER_QUALITY = {
  draft: {
    resolution: 0.5,
    effects: false,
    transitions: false
  },
  preview: {
    resolution: 0.75,
    effects: true,
    transitions: true
  },
  full: {
    resolution: 1.0,
    effects: true,
    transitions: true
  }
} as const;

// Export these grouped constants for easier imports
export const TimelineConstants = {
  Scale: {
    PIXELS_PER_SECOND,
    MIN_ZOOM,
    MAX_ZOOM,
    DEFAULT_ZOOM,
    getScale,
    getZoom
  },
  Time: {
    DEFAULT_FPS,
    DEFAULT_TIME_FORMAT,
    DEFAULT_TIME_OPTIONS,
    FRAME_RATE_OPTIONS,
    getDuration,
    getEndTime
  },
  Snapping: {
    SNAP_THRESHOLD,
    MIN_FRAME_SNAP_SPACING,
    MAX_FRAME_SNAP_ZOOM
  },
  VirtualScroll: {
    VIRTUAL_SCROLL_BUFFER,
    MIN_CLIP_WIDTH,
    MAX_VISIBLE_CLIPS
  },
  History: {
    MAX_HISTORY_SIZE
  },
  Performance: {
    SCROLL_THROTTLE,
    PLAYBACK_UPDATE_INTERVAL,
    WAVEFORM_RESOLUTION
  },
  UI: {
    TRACK_HEIGHT,
    HEADER_HEIGHT,
    RULER_HEIGHT,
    MIN_TRACK_WIDTH
  },
  Layers: {
    MAX_LAYERS,
    MIN_LAYER_HEIGHT,
    LAYER_SPACING
  },
  Transitions: {
    MIN_DURATION: MIN_TRANSITION_DURATION,
    MAX_DURATION: MAX_TRANSITION_DURATION,
    DEFAULT_DURATION: DEFAULT_TRANSITION_DURATION,
    HANDLE_SIZE: TRANSITION_HANDLE_SIZE
  },
  Effects: {
    MAX_PER_CLIP: MAX_EFFECTS_PER_CLIP,
    PREVIEW_RESOLUTION: EFFECT_PREVIEW_RESOLUTION
  },
  Waveform: {
    HEIGHT: WAVEFORM_HEIGHT,
    COLOR: WAVEFORM_COLOR,
    BACKGROUND: WAVEFORM_BACKGROUND,
    CHUNK_SIZE: WAVEFORM_CHUNK_SIZE,
    MAX_CHUNKS: WAVEFORM_MAX_CHUNKS
  },
  RenderQuality: RENDER_QUALITY
} as const;

=====================================
FILE: src/renderer/utils/timelineUnits.ts
=====================================
import { TimelineConstants } from './timelineConstants';

/**
 * Time formatting and conversion utilities
 */

export interface TimeFormatOptions {
  fps?: number;
  showFrames?: boolean;
  showMilliseconds?: boolean;
  padHours?: boolean;
  compact?: boolean;
  format?: 'standard' | 'frames' | 'milliseconds' | 'timecode';
}

/**
 * Format time in seconds to a string representation
 * Formats:
 * - standard: "HH:MM:SS:FF" or "HH:MM:SS.mmm"
 * - frames: "123" (total frames)
 * - milliseconds: "1234" (total milliseconds)
 * - timecode: "01:00:00:00" (SMPTE timecode)
 */
export const formatTime = (seconds: number, options: TimeFormatOptions = {}): string => {
  const opts = { ...TimelineConstants.Time.DEFAULT_TIME_OPTIONS, ...options };
  const { fps, showFrames, showMilliseconds, padHours, compact, format = 'standard' } = opts;

  // Handle special formats
  if (format === 'frames') {
    return Math.floor(seconds * fps).toString();
  }
  if (format === 'milliseconds') {
    return Math.floor(seconds * 1000).toString();
  }

  // Calculate time components
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const frames = Math.floor((seconds % 1) * fps);
  const milliseconds = Math.floor((seconds % 1) * 1000);

  // Handle compact format (MM:SS)
  if (compact && hours === 0) {
    if (showFrames) {
      return `${minutes}:${String(secs).padStart(2, '0')}:${String(frames).padStart(2, '0')}`;
    }
    if (showMilliseconds) {
      return `${minutes}:${String(secs).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
    }
    return `${minutes}:${String(secs).padStart(2, '0')}`;
  }

  // Build time parts
  const parts: string[] = [];

  // Add hours if needed
  if (hours > 0 || padHours) {
    parts.push(String(hours).padStart(2, '0'));
  }

  // Add minutes and seconds
  parts.push(String(minutes).padStart(2, '0'));
  parts.push(String(secs).padStart(2, '0'));

  // Add frames or milliseconds
  if (showFrames) {
    parts.push(String(frames).padStart(2, '0'));
  } else if (showMilliseconds) {
    parts.push(String(milliseconds).padStart(3, '0'));
  }

  // Join with appropriate separator
  const separator = showMilliseconds ? '.' : ':';
  const mainParts = parts.slice(0, -1).join(':');
  const fractionalPart = parts[parts.length - 1];

  return showFrames || !showMilliseconds
    ? parts.join(':')
    : `${mainParts}${separator}${fractionalPart}`;
};

/**
 * Parse a time string into seconds
 * Supports formats:
 * - HH:MM:SS:FF (frames)
 * - HH:MM:SS.mmm (milliseconds)
 * - HH:MM:SS
 * - MM:SS
 * - SS
 */
export const parseTime = (timeStr: string, fps: number = TimelineConstants.Time.DEFAULT_FPS): number => {
  // Handle empty or invalid input
  if (!timeStr) return 0;

  // Check for milliseconds format (SS.mmm)
  if (timeStr.includes('.')) {
    const [main, fraction] = timeStr.split('.');
    return parseFloat(`${main}.${fraction}`);
  }

  const parts = timeStr.split(':').map(Number);
  let seconds = 0;

  switch (parts.length) {
    case 4: // HH:MM:SS:FF
      seconds = parts[0] * 3600 + parts[1] * 60 + parts[2] + parts[3] / fps;
      break;
    case 3: // HH:MM:SS
      seconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
      break;
    case 2: // MM:SS
      seconds = parts[0] * 60 + parts[1];
      break;
    case 1: // SS
      seconds = parts[0];
      break;
    default:
      throw new Error('Invalid time format');
  }

  return seconds;
};

/**
 * Frame-time conversion utilities
 */

export const framesToTime = (frames: number, fps: number = TimelineConstants.Time.DEFAULT_FPS): number => {
  return frames / fps;
};

export const timeToFrames = (time: number, fps: number = TimelineConstants.Time.DEFAULT_FPS): number => {
  return Math.floor(time * fps);
};

export const getFrameAtTime = (time: number, fps: number = TimelineConstants.Time.DEFAULT_FPS): number => {
  return Math.floor(time * fps);
};

export const getTimeAtFrame = (frame: number, fps: number = TimelineConstants.Time.DEFAULT_FPS): number => {
  return frame / fps;
};

/**
 * Check if time aligns with frame boundary
 */
export const isFrameAligned = (time: number, fps: number = TimelineConstants.Time.DEFAULT_FPS): boolean => {
  const frames = time * fps;
  return Math.abs(frames - Math.round(frames)) < Number.EPSILON;
};

/**
 * Duration utilities
 */

export const getDuration = TimelineConstants.Time.getDuration;
export const getEndTime = TimelineConstants.Time.getEndTime;

/**
 * Frame rate utilities
 */

export const isValidFrameRate = (fps: number): boolean => {
  return TimelineConstants.Time.FRAME_RATE_OPTIONS.includes(fps as any);
};

export const getNearestValidFrameRate = (fps: number): number => {
  return TimelineConstants.Time.FRAME_RATE_OPTIONS.reduce((prev, curr) => 
    Math.abs(curr - fps) < Math.abs(prev - fps) ? curr : prev
  );
};

=====================================
FILE: src/renderer/utils/timelineScale.ts
=====================================
import { TimelineConstants } from './timelineConstants';

/**
 * Timeline scale utilities for consistent coordinate/time conversions
 */

/**
 * Convert time to pixels based on zoom level
 */
export const timeToPixels = (time: number, zoom: number): number => {
  return time * TimelineConstants.Scale.getScale(zoom);
};

/**
 * Convert pixels to time based on zoom level
 */
export const pixelsToTime = (pixels: number, zoom: number): number => {
  return pixels / TimelineConstants.Scale.getScale(zoom);
};

/**
 * Get current pixels per second based on zoom level
 */
export const getPixelsPerSecond = (zoom: number): number => {
  return TimelineConstants.Scale.getScale(zoom);
};

/**
 * Get current pixels per frame based on zoom level and fps
 */
export const getPixelsPerFrame = (zoom: number, fps: number): number => {
  return TimelineConstants.Scale.getScale(zoom) / fps;
};

/**
 * Calculate minimum zoom level to fit duration in width
 */
export const getMinZoomLevel = (duration: number, width: number): number => {
  return Math.max(
    width / (duration * TimelineConstants.Scale.PIXELS_PER_SECOND),
    TimelineConstants.Scale.MIN_ZOOM
  );
};

/**
 * Calculate visible duration at current zoom level and width
 */
export const getVisibleDuration = (width: number, zoom: number): number => {
  return width / TimelineConstants.Scale.getScale(zoom);
};

/**
 * Calculate content width for duration at zoom level
 */
export const getContentWidth = (duration: number, zoom: number): number => {
  return duration * TimelineConstants.Scale.getScale(zoom);
};

/**
 * Calculate minimum width needed to display duration at zoom level
 */
export const getMinWidth = (duration: number, zoom: number): number => {
  return Math.max(
    duration * TimelineConstants.Scale.getScale(zoom),
    TimelineConstants.UI.MIN_TRACK_WIDTH
  );
};

/**
 * Calculate optimal zoom level for a given duration and width
 * with optional padding factor (1.0 = no padding, 1.1 = 10% padding)
 */
export const getOptimalZoom = (duration: number, width: number, padding: number = 1.0): number => {
  const zoom = (width / (duration * TimelineConstants.Scale.PIXELS_PER_SECOND)) / padding;
  return Math.min(
    Math.max(zoom, TimelineConstants.Scale.MIN_ZOOM),
    TimelineConstants.Scale.MAX_ZOOM
  );
};

/**
 * Clamp zoom level to valid range
 */
export const clampZoom = (zoom: number): number => {
  return Math.min(
    Math.max(zoom, TimelineConstants.Scale.MIN_ZOOM),
    TimelineConstants.Scale.MAX_ZOOM
  );
};

=====================================
FILE: src/renderer/components/Timeline.tsx
=====================================
import React, { useCallback, useRef, useEffect, useState, memo } from 'react';
import { TimelineTracks } from './TimelineTracks';
import { TimelineRuler } from './TimelineRuler';
import { TimelinePlayhead } from './TimelinePlayhead';
import { useTimelineContext } from '../hooks/useTimelineContext';
import { useTimelineViewport } from '../hooks/useTimelineViewport';
import { throttle, THROTTLE } from '../utils/throttle';
import { ActionTypes, Track } from '../types/timeline';
import { logger } from '../utils/logger';

interface TimelineProps {
  containerWidth: number;
  scrollLeft: number;
  onScroll: (scrollLeft: number, scrollTop: number) => void;
  onTimeUpdate: (time: number) => void;
}

// Memoized sub-components to prevent unnecessary re-renders

const MemoizedRuler = memo(({ 
  currentTime, 
  duration, 
  zoom, 
  fps, 
  onTimeChange, 
  containerWidth, 
  scrollLeft 
}: {
  currentTime: number;
  duration: number;
  zoom: number;
  fps: number;
  onTimeChange: (time: number) => void;
  containerWidth: number;
  scrollLeft: number;
}) => (
  <TimelineRuler
    currentTime={currentTime}
    duration={duration}
    zoom={zoom}
    fps={fps}
    onTimeChange={onTimeChange}
    containerWidth={containerWidth}
    scrollLeft={scrollLeft}
  />
));

const MemoizedPlayhead = memo(({
  currentTime,
  isPlaying,
  zoom,
  fps,
  onTimeUpdate
}: {
  currentTime: number;
  isPlaying: boolean;
  zoom: number;
  fps: number;
  onTimeUpdate: (time: number) => void;
}) => (
  <TimelinePlayhead
    currentTime={currentTime}
    isPlaying={isPlaying}
    zoom={zoom}
    fps={fps}
    onTimeUpdate={onTimeUpdate}
  />
));

const MemoizedTracks = memo(({
  tracks,
  selectedTrackId,
  selectedClipIds,
  onSelectTrack,
  onSelectClip,
  onClipDragStart,
  onClipDragEnd,
  zoom,
  fps
}: {
  tracks: Track[];
  selectedTrackId?: string;
  selectedClipIds: string[];
  onSelectTrack: (trackId: string) => void;
  onSelectClip: (clipId: string) => void;
  onClipDragStart: (clipId: string) => void;
  onClipDragEnd: () => void;
  zoom: number;
  fps: number;
}) => (
  <TimelineTracks
    tracks={tracks}
    selectedTrackId={selectedTrackId}
    selectedClipIds={selectedClipIds}
    onSelectTrack={onSelectTrack}
    onSelectClip={onSelectClip}
    onClipDragStart={onClipDragStart}
    onClipDragEnd={onClipDragEnd}
    zoom={zoom}
    fps={fps}
  />
));

export const Timeline: React.FC<TimelineProps> = memo(({
  containerWidth,
  scrollLeft,
  onScroll,
  onTimeUpdate
}) => {
  const { state, dispatch } = useTimelineContext();
  const { timeToPixels } = useTimelineViewport();
  const containerRef = useRef<HTMLDivElement>(null);
  const [contentWidth, setContentWidth] = useState(0);

  // Memoize callback handlers to prevent unnecessary re-renders
  const handleTimeChange = useCallback((time: number) => {
    dispatch({
      type: ActionTypes.SET_CURRENT_TIME,
      payload: { time }
    });
  }, [dispatch]);

  const handleSelectTrack = useCallback((trackId: string) => {
    dispatch({
      type: ActionTypes.SELECT_TRACK,
      payload: { trackId }
    });
  }, [dispatch]);

  const handleSelectClip = useCallback((clipId: string) => {
    dispatch({
      type: ActionTypes.SELECT_CLIPS,
      payload: { clipIds: [clipId] }
    });
  }, [dispatch]);

  const handleClipDragStart = useCallback((clipId: string) => {
    dispatch({
      type: ActionTypes.SET_DRAGGING,
      payload: {
        isDragging: true,
        clipId
      }
    });
  }, [dispatch]);

  const handleClipDragEnd = useCallback(() => {
    dispatch({
      type: ActionTypes.SET_DRAGGING,
      payload: {
        isDragging: false
      }
    });
  }, [dispatch]);

  // Calculate content width based on duration and zoom
  useEffect(() => {
    const minWidth = containerWidth;
    const durationWidth = state.duration * state.zoom * 100;
    const newWidth = Math.max(minWidth, durationWidth);
    setContentWidth(newWidth);

    logger.debug('Timeline content width updated:', {
      containerWidth,
      durationWidth,
      contentWidth: newWidth
    });
  }, [containerWidth, state.duration, state.zoom]);

  // Handle scroll events with throttling
  const handleScroll = useCallback(throttle((e: React.UIEvent<HTMLDivElement>) => {
    const target = e.currentTarget;
    onScroll(target.scrollLeft, target.scrollTop);
  }, THROTTLE.SCROLL), [onScroll]);

  // Sync scroll position from props
  useEffect(() => {
    if (containerRef.current && containerRef.current.scrollLeft !== scrollLeft) {
      containerRef.current.scrollLeft = scrollLeft;
    }
  }, [scrollLeft]);

  return (
    <div 
      ref={containerRef}
      className="timeline"
      onScroll={handleScroll}
      style={{
        position: 'relative',
        width: '100%',
        height: '100%',
        overflow: 'auto'
      }}
    >
      <div 
        className="timeline-content"
        style={{
          position: 'relative',
          width: contentWidth,
          minHeight: '100%'
        }}
      >
        <MemoizedRuler
          currentTime={state.currentTime}
          duration={state.duration}
          zoom={state.zoom}
          fps={state.fps}
          onTimeChange={handleTimeChange}
          containerWidth={containerWidth}
          scrollLeft={scrollLeft}
        />
        <MemoizedPlayhead
          currentTime={state.currentTime}
          isPlaying={state.isPlaying}
          zoom={state.zoom}
          fps={state.fps}
          onTimeUpdate={handleTimeChange}
        />
        <MemoizedTracks
          tracks={state.tracks}
          selectedTrackId={state.selectedTrackId}
          selectedClipIds={state.selectedClipIds}
          onSelectTrack={handleSelectTrack}
          onSelectClip={handleSelectClip}
          onClipDragStart={handleClipDragStart}
          onClipDragEnd={handleClipDragEnd}
          zoom={state.zoom}
          fps={state.fps}
        />
      </div>
    </div>
  );
});

// Add display names for debugging
MemoizedRuler.displayName = 'MemoizedRuler';
MemoizedPlayhead.displayName = 'MemoizedPlayhead';
MemoizedTracks.displayName = 'MemoizedTracks';
Timeline.displayName = 'Timeline';

=====================================
FILE: src/renderer/hooks/useSnapPoints.ts
=====================================
import { useCallback, useMemo } from 'react';
import { Track, Clip, isMediaClip } from '../types/timeline';
import { isFrameAligned, roundToFrame } from '../utils/timeValidation';
import { logger } from '../utils/logger';

export interface SnapPoint {
  time: number;
  type: string;
  source: string;
}

// Constants for snap point optimization
const MIN_FRAME_PIXEL_SPACING = 10; // Minimum pixels between frame snap points
const MAX_FRAME_SNAP_ZOOM = 4; // Maximum zoom level for frame snapping
const FRAME_SNAP_WINDOW = 5; // Number of frames to generate on each side of current time

export const useSnapPoints = (fps: number) => {
  const getClipSnapPoints = useCallback((clip: Clip): SnapPoint[] => {
    const points: SnapPoint[] = [
      {
        time: clip.startTime,
        type: 'clip-start',
        source: clip.id
      },
      {
        time: clip.endTime,
        type: 'clip-end',
        source: clip.id
      }
    ];

    // Add trim points if this is a media clip
    if (isMediaClip(clip)) {
      if (typeof clip.trimStart === 'number') {
        points.push({
          time: clip.startTime + clip.trimStart,
          type: 'trim-start',
          source: clip.id
        });
      }

      if (typeof clip.trimEnd === 'number') {
        points.push({
          time: clip.startTime + clip.trimEnd,
          type: 'trim-end',
          source: clip.id
        });
      }
    }

    return points;
  }, []);

  // Memoize clip snap points to prevent recalculation
  const getClipsSnapPoints = useCallback((tracks: Track[]): SnapPoint[] => {
    const points: SnapPoint[] = [];
    tracks.forEach(track => {
      track.clips.forEach(clip => {
        points.push(...getClipSnapPoints(clip));
      });
    });
    return points;
  }, [getClipSnapPoints]);

  // Memoize marker snap points
  const getMarkerSnapPoints = useCallback((markers: { time: number; id: string }[]): SnapPoint[] => {
    return markers.map(marker => ({
      time: marker.time,
      type: 'marker',
      source: marker.id
    }));
  }, []);

  const getFrameSnapPoints = useCallback((
    currentTime: number,
    zoom: number,
    pixelsPerFrame: number
  ): SnapPoint[] => {
    // Skip frame snap points if zoom is too high or frame spacing is too small
    if (zoom > MAX_FRAME_SNAP_ZOOM || pixelsPerFrame < MIN_FRAME_PIXEL_SPACING) {
      return [];
    }

    const currentFrame = Math.round(currentTime * fps);
    const points: SnapPoint[] = [];

    // Only generate frame points within a window around current time
    for (let offset = -FRAME_SNAP_WINDOW; offset <= FRAME_SNAP_WINDOW; offset++) {
      const frame = currentFrame + offset;
      if (frame >= 0) { // Prevent negative frame numbers
        points.push({
          time: frame / fps,
          type: 'frame',
          source: `frame-${frame}`
        });
      }
    }

    return points;
  }, [fps]);

  const getAllSnapPoints = useCallback((
    tracks: Track[],
    markers: { time: number; id: string }[] = [],
    currentTime: number,
    zoom: number = 1,
    pixelsPerFrame: number = 0
  ): SnapPoint[] => {
    // Get clip and marker points (these are relatively few in number)
    const clipPoints = getClipsSnapPoints(tracks);
    const markerPoints = getMarkerSnapPoints(markers);

    // Add playhead point
    const playheadPoint = {
      time: currentTime,
      type: 'playhead',
      source: 'playhead'
    };

    // Get frame points (these can be numerous, so we optimize them)
    const framePoints = getFrameSnapPoints(currentTime, zoom, pixelsPerFrame);

    const allPoints = [
      ...clipPoints,
      ...markerPoints,
      playheadPoint,
      ...framePoints
    ];

    logger.debug('Snap points', {
      total: allPoints.length,
      clips: clipPoints.length,
      markers: markerPoints.length,
      frames: framePoints.length,
      zoom,
      pixelsPerFrame
    });

    return allPoints;
  }, [getClipsSnapPoints, getMarkerSnapPoints, getFrameSnapPoints]);

  const findNearestSnapPoint = useCallback((
    time: number,
    snapPoints: SnapPoint[],
    threshold: number,
    excludeTypes: string[] = []
  ): SnapPoint | null => {
    // Quick check if we're already on a frame boundary
    if (isFrameAligned(time, fps)) {
      return {
        time,
        type: 'frame',
        source: `frame-${Math.round(time * fps)}`
      };
    }

    // Find nearest point within threshold
    let nearestPoint: SnapPoint | null = null;
    let minDistance = threshold;

    // Sort points by distance first to optimize search
    const sortedPoints = snapPoints
      .filter(point => !excludeTypes.includes(point.type))
      .sort((a, b) => Math.abs(a.time - time) - Math.abs(b.time - time));

    // Only check points until we exceed the threshold
    for (const point of sortedPoints) {
      const distance = Math.abs(point.time - time);
      if (distance > minDistance) break; // No need to check further points
      minDistance = distance;
      nearestPoint = point;
    }

    // If no point found within threshold, snap to nearest frame
    if (!nearestPoint) {
      const roundedTime = roundToFrame(time, fps);
      if (Math.abs(roundedTime - time) < threshold) {
        nearestPoint = {
          time: roundedTime,
          type: 'frame',
          source: `frame-${Math.round(roundedTime * fps)}`
        };
      }
    }

    return nearestPoint;
  }, [fps]);

  return {
    getAllSnapPoints,
    findNearestSnapPoint,
    getClipSnapPoints
  };
};

=====================================
FILE: src/renderer/hooks/useVirtualScroll.ts
=====================================
import { useCallback, useMemo } from 'react';
import { useTimelineContext } from './useTimelineContext';
import { useTimelineViewport } from './useTimelineViewport';
import { Track, Clip } from '../types/timeline';
import { logger } from '../utils/logger';

// Increase buffer for smoother scrolling at high resolutions
const BUFFER_FACTOR = 2.0; // Extra buffer to prevent popping at edges
const MIN_CLIP_WIDTH = 10; // Minimum width in pixels to render a clip
const MAX_VISIBLE_CLIPS = 1000; // Maximum number of clips to render at once
const CLIP_DENSITY_THRESHOLD = 0.8; // Threshold for clip density optimization

interface VirtualizedData {
  tracks: Track[];
  visibleTimeRange: [number, number];
  visibleClipsCount: number;
  totalClipsCount: number;
  density: number;
}

export const useVirtualScroll = (containerWidth: number) => {
  const { state } = useTimelineContext();
  const { timeToPixels, pixelsToTime, getVisibleTimeRange } = useTimelineViewport();

  /**
   * Calculate visible time range with dynamic buffer
   */
  const getBufferedTimeRange = useCallback((): [number, number] => {
    const [visibleStart, visibleEnd] = getVisibleTimeRange(containerWidth);
    const visibleDuration = visibleEnd - visibleStart;
    
    // Adjust buffer based on zoom level and timeline duration
    const zoomFactor = Math.max(0.5, Math.min(2, state.zoom));
    const durationFactor = Math.min(1, 60 * 60 / state.duration); // Adjust for timelines > 1 hour
    const dynamicBuffer = visibleDuration * (BUFFER_FACTOR * zoomFactor * durationFactor - 1) / 2;

    return [
      Math.max(0, visibleStart - dynamicBuffer),
      Math.min(state.duration, visibleEnd + dynamicBuffer)
    ];
  }, [containerWidth, state.duration, state.zoom, getVisibleTimeRange]);

  /**
   * Check if clip is visible and renderable
   */
  const isClipVisible = useCallback((clip: Clip, timeRange: [number, number], clipDensity: number): boolean => {
    const [rangeStart, rangeEnd] = timeRange;
    
    // Basic visibility check
    if (clip.endTime < rangeStart || clip.startTime > rangeEnd) {
      return false;
    }

    // Width check with dynamic threshold based on clip density
    const clipWidth = timeToPixels(clip.endTime - clip.startTime);
    const minWidth = clipDensity > CLIP_DENSITY_THRESHOLD ? 
      MIN_CLIP_WIDTH * (1 + (clipDensity - CLIP_DENSITY_THRESHOLD) * 5) : 
      MIN_CLIP_WIDTH;

    if (clipWidth < minWidth) {
      return false;
    }

    return true;
  }, [timeToPixels]);

  /**
   * Calculate clip density in the visible range
   */
  const getClipDensity = useCallback((clips: Clip[], timeRange: [number, number]): number => {
    const [start, end] = timeRange;
    const rangeDuration = end - start;
    const totalClipDuration = clips.reduce((sum, clip) => {
      if (clip.endTime < start || clip.startTime > end) return sum;
      const clipStart = Math.max(start, clip.startTime);
      const clipEnd = Math.min(end, clip.endTime);
      return sum + (clipEnd - clipStart);
    }, 0);

    return totalClipDuration / rangeDuration;
  }, []);

  /**
   * Get virtualized tracks and clips with optimizations
   */
  const getVirtualizedData = useCallback((): VirtualizedData => {
    const timeRange = getBufferedTimeRange();
    let visibleClipsCount = 0;
    let totalClipsCount = 0;
    let totalDensity = 0;

    // First pass: calculate total clip density
    state.tracks.forEach(track => {
      const density = getClipDensity(track.clips, timeRange);
      totalDensity += density;
    });
    const averageDensity = totalDensity / state.tracks.length;

    // Second pass: filter clips with density-based optimizations
    const virtualizedTracks = state.tracks.map(track => {
      totalClipsCount += track.clips.length;

      // Sort clips by duration (longer clips get priority)
      const sortedClips = [...track.clips].sort((a, b) => 
        (b.endTime - b.startTime) - (a.endTime - a.startTime)
      );

      const visibleClips = sortedClips
        .filter(clip => {
          if (visibleClipsCount >= MAX_VISIBLE_CLIPS) return false;
          const visible = isClipVisible(clip, timeRange, averageDensity);
          if (visible) visibleClipsCount++;
          return visible;
        })
        // Restore original order
        .sort((a, b) => a.startTime - b.startTime);

      return {
        ...track,
        clips: visibleClips
      };
    });

    logger.debug('Virtual scroll update:', {
      timeRange,
      visibleClips: visibleClipsCount,
      totalClips: totalClipsCount,
      density: averageDensity,
      reduction: `${Math.round((1 - visibleClipsCount / totalClipsCount) * 100)}%`
    });

    return {
      tracks: virtualizedTracks,
      visibleTimeRange: timeRange,
      visibleClipsCount,
      totalClipsCount,
      density: averageDensity
    };
  }, [state.tracks, getBufferedTimeRange, isClipVisible, getClipDensity]);

  /**
   * Memoize virtualized data with additional dependencies
   */
  const virtualizedData = useMemo(() => getVirtualizedData(), [
    getVirtualizedData,
    state.tracks,
    state.zoom,
    state.scrollX,
    state.duration
  ]);

  return {
    virtualizedTracks: virtualizedData.tracks,
    visibleTimeRange: virtualizedData.visibleTimeRange,
    visibleClipsCount: virtualizedData.visibleClipsCount,
    totalClipsCount: virtualizedData.totalClipsCount,
    density: virtualizedData.density,
    isClipVisible: (clip: Clip, timeRange: [number, number]) => 
      isClipVisible(clip, timeRange, virtualizedData.density)
  };
};

=====================================
FILE: src/renderer/contexts/TimelineContext.tsx
=====================================
import React, { createContext, useReducer, useContext } from 'react';
import { produce } from 'immer';
import {
  TimelineState,
  TimelineAction,
  ActionTypes,
  initialTimelineState,
  isMediaClip
} from '../types/timeline';
import { applyStateDiff, createStateDiff, StateDiff } from '../utils/historyDiff';
import { logger } from '../utils/logger';

export interface TimelineContextValue {
  state: TimelineState;
  dispatch: React.Dispatch<TimelineAction>;
}

export const TimelineContext = createContext<TimelineContextValue | undefined>(undefined);

const MAX_HISTORY_SIZE = 100;

// Actions that should not be added to history
const NON_UNDOABLE_ACTIONS = new Set<ActionTypes>([
  ActionTypes.SET_CURRENT_TIME,
  ActionTypes.SET_PLAYING,
  ActionTypes.SET_SCROLL_X,
  ActionTypes.SET_SCROLL_Y,
  ActionTypes.SET_DRAGGING,
  ActionTypes.SET_ERROR,
  ActionTypes.RESTORE_SNAPSHOT,
  ActionTypes.SET_IS_PLAYING,
  ActionTypes.SET_IS_DRAGGING,
  ActionTypes.SET_SELECTED_CLIP_IDS,
  ActionTypes.SET_SELECTED_TRACK_ID
]);

// Actions that should create a new history checkpoint
const CHECKPOINT_ACTIONS = new Set<ActionTypes>([
  ActionTypes.ADD_TRACK,
  ActionTypes.REMOVE_TRACK,
  ActionTypes.ADD_CLIP,
  ActionTypes.REMOVE_CLIP,
  ActionTypes.SPLIT_CLIP,
  ActionTypes.SET_TRACKS,
  ActionTypes.MOVE_TRACK,
  ActionTypes.MOVE_CLIP
]);

export const timelineReducer = (state: TimelineState, action: TimelineAction): TimelineState => {
  return produce(state, draft => {
    let shouldCreateHistoryEntry = false;
    let historyDescription = '';
    let beforeState = state;

    // Pre-process action to determine if it should be added to history
    if (!NON_UNDOABLE_ACTIONS.has(action.type)) {
      shouldCreateHistoryEntry = true;
      historyDescription = getHistoryDescription(action);
      beforeState = { ...state };
    }

    // Apply the action
    switch (action.type) {
      case ActionTypes.SET_STATE:
        return action.payload;

      case ActionTypes.SET_CURRENT_TIME:
        draft.currentTime = action.payload.time;
        break;

      case ActionTypes.SET_PLAYING:
        draft.isPlaying = action.payload;
        break;

      case ActionTypes.SET_SCROLL_X:
        draft.scrollX = action.payload;
        break;

      case ActionTypes.SET_SCROLL_Y:
        draft.scrollY = action.payload;
        break;

      case ActionTypes.SET_ZOOM:
        draft.zoom = action.payload;
        break;

      case ActionTypes.SET_FPS:
        draft.fps = action.payload;
        break;

      case ActionTypes.SET_DRAGGING:
        draft.isDragging = action.payload.isDragging;
        draft.dragStartX = action.payload.dragStartX;
        draft.dragStartY = action.payload.dragStartY;
        break;

      case ActionTypes.SET_ERROR:
        draft.error = action.payload;
        break;

      case ActionTypes.SELECT_TRACK:
        draft.selectedTrackId = action.payload.trackId;
        break;

      case ActionTypes.SELECT_CLIPS:
        draft.selectedClipIds = action.payload.clipIds;
        break;

      case ActionTypes.PUSH_HISTORY:
        // Remove future entries if we're not at the end
        if (draft.history.currentIndex < draft.history.entries.length - 1) {
          draft.history.entries = draft.history.entries.slice(0, draft.history.currentIndex + 1);
        }

        const entry = action.payload.entry;

        // For checkpoint actions, store a full state diff
        if (CHECKPOINT_ACTIONS.has(action.type)) {
          entry.type = 'full';
        }

        // Add new entry
        draft.history.entries.push(entry);

        // Maintain max size
        if (draft.history.entries.length > MAX_HISTORY_SIZE) {
          // Keep the first entry (initial state) and remove oldest non-checkpoint entries
          const entries = draft.history.entries;
          const checkpoints = entries.filter((e, i) => i === 0 || e.type === 'full');
          const nonCheckpoints = entries.filter((e, i) => i !== 0 && e.type !== 'full');
          
          // Remove oldest non-checkpoints to get under max size
          const toRemove = entries.length - MAX_HISTORY_SIZE;
          nonCheckpoints.splice(0, toRemove);

          // Reconstruct history with remaining entries
          draft.history.entries = [
            entries[0],
            ...checkpoints.slice(1),
            ...nonCheckpoints
          ].slice(-MAX_HISTORY_SIZE);
        }

        // Update current index
        draft.history.currentIndex = draft.history.entries.length - 1;

        logger.debug('History updated:', {
          entries: draft.history.entries.length,
          currentIndex: draft.history.currentIndex,
          type: entry.type
        });
        break;

      case ActionTypes.RESTORE_SNAPSHOT:
        Object.assign(draft, action.payload);
        break;

      case ActionTypes.SET_HISTORY_INDEX:
        draft.history.currentIndex = action.payload;
        break;

      case ActionTypes.CLEAR_HISTORY:
        // Keep initial state
        const initialEntry = draft.history.entries[0];
        draft.history.entries = initialEntry ? [initialEntry] : [];
        draft.history.currentIndex = -1;
        break;

      case ActionTypes.UNDO:
        if (draft.history.currentIndex > 0) {
          let targetIndex = draft.history.currentIndex - 1;
          const prevDiff = draft.history.entries[draft.history.currentIndex];

          // If current entry is not a checkpoint, keep going until we hit one
          while (
            targetIndex > 0 &&
            prevDiff.type !== 'full' &&
            draft.history.entries[targetIndex].type !== 'full'
          ) {
            targetIndex--;
          }

          // Apply all diffs from target to current
          let currentState = state;
          for (let i = targetIndex; i <= draft.history.currentIndex; i++) {
            currentState = applyStateDiff(currentState, draft.history.entries[i], true);
          }

          draft.history.currentIndex = targetIndex;
          Object.assign(draft, currentState);
        }
        break;

      case ActionTypes.REDO:
        if (draft.history.currentIndex < draft.history.entries.length - 1) {
          let targetIndex = draft.history.currentIndex + 1;
          const nextDiff = draft.history.entries[targetIndex];

          // If next entry is not a checkpoint, keep going until we hit one
          while (
            targetIndex < draft.history.entries.length - 1 &&
            nextDiff.type !== 'full' &&
            draft.history.entries[targetIndex + 1].type !== 'full'
          ) {
            targetIndex++;
          }

          // Apply all diffs from current to target
          let currentState = state;
          for (let i = draft.history.currentIndex + 1; i <= targetIndex; i++) {
            currentState = applyStateDiff(currentState, draft.history.entries[i]);
          }

          draft.history.currentIndex = targetIndex;
          Object.assign(draft, currentState);
        }
        break;

      default:
        logger.warn('Unknown action type:', action);
    }

    // Post-process action to create history entry if needed
    if (shouldCreateHistoryEntry) {
      const diff = createStateDiff(beforeState, draft as TimelineState, historyDescription);
      draft.history.entries.push(diff);
      if (draft.history.entries.length > MAX_HISTORY_SIZE) {
        draft.history.entries = draft.history.entries.slice(-MAX_HISTORY_SIZE);
      }
      draft.history.currentIndex = draft.history.entries.length - 1;
    }
  });
};

const getHistoryDescription = (action: TimelineAction): string => {
  switch (action.type) {
    case ActionTypes.ADD_TRACK:
      return 'Add track';
    case ActionTypes.REMOVE_TRACK:
      return 'Remove track';
    case ActionTypes.ADD_CLIP:
      return 'Add clip';
    case ActionTypes.REMOVE_CLIP:
      return 'Remove clip';
    case ActionTypes.MOVE_CLIP:
      return 'Move clip';
    case ActionTypes.SPLIT_CLIP:
      return 'Split clip';
    case ActionTypes.TRIM_CLIP:
      return 'Trim clip';
    case ActionTypes.SET_ZOOM:
      return 'Change zoom';
    case ActionTypes.SET_FPS:
      return 'Change FPS';
    default:
      return action.type;
  }
};

export const TimelineProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, dispatch] = useReducer(timelineReducer, initialTimelineState);

  return (
    <TimelineContext.Provider value={{ state, dispatch }}>
      {children}
    </TimelineContext.Provider>
  );
};

export const useTimelineContext = () => {
  const context = useContext(TimelineContext);
  if (!context) {
    throw new Error('useTimelineContext must be used within a TimelineProvider');
  }
  return context;
};

=====================================
FILE: src/renderer/components/clips/CaptionClipContent.tsx
=====================================
import React from 'react';
import { CaptionClip, Caption } from '../../types/timeline';

interface CaptionClipContentProps {
  clip: CaptionClip;
  isSelected: boolean;
  zoom: number;
  fps: number;
}

export const CaptionClipContent: React.FC<CaptionClipContentProps> = ({
  clip,
  isSelected,
  zoom,
  fps
}) => {
  // Get speaker style for a caption
  const getSpeakerStyle = (caption: Caption) => {
    if (!clip.speakerStyles?.speakers || !caption.speakerId) return {};
    const style = clip.speakerStyles.speakers[caption.speakerId];
    return style ? {
      color: style.color,
      borderColor: style.color
    } : {};
  };

  // Get speaker name for a caption
  const getSpeakerName = (caption: Caption) => {
    if (!clip.speakerStyles?.speakers || !caption.speakerId) return 'Unknown';
    const style = clip.speakerStyles.speakers[caption.speakerId];
    return style ? style.name : 'Unknown';
  };

  return (
    <div className={`caption-clip-content ${isSelected ? 'selected' : ''}`}>
      <div className="caption-header">
        <span className="caption-title">{clip.name}</span>
      </div>
      <div className="caption-body">
        {clip.captions?.map((caption) => (
          <div
            key={caption.id}
            className="caption-item"
            style={getSpeakerStyle(caption)}
          >
            <span className="speaker-name">
              {getSpeakerName(caption)}:
            </span>
            <span className="caption-text">
              {caption.text}
            </span>
          </div>
        ))}
      </div>
    </div>
  );
};

=====================================
FILE: src/renderer/components/TimelineClip.tsx
=====================================
import React, { useCallback, useState } from 'react';
import { ClipWithLayer, isVideoClip, isAudioClip, isCaptionClip } from '../types/timeline';
import { VideoClipContent } from './clips/VideoClipContent';
import { AudioClipContent } from './clips/AudioClipContent';
import { CaptionClipContent } from './clips/CaptionClipContent';
import { formatTime } from '../utils/timelineUnits';

interface TimelineClipProps {
  clip: ClipWithLayer;
  layer: number;
  zoom: number;
  fps: number;
  onSelect: () => void;
  onDragStart: () => void;
  onDragEnd: () => void;
  tabIndex?: number;
  'aria-posinset'?: number;
  'aria-setsize'?: number;
}

const KEYBOARD_MOVE_STEP = 1; // 1 frame movement by default
const KEYBOARD_MOVE_FAST = 10; // 10 frame movement with shift

export const TimelineClip: React.FC<TimelineClipProps> = ({
  clip,
  layer,
  zoom,
  fps,
  onSelect,
  onDragStart,
  onDragEnd,
  tabIndex = 0,
  'aria-posinset': posinset,
  'aria-setsize': setsize
}) => {
  const [isKeyboardDragging, setIsKeyboardDragging] = useState(false);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onSelect();
    onDragStart();
  }, [onSelect, onDragStart]);

  const handleMouseUp = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onDragEnd();
  }, [onDragEnd]);

  const moveClip = useCallback((frameOffset: number) => {
    const frameDuration = 1 / fps;
    const timeOffset = frameOffset * frameDuration;
    const newStartTime = clip.startTime + timeOffset;
    const newEndTime = clip.endTime + timeOffset;

    // TODO: Dispatch move clip action with new times
    console.log('Move clip:', {
      clipId: clip.id,
      newStartTime,
      newEndTime
    });
  }, [clip, fps]);

  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    switch (e.key) {
      case 'Enter':
      case ' ':
        e.preventDefault();
        onSelect();
        break;

      case 'Delete':
      case 'Backspace':
        e.preventDefault();
        // TODO: Handle clip deletion
        break;

      // Start keyboard dragging mode
      case 'm':
        if (!isKeyboardDragging) {
          e.preventDefault();
          setIsKeyboardDragging(true);
          onDragStart();
        }
        break;

      // Move clip when in keyboard dragging mode
      case 'ArrowLeft':
        if (isKeyboardDragging) {
          e.preventDefault();
          moveClip(e.shiftKey ? -KEYBOARD_MOVE_FAST : -KEYBOARD_MOVE_STEP);
        }
        break;

      case 'ArrowRight':
        if (isKeyboardDragging) {
          e.preventDefault();
          moveClip(e.shiftKey ? KEYBOARD_MOVE_FAST : KEYBOARD_MOVE_STEP);
        }
        break;

      // End keyboard dragging mode
      case 'Escape':
        if (isKeyboardDragging) {
          e.preventDefault();
          setIsKeyboardDragging(false);
          onDragEnd();
        }
        break;
    }
  }, [isKeyboardDragging, onSelect, onDragStart, onDragEnd, moveClip]);

  const renderClipContent = () => {
    if (isVideoClip(clip)) {
      return (
        <VideoClipContent
          clip={clip}
          isSelected={false}
          zoom={zoom}
          fps={fps}
        />
      );
    }
    if (isAudioClip(clip)) {
      return (
        <AudioClipContent
          clip={clip}
          isSelected={false}
          zoom={zoom}
          fps={fps}
        />
      );
    }
    if (isCaptionClip(clip)) {
      return (
        <CaptionClipContent
          clip={clip}
          isSelected={false}
          zoom={zoom}
          fps={fps}
        />
      );
    }
    return null;
  };

  const startTimeFormatted = formatTime(clip.startTime, { fps, showFrames: true });
  const endTimeFormatted = formatTime(clip.endTime, { fps, showFrames: true });
  const durationFormatted = formatTime(clip.endTime - clip.startTime, { fps, showFrames: true });

  return (
    <div
      className={`timeline-clip ${clip.type} ${isKeyboardDragging ? 'keyboard-dragging' : ''}`}
      style={{
        position: 'absolute',
        left: clip.startTime * zoom * 100,
        width: (clip.endTime - clip.startTime) * zoom * 100,
        top: layer * 50,
        height: 45,
        cursor: isKeyboardDragging ? 'move' : 'pointer'
      }}
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      onKeyDown={handleKeyDown}
      role="listitem"
      aria-label={`${clip.name} clip from ${startTimeFormatted} to ${endTimeFormatted}, duration ${durationFormatted}`}
      aria-grabbed={isKeyboardDragging}
      aria-dropeffect="move"
      aria-roledescription={`${clip.type} clip`}
      aria-description={isKeyboardDragging 
        ? 'Press arrow keys to move clip, Shift+arrow keys to move faster, Escape to finish moving' 
        : 'Press M to start moving clip with keyboard'
      }
      tabIndex={tabIndex}
      aria-posinset={posinset}
      aria-setsize={setsize}
    >
      {renderClipContent()}
    </div>
  );
};

=====================================
FILE: src/renderer/components/TimelinePlayhead.tsx
=====================================
import React, { useCallback, useRef } from 'react';
import { useTimelineCoordinates } from '../hooks/useTimelineCoordinates';
import { useTimelineContext } from '../hooks/useTimelineContext';
import { useSnapPoints } from '../hooks/useSnapPoints';
import { throttle, THROTTLE } from '../utils/throttle';
import { clampTime } from '../utils/timeValidation';
import { formatTime } from '../utils/timelineUnits';
import { logger } from '../utils/logger';

interface TimelinePlayheadProps {
  currentTime: number;
  isPlaying: boolean;
  zoom: number;
  fps: number;
  onTimeUpdate: (time: number) => void;
}

export const TimelinePlayhead: React.FC<TimelinePlayheadProps> = ({
  currentTime,
  isPlaying,
  zoom,
  fps,
  onTimeUpdate
}) => {
  const { state } = useTimelineContext();
  const containerRef = useRef<HTMLDivElement>(null);
  const isDraggingRef = useRef(false);
  const { clientToTime } = useTimelineCoordinates(containerRef);
  const { findNearestSnapPoint, getAllSnapPoints } = useSnapPoints(fps);

  const handleTimeChange = useCallback((newTime: number, shouldSnap: boolean = true) => {
    if (shouldSnap) {
      const snapPoints = getAllSnapPoints(state.tracks, state.markers, currentTime);
      const nearestPoint = findNearestSnapPoint(
        newTime,
        snapPoints,
        1 / fps,
        ['frame', 'marker']
      );

      if (nearestPoint) {
        newTime = nearestPoint.time;
      }
    }

    const clampedTime = clampTime(newTime, {
      minValue: 0,
      maxValue: state.duration,
      snapToFrames: true,
      fps
    });

    onTimeUpdate(clampedTime);
  }, [state.tracks, state.markers, state.duration, currentTime, fps, findNearestSnapPoint, getAllSnapPoints, onTimeUpdate]);

  const handlePointerDown = useCallback((e: React.PointerEvent) => {
    if (!containerRef.current) return;

    isDraggingRef.current = true;
    containerRef.current.setPointerCapture(e.pointerId);

    const time = clientToTime({ x: e.clientX, y: e.clientY });
    handleTimeChange(time);

    logger.debug('Playhead drag started:', { time });
  }, [clientToTime, handleTimeChange]);

  const handlePointerMove = useCallback(throttle((e: React.PointerEvent) => {
    if (!isDraggingRef.current) return;

    const time = clientToTime({ x: e.clientX, y: e.clientY });
    handleTimeChange(time);

    logger.debug('Playhead dragged:', { time });
  }, THROTTLE.DRAG), [clientToTime, handleTimeChange]);

  const handlePointerUp = useCallback((e: React.PointerEvent) => {
    if (!containerRef.current) return;

    isDraggingRef.current = false;
    containerRef.current.releasePointerCapture(e.pointerId);

    logger.debug('Playhead drag ended');
  }, []);

  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    const frameStep = 1 / fps;
    let newTime = currentTime;

    switch (e.key) {
      case 'ArrowLeft':
        e.preventDefault();
        newTime = currentTime - (e.shiftKey ? frameStep * 10 : frameStep);
        handleTimeChange(newTime, false);
        break;
      case 'ArrowRight':
        e.preventDefault();
        newTime = currentTime + (e.shiftKey ? frameStep * 10 : frameStep);
        handleTimeChange(newTime, false);
        break;
      case 'Home':
        e.preventDefault();
        handleTimeChange(0, false);
        break;
      case 'End':
        e.preventDefault();
        handleTimeChange(state.duration, false);
        break;
    }
  }, [currentTime, fps, state.duration, handleTimeChange]);

  const formattedTime = formatTime(currentTime, { fps, showFrames: true });

  return (
    <div
      ref={containerRef}
      className={`timeline-playhead ${isPlaying ? 'playing' : ''}`}
      style={{
        position: 'absolute',
        top: 0,
        bottom: 0,
        left: currentTime * zoom * 100,
        width: 2,
        backgroundColor: '#f00',
        cursor: 'ew-resize',
        zIndex: 1000
      }}
    >
      <div 
        className="timeline-playhead-handle"
        role="slider"
        aria-label="Playhead"
        aria-valuemin={0}
        aria-valuemax={state.duration}
        aria-valuenow={currentTime}
        aria-valuetext={formattedTime}
        tabIndex={0}
        onPointerDown={handlePointerDown}
        onPointerMove={handlePointerMove}
        onPointerUp={handlePointerUp}
        onKeyDown={handleKeyDown}
        style={{
          position: 'absolute',
          top: -8,
          left: -8,
          width: 16,
          height: 16,
          backgroundColor: '#f00',
          borderRadius: '50%',
          cursor: 'pointer'
        }}
      />
    </div>
  );
};

=====================================
FILE: src/renderer/components/TimelineTrack.tsx
=====================================
import React, { useCallback, useRef } from 'react';
import { Track, Clip, createLayeredClip } from '../types/timeline';
import { TimelineClip } from './TimelineClip';
import { logger } from '../utils/logger';

interface TimelineTrackProps {
  track: Track;
  isSelected: boolean;
  zoom: number;
  fps: number;
  onSelectTrack: (trackId: string) => void;
  onSelectClip: (clipId: string) => void;
  onClipDragStart: (clipId: string) => void;
  onClipDragEnd: () => void;
}

export const TimelineTrack: React.FC<TimelineTrackProps> = ({
  track,
  isSelected,
  zoom,
  fps,
  onSelectTrack,
  onSelectClip,
  onClipDragStart,
  onClipDragEnd
}) => {
  const containerRef = useRef<HTMLDivElement>(null);

  // Calculate clip layers to prevent overlapping
  const getClipsWithLayers = useCallback(() => {
    const clipsWithLayers = track.clips.map((clip, baseLayer) => {
      let layer = baseLayer;

      track.clips.slice(0, baseLayer).forEach((prevClip) => {
        if (
          clip.startTime < prevClip.endTime &&
          clip.endTime > prevClip.startTime
        ) {
          layer++;
        }
      });

      return createLayeredClip(clip, layer);
    });

    logger.debug('Clips with layers:', {
      trackId: track.id,
      clips: clipsWithLayers
    });

    return clipsWithLayers;
  }, [track.clips]);

  const handleTrackClick = useCallback((e: React.MouseEvent) => {
    if (e.currentTarget === e.target) {
      onSelectTrack(track.id);
    }
  }, [track.id, onSelectTrack]);

  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    switch (e.key) {
      case 'Enter':
      case ' ':
        e.preventDefault();
        onSelectTrack(track.id);
        break;
      case 'ArrowUp':
        e.preventDefault();
        // Focus previous track
        const prevTrack = containerRef.current?.previousElementSibling;
        if (prevTrack instanceof HTMLElement) {
          prevTrack.focus();
        }
        break;
      case 'ArrowDown':
        e.preventDefault();
        // Focus next track
        const nextTrack = containerRef.current?.nextElementSibling;
        if (nextTrack instanceof HTMLElement) {
          nextTrack.focus();
        }
        break;
      case 'Tab':
        // Let default tab behavior work, but ensure clips are in tab order
        if (e.shiftKey && isSelected) {
          // When shift+tab on selected track, focus last clip
          const clips = containerRef.current?.querySelectorAll('.timeline-clip');
          const lastClip = clips?.[clips.length - 1];
          if (lastClip instanceof HTMLElement) {
            e.preventDefault();
            lastClip.focus();
          }
        }
        break;
    }
  }, [track.id, onSelectTrack, isSelected]);

  const clipsWithLayers = getClipsWithLayers();
  const trackHeight = (Math.max(...clipsWithLayers.map(c => c.layer)) + 1) * 50;

  return (
    <div
      ref={containerRef}
      className={`timeline-track ${isSelected ? 'selected' : ''} ${track.type}`}
      onClick={handleTrackClick}
      onKeyDown={handleKeyDown}
      role="region"
      aria-label={`${track.name} track`}
      aria-selected={isSelected}
      tabIndex={0}
      style={{
        height: trackHeight,
        opacity: track.isVisible ? 1 : 0.5,
        pointerEvents: track.isLocked ? 'none' : 'auto'
      }}
    >
      <div className="track-header">
        <span className="track-name">{track.name}</span>
        <div className="track-controls">
          {track.isLocked && (
            <span className="track-locked-indicator" role="img" aria-label="Track locked" />
          )}
          {!track.isVisible && (
            <span className="track-hidden-indicator" role="img" aria-label="Track hidden" />
          )}
        </div>
      </div>
      <div 
        className="track-content"
        role="list"
        aria-label={`Clips in ${track.name}`}
      >
        {clipsWithLayers.map((clip, index) => (
          <TimelineClip
            key={clip.id}
            clip={clip}
            layer={clip.layer}
            zoom={zoom}
            fps={fps}
            onSelect={() => onSelectClip(clip.id)}
            onDragStart={() => onClipDragStart(clip.id)}
            onDragEnd={onClipDragEnd}
            tabIndex={isSelected ? 0 : -1}
            aria-posinset={index + 1}
            aria-setsize={clipsWithLayers.length}
          />
        ))}
      </div>
    </div>
  );
};

=====================================
FILE: src/renderer/components/TimelineTracks.tsx
=====================================
import React, { useEffect } from 'react';
import { Track } from '../types/timeline';
import { TimelineTrack } from './TimelineTrack';
import { useVirtualScroll } from '../hooks/useVirtualScroll';
import { logger } from '../utils/logger';

interface TimelineTracksProps {
  tracks: Track[];
  selectedTrackId?: string;
  selectedClipIds: string[];
  onSelectTrack: (trackId: string) => void;
  onSelectClip: (clipId: string) => void;
  onClipDragStart: (clipId: string) => void;
  onClipDragEnd: () => void;
  zoom: number;
  fps: number;
}

export const TimelineTracks: React.FC<TimelineTracksProps> = ({
  tracks,
  selectedTrackId,
  selectedClipIds,
  onSelectTrack,
  onSelectClip,
  onClipDragStart,
  onClipDragEnd,
  zoom,
  fps
}) => {
  // Use virtual scrolling for performance
  const {
    virtualizedTracks,
    visibleTimeRange,
    visibleClipsCount,
    totalClipsCount
  } = useVirtualScroll(window.innerWidth);

  // Log performance metrics
  useEffect(() => {
    logger.debug('Timeline tracks performance:', {
      totalTracks: tracks.length,
      virtualizedTracks: virtualizedTracks.length,
      visibleClips: visibleClipsCount,
      totalClips: totalClipsCount,
      visibleTimeRange,
      reduction: {
        clips: `${Math.round((1 - visibleClipsCount / totalClipsCount) * 100)}%`,
        memory: `${Math.round((1 - (visibleClipsCount * 200) / (totalClipsCount * 200)) * 100)}%` // Rough estimate of memory savings
      }
    });
  }, [tracks.length, virtualizedTracks.length, visibleClipsCount, totalClipsCount, visibleTimeRange]);

  return (
    <div className="timeline-tracks">
      {virtualizedTracks.map((track) => (
        <TimelineTrack
          key={track.id}
          track={track}
          isSelected={track.id === selectedTrackId}
          zoom={zoom}
          fps={fps}
          onSelectTrack={onSelectTrack}
          onSelectClip={onSelectClip}
          onClipDragStart={onClipDragStart}
          onClipDragEnd={onClipDragEnd}
        />
      ))}
      {virtualizedTracks.length === 0 && (
        <div className="timeline-tracks-empty">
          <span>No tracks to display</span>
        </div>
      )}
      {virtualizedTracks.length > 0 && visibleClipsCount === 0 && (
        <div className="timeline-tracks-empty">
          <span>Zoom in to view clips</span>
        </div>
      )}
    </div>
  );
};

=====================================
FILE: src/renderer/hooks/useTimelineContext.ts
=====================================
import { useContext } from 'react';
import { TimelineContext, TimelineContextValue } from '../contexts/TimelineContext';

export const useTimelineContext = (): TimelineContextValue => {
  const context = useContext(TimelineContext);
  if (!context) {
    throw new Error('useTimelineContext must be used within a TimelineProvider');
  }
  return context;
};

=====================================
FILE: src/renderer/components/clips/VideoClipContent.tsx
=====================================
import React from 'react';
import { VideoClip, Effect } from '../../types/timeline';

interface VideoClipContentProps {
  clip: VideoClip;
  isSelected: boolean;
  zoom: number;
  fps: number;
}

export const VideoClipContent: React.FC<VideoClipContentProps> = ({
  clip,
  isSelected,
  zoom,
  fps
}) => {
  // Check if effect is active at current time
  const isEffectActive = (effect: Effect, currentTime: number): boolean => {
    if (!effect.enabled) return false;
    
    // If no time range is specified, effect is always active
    if (!effect.startTime && !effect.endTime) return true;
    
    // If only start time is specified, effect is active from that point on
    if (effect.startTime && !effect.endTime) {
      return currentTime >= effect.startTime;
    }
    
    // If only end time is specified, effect is active until that point
    if (!effect.startTime && effect.endTime) {
      return currentTime <= effect.endTime;
    }
    
    // Both start and end times are specified
    return currentTime >= (effect.startTime || 0) && currentTime <= (effect.endTime || Infinity);
  };

  return (
    <div className={`video-clip-content ${isSelected ? 'selected' : ''}`}>
      <div className="clip-header">
        <span className="clip-title">{clip.name}</span>
        {clip.effects.length > 0 && (
          <div className="effect-indicators">
            {clip.effects.map(effect => (
              <span
                key={effect.id}
                className={`effect-indicator ${effect.enabled ? 'active' : ''}`}
                title={`${effect.type} (${effect.enabled ? 'Enabled' : 'Disabled'})`}
              />
            ))}
          </div>
        )}
      </div>
      {clip.thumbnail && (
        <div className="clip-thumbnail">
          <img src={clip.thumbnail} alt={clip.name} />
        </div>
      )}
    </div>
  );
};

=====================================
FILE: src/renderer/hooks/useTimelineFPS.ts
=====================================
import { useCallback } from 'react';
import { useTimelineContext } from './useTimelineContext';
import { ActionTypes } from '../types/timeline';
import { logger } from '../utils/logger';

export interface FPSConfig {
  fps: number;
  frameDuration: number;
  defaultFPS: number;
  minFPS: number;
  maxFPS: number;
  commonFPS: number[];
}

/**
 * Hook to manage timeline FPS configuration
 */
export const useTimelineFPS = () => {
  const { state, dispatch } = useTimelineContext();

  // Common FPS values
  const commonFPS = [23.976, 24, 25, 29.97, 30, 50, 59.94, 60];

  // FPS configuration
  const config: FPSConfig = {
    fps: state.fps,
    frameDuration: 1 / state.fps,
    defaultFPS: 30,
    minFPS: 1,
    maxFPS: 240,
    commonFPS
  };

  /**
   * Set timeline FPS
   */
  const setFPS = useCallback((fps: number) => {
    const clampedFPS = Math.min(Math.max(fps, config.minFPS), config.maxFPS);
    
    dispatch({
      type: ActionTypes.SET_FPS,
      payload: clampedFPS
    });

    logger.debug('Timeline FPS updated:', {
      fps: clampedFPS,
      frameDuration: 1 / clampedFPS
    });
  }, [dispatch, config.minFPS, config.maxFPS]);

  /**
   * Get nearest standard FPS value
   */
  const getNearestStandardFPS = useCallback((fps: number): number => {
    return commonFPS.reduce((prev, curr) => {
      return Math.abs(curr - fps) < Math.abs(prev - fps) ? curr : prev;
    });
  }, [commonFPS]);

  /**
   * Check if FPS value is a standard rate
   */
  const isStandardFPS = useCallback((fps: number): boolean => {
    return commonFPS.includes(fps);
  }, [commonFPS]);

  /**
   * Convert frame number to time
   */
  const frameToTime = useCallback((frame: number): number => {
    return frame / state.fps;
  }, [state.fps]);

  /**
   * Convert time to frame number
   */
  const timeToFrame = useCallback((time: number): number => {
    return Math.round(time * state.fps);
  }, [state.fps]);

  /**
   * Get frame duration in seconds
   */
  const getFrameDuration = useCallback((): number => {
    return 1 / state.fps;
  }, [state.fps]);

  /**
   * Check if time aligns with frame boundary
   */
  const isFrameAligned = useCallback((time: number): boolean => {
    const frame = time * state.fps;
    return Math.abs(frame - Math.round(frame)) < Number.EPSILON;
  }, [state.fps]);

  /**
   * Snap time to nearest frame boundary
   */
  const snapToFrame = useCallback((time: number): number => {
    return Math.round(time * state.fps) / state.fps;
  }, [state.fps]);

  return {
    ...config,
    setFPS,
    getNearestStandardFPS,
    isStandardFPS,
    frameToTime,
    timeToFrame,
    getFrameDuration,
    isFrameAligned,
    snapToFrame
  };
};

=====================================
FILE: src/renderer/hooks/useTimelineViewport.ts
=====================================
import { useCallback } from 'react';
import { useTimelineContext } from './useTimelineContext';
import * as scale from '../utils/timelineScale';
import { logger } from '../utils/logger';

export interface ViewportDimensions {
  width: number;
  height: number;
  scrollLeft: number;
  scrollTop: number;
  contentWidth: number;
  contentHeight: number;
  visibleDuration: number;
}

export const useTimelineViewport = () => {
  const { state } = useTimelineContext();

  /**
   * Convert time to pixels
   */
  const timeToPixels = useCallback((time: number): number => {
    return scale.timeToPixels(time, state.zoom);
  }, [state.zoom]);

  /**
   * Convert pixels to time
   */
  const pixelsToTime = useCallback((pixels: number): number => {
    return scale.pixelsToTime(pixels, state.zoom);
  }, [state.zoom]);

  /**
   * Get current pixels per second
   */
  const getPixelsPerSecond = useCallback((): number => {
    return scale.getPixelsPerSecond(state.zoom);
  }, [state.zoom]);

  /**
   * Get current pixels per frame
   */
  const getPixelsPerFrame = useCallback((): number => {
    return scale.getPixelsPerFrame(state.zoom, state.fps);
  }, [state.zoom, state.fps]);

  /**
   * Calculate viewport dimensions
   */
  const getViewportDimensions = useCallback((containerWidth: number, containerHeight: number): ViewportDimensions => {
    const contentWidth = scale.getContentWidth(state.duration, state.zoom);
    const visibleDuration = scale.getVisibleDuration(containerWidth, state.zoom);

    logger.debug('Viewport dimensions:', {
      containerWidth,
      contentWidth,
      zoom: state.zoom,
      visibleDuration
    });

    return {
      width: containerWidth,
      height: containerHeight,
      scrollLeft: state.scrollX,
      scrollTop: state.scrollY,
      contentWidth,
      contentHeight: containerHeight, // Height is fixed by container
      visibleDuration
    };
  }, [state.duration, state.zoom, state.scrollX, state.scrollY]);

  /**
   * Calculate optimal zoom level to fit duration
   */
  const getOptimalZoom = useCallback((width: number, padding: number = 1.1): number => {
    return scale.getOptimalZoom(state.duration, width, padding);
  }, [state.duration]);

  /**
   * Calculate minimum zoom level to fit duration
   */
  const getMinZoomLevel = useCallback((width: number): number => {
    return scale.getMinZoomLevel(state.duration, width);
  }, [state.duration]);

  /**
   * Get visible time range
   */
  const getVisibleTimeRange = useCallback((containerWidth: number): [number, number] => {
    const startTime = pixelsToTime(state.scrollX);
    const visibleDuration = scale.getVisibleDuration(containerWidth, state.zoom);
    const endTime = startTime + visibleDuration;

    return [startTime, endTime];
  }, [state.scrollX, state.zoom, pixelsToTime]);

  /**
   * Check if time is visible in viewport
   */
  const isTimeVisible = useCallback((time: number, containerWidth: number): boolean => {
    const [startTime, endTime] = getVisibleTimeRange(containerWidth);
    return time >= startTime && time <= endTime;
  }, [getVisibleTimeRange]);

  return {
    timeToPixels,
    pixelsToTime,
    getPixelsPerSecond,
    getPixelsPerFrame,
    getViewportDimensions,
    getOptimalZoom,
    getMinZoomLevel,
    getVisibleTimeRange,
    isTimeVisible
  };
};

=====================================
FILE: src/renderer/utils/throttle.ts
=====================================
/**
 * Throttle constants in milliseconds
 */
export const THROTTLE = {
  SCROLL: 16,    // ~60fps
  RESIZE: 100,   // Resize operations
  SAVE: 1000,    // Auto-save operations
  RENDER: 16,    // Canvas/WebGL renders
  PLAYBACK: 16,  // Video/audio playback updates
  DRAG: 16       // Drag operations
} as const;

/**
 * Creates a throttled function that only invokes func at most once per wait period
 */
export const throttle = <T extends (...args: any[]) => any>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let timeout: NodeJS.Timeout | null = null;
  let previous = 0;

  return (...args: Parameters<T>) => {
    const now = Date.now();

    if (!previous) {
      previous = now;
    }

    const remaining = wait - (now - previous);

    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }

      previous = now;
      func(...args);
    } else if (!timeout) {
      timeout = setTimeout(() => {
        previous = Date.now();
        timeout = null;
        func(...args);
      }, remaining);
    }
  };
};

=====================================
FILE: src/renderer/components/TimelineRuler.tsx
=====================================
import React, { useCallback, useMemo, useRef, useState } from 'react';
import { useTimelineCoordinates } from '../hooks/useTimelineCoordinates';
import { formatTime } from '../utils/timelineUnits';
import { logger } from '../utils/logger';

interface TimelineRulerProps {
  currentTime: number;
  duration: number;
  zoom: number;
  fps: number;
  onTimeChange: (time: number) => void;
  containerWidth: number;
  scrollLeft: number;
}

const BASE_PIXELS_PER_SECOND = 100;
const MIN_DIVISION_SPACING = 50; // Minimum pixels between divisions
const MAX_DIVISIONS = 200; // Maximum number of divisions to render
const FRAME_MARKER_HEIGHT = 10;
const SECOND_MARKER_HEIGHT = 15;
const LABEL_OFFSET = 25;

interface Division {
  time: number;
  x: number;
  isSecond: boolean;
  label?: string;
}

export const TimelineRuler: React.FC<TimelineRulerProps> = ({
  currentTime,
  duration,
  zoom,
  fps,
  onTimeChange,
  containerWidth,
  scrollLeft
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const { clientToTime } = useTimelineCoordinates(containerRef);
  const [isDragging, setIsDragging] = useState(false);

  // Calculate divisions for ruler marks
  const divisions = useMemo(() => {
    const pixelsPerSecond = BASE_PIXELS_PER_SECOND * zoom;
    const visibleDuration = containerWidth / pixelsPerSecond;
    const startTime = scrollLeft / pixelsPerSecond;
    const endTime = startTime + visibleDuration;

    // Determine optimal division interval
    const frameInterval = 1 / fps;
    const minInterval = MIN_DIVISION_SPACING / pixelsPerSecond;
    let interval = frameInterval;

    // Scale up interval if divisions would be too dense
    while (interval < minInterval) {
      if (interval < 0.1) interval *= 2;
      else if (interval < 0.5) interval = 0.5;
      else if (interval < 1) interval = 1;
      else interval = Math.ceil(interval) * 2;
    }

    const result: Division[] = [];
    let time = Math.floor(startTime / interval) * interval;

    while (time <= endTime && result.length < MAX_DIVISIONS) {
      const x = time * pixelsPerSecond;
      const isSecond = Math.abs(time % 1) < 0.001;

      result.push({
        time,
        x,
        isSecond,
        label: isSecond ? formatTime(time, { fps, showFrames: false }) : undefined
      });

      time += interval;
    }

    return result;
  }, [containerWidth, zoom, fps, scrollLeft]);

  // Draw ruler
  const drawRuler = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Set styles
    ctx.strokeStyle = '#666';
    ctx.fillStyle = '#999';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';

    // Draw divisions
    divisions.forEach(({ x, isSecond, label }) => {
      const height = isSecond ? SECOND_MARKER_HEIGHT : FRAME_MARKER_HEIGHT;

      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();

      if (label) {
        ctx.fillText(label, x, LABEL_OFFSET);
      }
    });

    // Draw current time marker
    const currentX = currentTime * BASE_PIXELS_PER_SECOND * zoom;
    ctx.strokeStyle = '#f00';
    ctx.beginPath();
    ctx.moveTo(currentX, 0);
    ctx.lineTo(currentX, canvas.height);
    ctx.stroke();
  }, [divisions, currentTime, zoom]);

  // Handle pointer events
  const handlePointerDown = useCallback((e: React.PointerEvent) => {
    if (!containerRef.current) return;

    setIsDragging(true);
    containerRef.current.setPointerCapture(e.pointerId);

    const time = clientToTime({ x: e.clientX, y: e.clientY });
    onTimeChange(time);

    logger.debug('Ruler pointer down:', { time });
  }, [clientToTime, onTimeChange]);

  const handlePointerMove = useCallback((e: React.PointerEvent) => {
    if (!isDragging) return;

    const time = clientToTime({ x: e.clientX, y: e.clientY });
    onTimeChange(time);

    logger.debug('Ruler pointer move:', { time });
  }, [isDragging, clientToTime, onTimeChange]);

  const handlePointerUp = useCallback((e: React.PointerEvent) => {
    if (!containerRef.current) return;

    setIsDragging(false);
    containerRef.current.releasePointerCapture(e.pointerId);

    logger.debug('Ruler pointer up');
  }, []);

  // Update canvas on changes
  React.useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    // Set canvas size
    canvas.width = containerWidth;
    canvas.height = 30;

    drawRuler();
  }, [containerWidth, drawRuler]);

  return (
    <div
      ref={containerRef}
      className="timeline-ruler"
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        position: 'sticky',
        top: 0,
        height: 30,
        backgroundColor: '#1a1a1a',
        borderBottom: '1px solid #333',
        cursor: 'pointer',
        zIndex: 1
      }}
    >
      <canvas
        ref={canvasRef}
        style={{
          position: 'absolute',
          left: 0,
          top: 0
        }}
      />
    </div>
  );
};

=====================================
FILE: src/renderer/hooks/useTimelineCoordinates.ts
=====================================
import { useCallback, RefObject } from 'react';
import { useTimelineContext } from './useTimelineContext';
import { clampTime } from '../utils/timeValidation';
import { logger } from '../utils/logger';

interface Coordinates {
  x: number;
  y: number;
}

interface ContainerInfo {
  rect: {
    left: number;
    top: number;
    width: number;
    height: number;
  };
  scroll: {
    left: number;
    top: number;
  };
}

export const useTimelineCoordinates = (containerRef: RefObject<HTMLElement>) => {
  const { state } = useTimelineContext();

  /**
   * Get container's position and scroll information
   */
  const getContainerInfo = useCallback((): ContainerInfo => {
    if (!containerRef.current) {
      return {
        rect: { left: 0, top: 0, width: 0, height: 0 },
        scroll: { left: 0, top: 0 }
      };
    }

    const domRect = containerRef.current.getBoundingClientRect();
    return {
      rect: {
        left: domRect.left,
        top: domRect.top,
        width: domRect.width,
        height: domRect.height
      },
      scroll: {
        left: containerRef.current.scrollLeft,
        top: containerRef.current.scrollTop
      }
    };
  }, []);

  /**
   * Convert client coordinates to timeline time
   */
  const clientToTime = useCallback((clientCoords: Coordinates): number => {
    const { rect, scroll } = getContainerInfo();
    
    // Calculate position relative to container
    const relativeX = clientCoords.x - rect.left + scroll.left;
    
    // Convert to time
    const time = relativeX / (state.zoom * 100);

    // Clamp to valid range
    const clampedTime = clampTime(time, {
      minValue: 0,
      maxValue: state.duration,
      snapToFrames: true,
      fps: state.fps
    });

    logger.debug('Client to time conversion:', {
      clientX: clientCoords.x,
      containerLeft: rect.left,
      scrollLeft: scroll.left,
      relativeX,
      time: clampedTime
    });

    return clampedTime;
  }, [state.zoom, state.duration, state.fps]);

  /**
   * Convert timeline time to client coordinates
   */
  const timeToClient = useCallback((time: number): Coordinates => {
    const { rect, scroll } = getContainerInfo();
    
    // Convert time to container-relative position
    const relativeX = time * state.zoom * 100;
    
    // Convert to client coordinates
    const clientX = relativeX + rect.left - scroll.left;

    logger.debug('Time to client conversion:', {
      time,
      relativeX,
      containerLeft: rect.left,
      scrollLeft: scroll.left,
      clientX
    });

    return {
      x: clientX,
      y: rect.top
    };
  }, [state.zoom]);

  /**
   * Get relative coordinates within the container
   */
  const getRelativeCoordinates = useCallback((clientCoords: Coordinates): Coordinates => {
    const { rect, scroll } = getContainerInfo();
    
    return {
      x: clientCoords.x - rect.left + scroll.left,
      y: clientCoords.y - rect.top + scroll.top
    };
  }, []);

  /**
   * Check if coordinates are within the container
   */
  const isWithinContainer = useCallback((clientCoords: Coordinates): boolean => {
    const { rect } = getContainerInfo();
    
    return (
      clientCoords.x >= rect.left &&
      clientCoords.x <= rect.left + rect.width &&
      clientCoords.y >= rect.top &&
      clientCoords.y <= rect.top + rect.height
    );
  }, []);

  /**
   * Get container dimensions and position
   */
  const getContainerDimensions = useCallback(() => {
    const { rect, scroll } = getContainerInfo();
    
    return {
      width: rect.width,
      height: rect.height,
      left: rect.left,
      top: rect.top,
      scrollLeft: scroll.left,
      scrollTop: scroll.top
    };
  }, []);

  return {
    clientToTime,
    timeToClient,
    getRelativeCoordinates,
    isWithinContainer,
    getContainerDimensions
  };
};

=====================================
FILE: src/renderer/components/TimelineContainer.tsx
=====================================
import React, { useCallback, useEffect, useState } from 'react';
import { Timeline } from './Timeline';
import { useTimelineContext } from '../hooks/useTimelineContext';
import { ActionTypes } from '../types/timeline';
import { logger } from '../utils/logger';

export const TimelineContainer: React.FC = () => {
  const { state, dispatch } = useTimelineContext();
  const [containerWidth, setContainerWidth] = useState(0);

  // Update container width on resize
  useEffect(() => {
    const updateWidth = () => {
      const container = document.querySelector('.timeline');
      if (container) {
        setContainerWidth(container.clientWidth);
      }
    };

    updateWidth();
    window.addEventListener('resize', updateWidth);
    return () => window.removeEventListener('resize', updateWidth);
  }, []);

  // Handle scroll events
  const handleScroll = useCallback((scrollLeft: number, scrollTop: number) => {
    dispatch({
      type: ActionTypes.SET_SCROLL_X,
      payload: scrollLeft
    });
    dispatch({
      type: ActionTypes.SET_SCROLL_Y,
      payload: scrollTop
    });
    logger.debug('Timeline scrolled:', { scrollLeft, scrollTop });
  }, [dispatch]);

  // Handle time updates
  const handleTimeUpdate = useCallback((time: number) => {
    dispatch({
      type: ActionTypes.SET_CURRENT_TIME,
      payload: { time }
    });
    logger.debug('Timeline time updated:', time);
  }, [dispatch]);

  return (
    <div className="timeline-container">
      <Timeline
        containerWidth={containerWidth}
        scrollLeft={state.scrollX}
        onScroll={handleScroll}
        onTimeUpdate={handleTimeUpdate}
      />
    </div>
  );
};

=====================================
FILE: src/renderer/components/TimelineTransitionHandle.tsx
=====================================
import React, { useCallback, useRef, useState } from 'react';
import { useTimelineContext } from '../hooks/useTimelineContext';
import { useTimelineViewport } from '../hooks/useTimelineViewport';
import { useSnapPoints } from '../hooks/useSnapPoints';
import { clampTime } from '../utils/timeValidation';
import { logger } from '../utils/logger';

interface TimelineTransitionHandleProps {
  clipId: string;
  time: number;
  type: 'in' | 'out';
  onChange: (time: number) => void;
}

const SNAP_THRESHOLD = 10; // pixels
const HANDLE_WIDTH = 12;

export const TimelineTransitionHandle: React.FC<TimelineTransitionHandleProps> = ({
  clipId,
  time,
  type,
  onChange
}) => {
  const { state } = useTimelineContext();
  const { timeToPixels, pixelsToTime } = useTimelineViewport();
  const { getAllSnapPoints, findNearestSnapPoint } = useSnapPoints(state.fps);
  
  const containerRef = useRef<HTMLDivElement>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [dragStartX, setDragStartX] = useState(0);
  const [dragStartTime, setDragStartTime] = useState(0);

  const handlePointerDown = useCallback((e: React.PointerEvent) => {
    if (!containerRef.current) return;

    setIsDragging(true);
    setDragStartX(e.clientX);
    setDragStartTime(time);
    containerRef.current.setPointerCapture(e.pointerId);

    logger.debug('Transition handle drag started:', {
      clipId,
      type,
      time
    });
  }, [clipId, type, time]);

  const handlePointerMove = useCallback((e: React.PointerEvent) => {
    if (!isDragging || !containerRef.current) return;

    const rect = containerRef.current.getBoundingClientRect();
    const scrollLeft = containerRef.current.parentElement?.scrollLeft || 0;
    
    // Calculate timeline coordinates accounting for scroll
    const timelineX = e.clientX - rect.left + scrollLeft;
    const deltaX = e.clientX - dragStartX;
    const newTime = dragStartTime + pixelsToTime(deltaX);

    // Get snap points
    const snapPoints = getAllSnapPoints(
      state.tracks,
      state.markers,
      state.currentTime
    );

    // Find nearest snap point within threshold
    const snapPoint = findNearestSnapPoint(
      newTime,
      snapPoints,
      pixelsToTime(SNAP_THRESHOLD),
      [type === 'in' ? 'clip-end' : 'clip-start']
    );

    // Apply snap or use raw position
    const snappedTime = snapPoint ? snapPoint.time : newTime;

    // Clamp to valid range
    const clampedTime = clampTime(snappedTime, {
      minValue: type === 'in' ? 0 : time,
      maxValue: type === 'out' ? state.duration : time,
      snapToFrames: true,
      fps: state.fps
    });

    onChange(clampedTime);

    logger.debug('Transition handle dragged:', {
      clipId,
      type,
      newTime: clampedTime,
      snapped: !!snapPoint
    });
  }, [
    isDragging,
    dragStartX,
    dragStartTime,
    state.tracks,
    state.markers,
    state.currentTime,
    state.duration,
    state.fps,
    clipId,
    type,
    time,
    getAllSnapPoints,
    findNearestSnapPoint,
    pixelsToTime,
    onChange
  ]);

  const handlePointerUp = useCallback((e: React.PointerEvent) => {
    if (!containerRef.current) return;

    setIsDragging(false);
    containerRef.current.releasePointerCapture(e.pointerId);

    logger.debug('Transition handle drag ended:', {
      clipId,
      type,
      finalTime: time
    });
  }, [clipId, type, time]);

  return (
    <div
      ref={containerRef}
      className={`transition-handle ${type} ${isDragging ? 'dragging' : ''}`}
      style={{
        position: 'absolute',
        left: timeToPixels(time) - (type === 'in' ? 0 : HANDLE_WIDTH),
        width: HANDLE_WIDTH,
        top: 0,
        bottom: 0,
        cursor: 'ew-resize'
      }}
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      role="slider"
      aria-label={`${type} transition handle`}
      aria-valuemin={type === 'in' ? 0 : time}
      aria-valuemax={type === 'out' ? state.duration : time}
      aria-valuenow={time}
    >
      <div className="handle-grip" />
    </div>
  );
};

=====================================
FILE: src/renderer/components/TimelineShortcutsHelp.tsx
=====================================
import React from 'react';
import { useTimelineContext } from '../hooks/useTimelineContext';
import { useTimelineShortcuts, ShortcutGroup, Shortcut } from '../hooks/useTimelineShortcuts';

interface TimelineShortcutsHelpProps {
  onClose: () => void;
}

export const TimelineShortcutsHelp: React.FC<TimelineShortcutsHelpProps> = ({
  onClose
}) => {
  const { state } = useTimelineContext();
  const { shortcutGroups } = useTimelineShortcuts(
    () => {},  // Empty handlers since this is just for display
    () => {},
    () => {}
  );

  const getShortcutStatus = (shortcut: Shortcut): string => {
    if (shortcut.disabledWhenPlaying && state.isPlaying) {
      return '(Disabled while playing)';
    }
    if (shortcut.requiresSelection && !state.selectedClipIds.length) {
      return '(Requires clip selection)';
    }
    if (shortcut.disabledWhenEditing) {
      return '(Disabled while editing text)';
    }
    return '';
  };

  return (
    <div className="shortcuts-help-overlay" onClick={onClose}>
      <div className="shortcuts-help-content" onClick={e => e.stopPropagation()}>
        <div className="shortcuts-help-header">
          <h2>Keyboard Shortcuts</h2>
          <button 
            className="close-button"
            onClick={onClose}
            aria-label="Close shortcuts help"
          >
            
          </button>
        </div>
        <div className="shortcuts-help-body">
          {shortcutGroups.map((group, groupIndex) => (
            <div key={groupIndex} className="shortcut-group">
              <h3>{group.name}</h3>
              <table>
                <tbody>
                  {group.shortcuts.map((shortcut, shortcutIndex) => (
                    <tr key={shortcutIndex}>
                      <td className="shortcut-key">
                        <kbd>{shortcut.key}</kbd>
                      </td>
                      <td className="shortcut-description">
                        {shortcut.description}
                      </td>
                      <td className="shortcut-status">
                        <span className="status-text">
                          {getShortcutStatus(shortcut)}
                        </span>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          ))}
        </div>
        <div className="shortcuts-help-footer">
          <p className="note">
            Note: Some shortcuts may be disabled based on the current context 
            (e.g., when playing, editing text, or when no clips are selected).
          </p>
        </div>
      </div>
    </div>
  );
};

=====================================
FILE: src/renderer/hooks/useTimelineShortcuts.ts
=====================================
import { useCallback, useEffect } from 'react';
import { useTimelineContext } from './useTimelineContext';
import { ActionTypes } from '../types/timeline';
import { logger } from '../utils/logger';

interface ShortcutContext {
  isPlaying: boolean;
  hasSelectedClips: boolean;
  isEditing: boolean;
  isModalOpen: boolean;
}

export interface ShortcutGroup {
  name: string;
  shortcuts: Shortcut[];
}

export interface Shortcut {
  key: string;
  description: string;
  action: () => void;
  requiresSelection?: boolean;
  disabledWhenPlaying?: boolean;
  disabledWhenEditing?: boolean;
}

export const useTimelineShortcuts = (
  onPlayPause: () => void,
  onStepForward: () => void,
  onStepBackward: () => void
) => {
  const { state, dispatch } = useTimelineContext();

  const getContext = useCallback((): ShortcutContext => ({
    isPlaying: state.isPlaying,
    hasSelectedClips: state.selectedClipIds.length > 0,
    isEditing: document.activeElement instanceof HTMLInputElement || 
               document.activeElement instanceof HTMLTextAreaElement,
    isModalOpen: document.querySelector('.modal[role="dialog"]') !== null
  }), [state.isPlaying, state.selectedClipIds]);

  const isShortcutEnabled = useCallback((shortcut: Shortcut, context: ShortcutContext): boolean => {
    if (context.isModalOpen) return false;
    if (context.isEditing && shortcut.disabledWhenEditing) return false;
    if (context.isPlaying && shortcut.disabledWhenPlaying) return false;
    if (shortcut.requiresSelection && !context.hasSelectedClips) return false;
    return true;
  }, []);

  // Global shortcuts (always available unless editing/modal)
  const globalShortcuts: ShortcutGroup = {
    name: 'Playback',
    shortcuts: [
      {
        key: 'Space',
        description: 'Play/Pause',
        action: onPlayPause,
        disabledWhenEditing: true
      },
      {
        key: 'Right',
        description: 'Step Forward',
        action: onStepForward,
        disabledWhenPlaying: true
      },
      {
        key: 'Left',
        description: 'Step Backward',
        action: onStepBackward,
        disabledWhenPlaying: true
      },
      {
        key: 'Home',
        description: 'Jump to Start',
        action: () => dispatch({
          type: ActionTypes.SET_CURRENT_TIME,
          payload: { time: 0 }
        }),
        disabledWhenPlaying: true
      },
      {
        key: 'End',
        description: 'Jump to End',
        action: () => dispatch({
          type: ActionTypes.SET_CURRENT_TIME,
          payload: { time: state.duration }
        }),
        disabledWhenPlaying: true
      }
    ]
  };

  // Clip shortcuts (require clip selection)
  const clipShortcuts: ShortcutGroup = {
    name: 'Clip Operations',
    shortcuts: [
      {
        key: 'Delete',
        description: 'Delete Selected Clips',
        action: () => {
          state.selectedClipIds.forEach(clipId => {
            const track = state.tracks.find(t => 
              t.clips.some(c => c.id === clipId)
            );
            if (track) {
              dispatch({
                type: ActionTypes.REMOVE_CLIP,
                payload: { trackId: track.id, clipId }
              });
            }
          });
          logger.debug('Deleted clips:', state.selectedClipIds);
        },
        requiresSelection: true,
        disabledWhenPlaying: true
      },
      {
        key: 'Ctrl+A',
        description: 'Select All Clips',
        action: () => {
          const allClipIds = state.tracks.flatMap(t => 
            t.clips.map(c => c.id)
          );
          dispatch({
            type: ActionTypes.SELECT_CLIPS,
            payload: { clipIds: allClipIds }
          });
          logger.debug('Selected all clips');
        }
      },
      {
        key: 'Ctrl+D',
        description: 'Deselect All',
        action: () => {
          dispatch({
            type: ActionTypes.SELECT_CLIPS,
            payload: { clipIds: [] }
          });
          logger.debug('Deselected all clips');
        },
        requiresSelection: true
      }
    ]
  };

  // Timeline shortcuts
  const timelineShortcuts: ShortcutGroup = {
    name: 'Timeline',
    shortcuts: [
      {
        key: '+',
        description: 'Zoom In',
        action: () => {
          dispatch({
            type: ActionTypes.SET_ZOOM,
            payload: state.zoom * 1.2
          });
          logger.debug('Zoom in:', state.zoom * 1.2);
        }
      },
      {
        key: '-',
        description: 'Zoom Out',
        action: () => {
          dispatch({
            type: ActionTypes.SET_ZOOM,
            payload: state.zoom / 1.2
          });
          logger.debug('Zoom out:', state.zoom / 1.2);
        }
      }
    ]
  };

  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    const context = getContext();
    const allShortcuts = [
      ...globalShortcuts.shortcuts,
      ...clipShortcuts.shortcuts,
      ...timelineShortcuts.shortcuts
    ];

    for (const shortcut of allShortcuts) {
      const key = shortcut.key.toLowerCase();
      const pressedKey = e.key.toLowerCase();
      const ctrlKey = key.startsWith('ctrl+') === e.ctrlKey;
      const matchesKey = ctrlKey ? 
        key.endsWith(pressedKey) : 
        key === pressedKey;

      if (matchesKey && isShortcutEnabled(shortcut, context)) {
        e.preventDefault();
        shortcut.action();
        break;
      }
    }
  }, [getContext, isShortcutEnabled, globalShortcuts, clipShortcuts, timelineShortcuts]);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);

  return {
    shortcutGroups: [globalShortcuts, clipShortcuts, timelineShortcuts]
  };
};

=====================================
FILE: src/renderer/components/TimelineHeader.tsx
=====================================
import React from 'react';
import { TimeDisplay } from './TimeDisplay';
import { PlaybackControls } from './PlaybackControls';
import { useTimelineContext } from '../hooks/useTimelineContext';
import { ActionTypes } from '../types/timeline';
import { logger } from '../utils/logger';

interface TimelineHeaderProps {
  currentTime: number;
  duration: number;
  zoom: number;
  fps: number;
  isPlaying: boolean;
  onPlayPause: () => void;
}

export const TimelineHeader: React.FC<TimelineHeaderProps> = ({
  currentTime,
  duration,
  zoom,
  fps,
  isPlaying,
  onPlayPause
}) => {
  const { dispatch } = useTimelineContext();

  const handleZoomIn = () => {
    dispatch({
      type: ActionTypes.SET_ZOOM,
      payload: zoom * 1.2
    });
    logger.debug('Zoom in:', zoom * 1.2);
  };

  const handleZoomOut = () => {
    dispatch({
      type: ActionTypes.SET_ZOOM,
      payload: zoom / 1.2
    });
    logger.debug('Zoom out:', zoom / 1.2);
  };

  return (
    <div className="timeline-header">
      <div className="timeline-controls">
        <TimeDisplay
          time={currentTime}
          fps={fps}
          options={{ showFrames: true }}
        />
        <PlaybackControls
          isPlaying={isPlaying}
          currentTime={currentTime}
          duration={duration}
          onPlayPause={onPlayPause}
        />
        <TimeDisplay
          time={duration}
          fps={fps}
          options={{ showFrames: true, compact: true }}
        />
      </div>
      <div className="zoom-controls">
        <button
          onClick={handleZoomOut}
          className="zoom-button"
          title="Zoom out"
          disabled={zoom <= 0.1}
        >
          -
        </button>
        <span className="zoom-level">{Math.round(zoom * 100)}%</span>
        <button
          onClick={handleZoomIn}
          className="zoom-button"
          title="Zoom in"
          disabled={zoom >= 10}
        >
          +
        </button>
      </div>
    </div>
  );
};

=====================================
FILE: src/renderer/components/TimeDisplay.tsx
=====================================
import React from 'react';
import { formatTime, TimeFormatOptions } from '../utils/timelineUnits';

interface TimeDisplayProps {
  time: number;
  fps: number;
  options?: Omit<TimeFormatOptions, 'fps'>;
  className?: string;
}

export const TimeDisplay: React.FC<TimeDisplayProps> = ({
  time,
  fps,
  options = {},
  className
}) => {
  const formattedTime = formatTime(time, {
    ...options,
    fps
  });

  return (
    <div className={`time-display ${className || ''}`}>
      {formattedTime}
    </div>
  );
};

export default App;

=====================================
FILE: src/renderer/components/clips/AudioClipContent.tsx
=====================================
import React from 'react';
import { AudioClip } from '../../types/timeline';

export interface AudioClipContentProps {
  clip: AudioClip;
  isSelected: boolean;
  zoom: number;
  fps: number;
}

export const AudioClipContent: React.FC<AudioClipContentProps> = ({
  clip,
  isSelected,
  zoom,
  fps
}) => {
  return (
    <div className={`audio-clip-content ${isSelected ? 'selected' : ''}`}>
      <div className="clip-label">{clip.name}</div>
      {clip.effects.length > 0 && (
        <div className="clip-effects">
          {clip.effects.map(effect => (
            <div key={effect.id} className={`effect ${effect.enabled ? 'enabled' : 'disabled'}`}>
              {effect.type}
            </div>
          ))}
        </div>
      )}
      {clip.trimStart !== undefined && (
        <div className="trim-indicator start" style={{ left: 0 }} />
      )}
      {clip.trimEnd !== undefined && (
        <div className="trim-indicator end" style={{ right: 0 }} />
      )}
      <div className="waveform-placeholder" />
    </div>
  );
};

=====================================
FILE: src/renderer/components/PlaybackControls.tsx
=====================================
import React, { useCallback } from 'react';
import { useTimelineContext } from '../hooks/useTimelineContext';
import { ActionTypes } from '../types/timeline';
import { timeToFrames, framesToTime } from '../utils/timelineUnits';

interface PlaybackControlsProps {
  isPlaying: boolean;
  currentTime: number;
  duration: number;
  onPlayPause: () => void;
}

export const PlaybackControls: React.FC<PlaybackControlsProps> = ({
  isPlaying,
  currentTime,
  duration,
  onPlayPause
}) => {
  const { state, dispatch } = useTimelineContext();

  const stepFrames = useCallback((frames: number) => {
    // Convert current time to frames
    const currentFrames = timeToFrames(currentTime, state.fps);
    // Add step and convert back to time
    const newTime = framesToTime(currentFrames + frames, state.fps);
    // Clamp to valid range
    const clampedTime = Math.max(0, Math.min(newTime, duration));

    dispatch({
      type: ActionTypes.SET_CURRENT_TIME,
      payload: { time: clampedTime }
    });
  }, [currentTime, duration, state.fps, dispatch]);

  const handleStepBackward = useCallback(() => {
    if (!isPlaying) {
      stepFrames(-1);
    }
  }, [isPlaying, stepFrames]);

  const handleStepForward = useCallback(() => {
    if (!isPlaying) {
      stepFrames(1);
    }
  }, [isPlaying, stepFrames]);

  const handleJumpToStart = useCallback(() => {
    dispatch({
      type: ActionTypes.SET_CURRENT_TIME,
      payload: { time: 0 }
    });
  }, [dispatch]);

  const handleJumpToEnd = useCallback(() => {
    dispatch({
      type: ActionTypes.SET_CURRENT_TIME,
      payload: { time: duration }
    });
  }, [duration, dispatch]);

  return (
    <div className="playback-controls">
      <button
        onClick={handleJumpToStart}
        className="control-button"
        aria-label="Jump to start"
        title="Jump to start"
        disabled={currentTime <= 0}
      >
        <span className="icon"></span>
      </button>
      <button
        onClick={handleStepBackward}
        className="control-button"
        aria-label="Step backward"
        title="Step backward"
        disabled={isPlaying || currentTime <= 0}
      >
        <span className="icon"></span>
      </button>
      <button
        onClick={onPlayPause}
        className="control-button play-button"
        aria-label={isPlaying ? 'Pause' : 'Play'}
        title={isPlaying ? 'Pause' : 'Play'}
      >
        <span className="icon">{isPlaying ? '' : ''}</span>
      </button>
      <button
        onClick={handleStepForward}
        className="control-button"
        aria-label="Step forward"
        title="Step forward"
        disabled={isPlaying || currentTime >= duration}
      >
        <span className="icon"></span>
      </button>
      <button
        onClick={handleJumpToEnd}
        className="control-button"
        aria-label="Jump to end"
        title="Jump to end"
        disabled={currentTime >= duration}
      >
        <span className="icon"></span>
      </button>
    </div>
  );
};

=====================================
FILE: src/renderer/utils/logger.ts
=====================================
/**
 * Application logger with configurable levels and environments
 */

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

interface LoggerConfig {
  level: LogLevel;
  enabled: boolean;
  prefix?: string;
}

class Logger {
  private static instance: Logger;
  private config: LoggerConfig = {
    level: process.env.NODE_ENV === 'development' ? LogLevel.DEBUG : LogLevel.WARN,
    enabled: true,
    prefix: '[Timeline]'
  };

  private constructor() {
    // Private constructor to enforce singleton
  }

  public static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  public configure(config: Partial<LoggerConfig>): void {
    this.config = { ...this.config, ...config };
  }

  private formatMessage(level: string, message: any, ...args: any[]): string {
    const timestamp = new Date().toISOString();
    const prefix = this.config.prefix ? `${this.config.prefix} ` : '';
    return `${timestamp} ${prefix}[${level}] ${message}`;
  }

  private shouldLog(level: LogLevel): boolean {
    return this.config.enabled && level >= this.config.level;
  }

  public debug(message: any, ...args: any[]): void {
    if (this.shouldLog(LogLevel.DEBUG)) {
      console.debug(this.formatMessage('DEBUG', message), ...args);
    }
  }

  public info(message: any, ...args: any[]): void {
    if (this.shouldLog(LogLevel.INFO)) {
      console.info(this.formatMessage('INFO', message), ...args);
    }
  }

  public warn(message: any, ...args: any[]): void {
    if (this.shouldLog(LogLevel.WARN)) {
      console.warn(this.formatMessage('WARN', message), ...args);
    }
  }

  public error(message: any, error?: Error, ...args: any[]): void {
    if (this.shouldLog(LogLevel.ERROR)) {
      console.error(this.formatMessage('ERROR', message), error || '', ...args);
      if (error?.stack) {
        console.error(error.stack);
      }
    }
  }

  // Performance logging
  public time(label: string): void {
    if (this.shouldLog(LogLevel.DEBUG)) {
      console.time(`${this.config.prefix} ${label}`);
    }
  }

  public timeEnd(label: string): void {
    if (this.shouldLog(LogLevel.DEBUG)) {
      console.timeEnd(`${this.config.prefix} ${label}`);
    }
  }

  // Group logging for related messages
  public group(label: string): void {
    if (this.shouldLog(LogLevel.DEBUG)) {
      console.group(this.formatMessage('GROUP', label));
    }
  }

  public groupEnd(): void {
    if (this.shouldLog(LogLevel.DEBUG)) {
      console.groupEnd();
    }
  }
}

// Export singleton instance
export const logger = Logger.getInstance();

// Usage examples:
// logger.configure({ level: LogLevel.DEBUG }); // Configure globally
// logger.debug('Initializing timeline');
// logger.info('Timeline ready');
// logger.warn('Performance degradation detected');
// logger.error('Failed to load clip', new Error('Network error'));
// 
// logger.time('Render duration');
// // ... rendering code
// logger.timeEnd('Render duration');
//
// logger.group('Timeline Update');
// logger.debug('Updating clips');
// logger.debug('Recalculating layout');
// logger.groupEnd();

=====================================
FILE: src/renderer/hooks/useTimelineScroll.ts
=====================================
import { useCallback, useRef, useState, useEffect } from 'react';
import { useTimelineContext } from './useTimelineContext';
import { ActionTypes } from '../types/timeline';
import { throttle, THROTTLE } from '../utils/throttle';
import { logger } from '../utils/logger';

interface ScrollState {
  scrollLeft: number;
  scrollTop: number;
  isScrolling: boolean;
}

export const useTimelineScroll = (containerRef: React.RefObject<HTMLElement>) => {
  const { state, dispatch } = useTimelineContext();
  const [scrollState, setScrollState] = useState<ScrollState>({
    scrollLeft: state.scrollX,
    scrollTop: state.scrollY,
    isScrolling: false
  });

  // Refs for tracking scroll state between renders
  const scrollingTimeoutRef = useRef<NodeJS.Timeout>();
  const lastScrollLeftRef = useRef(state.scrollX);
  const lastScrollTopRef = useRef(state.scrollY);

  // Update local state when timeline state changes
  useEffect(() => {
    setScrollState(prev => ({
      ...prev,
      scrollLeft: state.scrollX,
      scrollTop: state.scrollY
    }));
    lastScrollLeftRef.current = state.scrollX;
    lastScrollTopRef.current = state.scrollY;
  }, [state.scrollX, state.scrollY]);

  // Throttled scroll handler
  const handleScroll = useCallback(
    throttle((e: Event) => {
      if (!containerRef.current) return;

      const target = e.target as HTMLElement;
      const newScrollLeft = target.scrollLeft;
      const newScrollTop = target.scrollTop;

      // Only update if scroll position has changed significantly
      const hasScrollChanged = 
        Math.abs(newScrollLeft - lastScrollLeftRef.current) > 1 ||
        Math.abs(newScrollTop - lastScrollTopRef.current) > 1;

      if (hasScrollChanged) {
        // Update refs immediately for smooth scrolling
        lastScrollLeftRef.current = newScrollLeft;
        lastScrollTopRef.current = newScrollTop;

        // Update local state for UI
        setScrollState({
          scrollLeft: newScrollLeft,
          scrollTop: newScrollTop,
          isScrolling: true
        });

        // Dispatch to global state
        dispatch({
          type: ActionTypes.SET_SCROLL_X,
          payload: newScrollLeft
        });
        dispatch({
          type: ActionTypes.SET_SCROLL_Y,
          payload: newScrollTop
        });

        logger.debug('Timeline scroll', { 
          scrollLeft: newScrollLeft, 
          scrollTop: newScrollTop 
        });

        // Reset scrolling flag after delay
        if (scrollingTimeoutRef.current) {
          clearTimeout(scrollingTimeoutRef.current);
        }
        scrollingTimeoutRef.current = setTimeout(() => {
          setScrollState(prev => ({ ...prev, isScrolling: false }));
        }, THROTTLE.SCROLL * 2);
      }
    }, THROTTLE.SCROLL),
    [containerRef, dispatch]
  );

  // Scroll to specific position
  const scrollTo = useCallback(({ left, top }: { left?: number; top?: number }) => {
    if (!containerRef.current) return;

    if (typeof left === 'number') {
      containerRef.current.scrollLeft = left;
      lastScrollLeftRef.current = left;
      dispatch({
        type: ActionTypes.SET_SCROLL_X,
        payload: left
      });
    }

    if (typeof top === 'number') {
      containerRef.current.scrollTop = top;
      lastScrollTopRef.current = top;
      dispatch({
        type: ActionTypes.SET_SCROLL_Y,
        payload: top
      });
    }
  }, [containerRef, dispatch]);

  // Attach scroll listener
  useEffect(() => {
    const element = containerRef.current;
    if (!element) return;

    element.addEventListener('scroll', handleScroll);
    return () => {
      element.removeEventListener('scroll', handleScroll);
      if (scrollingTimeoutRef.current) {
        clearTimeout(scrollingTimeoutRef.current);
      }
    };
  }, [containerRef, handleScroll]);

  return {
    scrollTo,
    scrollState,
    isScrolling: scrollState.isScrolling
  };
};

=====================================
FILE: src/renderer/utils/timeValidation.ts
=====================================
import { timeToFrames, framesToTime } from './timelineUnits';
import { logger } from './logger';

interface TimeValidationOptions {
  minValue?: number;
  maxValue?: number;
  snapToFrames?: boolean;
  fps?: number;
}

const DEFAULT_OPTIONS: Required<TimeValidationOptions> = {
  minValue: 0,
  maxValue: Infinity,
  snapToFrames: true,
  fps: 30
};

/**
 * Clamps a time value within bounds and optionally snaps to frame boundaries
 */
export const clampTime = (time: number, options: TimeValidationOptions = {}): number => {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const { minValue, maxValue, snapToFrames, fps } = opts;

  let result = Math.max(minValue, Math.min(maxValue, time));

  if (snapToFrames) {
    // Convert to frames and back to ensure frame-accurate timing
    const frames = timeToFrames(result, fps);
    result = framesToTime(frames, fps);
  }

  return result;
};

interface ClipValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

/**
 * Validates clip trim points against clip duration and frame boundaries
 */
export const validateClipTrim = (
  trimStart: number | undefined,
  trimEnd: number | undefined,
  duration: number,
  fps: number
): ClipValidationResult => {
  const result: ClipValidationResult = {
    isValid: true,
    errors: [],
    warnings: []
  };

  // Convert to frame boundaries for validation
  const startFrame = trimStart !== undefined ? timeToFrames(trimStart, fps) : 0;
  const endFrame = trimEnd !== undefined ? timeToFrames(trimEnd, fps) : timeToFrames(duration, fps);
  const durationFrames = timeToFrames(duration, fps);

  // Validate trim points
  if (startFrame < 0) {
    result.errors.push('Trim start cannot be negative');
    result.isValid = false;
  }

  if (endFrame > durationFrames) {
    result.errors.push('Trim end cannot exceed clip duration');
    result.isValid = false;
  }

  if (startFrame >= endFrame) {
    result.errors.push('Trim start must be less than trim end');
    result.isValid = false;
  }

  // Check for potential issues
  if (endFrame - startFrame < fps) {
    result.warnings.push('Trimmed clip duration is less than one second');
  }

  return result;
};

interface TimeRangeValidationResult {
  isValid: boolean;
  errors: string[];
}

/**
 * Validates a time range against bounds and frame boundaries
 */
export const validateTimeRange = (
  startTime: number,
  endTime: number,
  options: TimeValidationOptions = {}
): TimeRangeValidationResult => {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const { minValue, maxValue, snapToFrames, fps } = opts;

  const result: TimeRangeValidationResult = {
    isValid: true,
    errors: []
  };

  // Clamp times to valid range
  const clampedStart = clampTime(startTime, opts);
  const clampedEnd = clampTime(endTime, opts);

  if (clampedStart !== startTime || clampedEnd !== endTime) {
    result.errors.push('Time values must be within valid range');
    result.isValid = false;
  }

  if (snapToFrames) {
    const startFrame = timeToFrames(startTime, fps);
    const endFrame = timeToFrames(endTime, fps);

    if (framesToTime(startFrame, fps) !== startTime || 
        framesToTime(endFrame, fps) !== endTime) {
      result.errors.push('Time values must align with frame boundaries');
      result.isValid = false;
    }
  }

  if (startTime >= endTime) {
    result.errors.push('Start time must be less than end time');
    result.isValid = false;
  }

  return result;
};

/**
 * Validates that a time value aligns with frame boundaries
 */
export const isFrameAligned = (time: number, fps: number): boolean => {
  const frame = timeToFrames(time, fps);
  return Math.abs(time - framesToTime(frame, fps)) < Number.EPSILON;
};

/**
 * Rounds a time value to the nearest frame boundary
 */
export const roundToFrame = (time: number, fps: number): number => {
  return framesToTime(Math.round(time * fps), fps);
};

// Export common validation options
export const VALIDATION = {
  PLAYHEAD: {
    snapToFrames: true,
    minValue: 0
  },
  CLIP_TRIM: {
    snapToFrames: true,
    minValue: 0
  },
  ZOOM: {
    snapToFrames: false,
    minValue: 0.1,
    maxValue: 10
  }
} as const;

=====================================
FILE: src/renderer/components/TimelinePoint.tsx
=====================================
import React from 'react';
import { useTimelineViewport } from '../hooks/useTimelineViewport';

interface TimelinePointProps {
  time: number;
  color?: string;
  label?: string;
  zoom: number;
}

export const TimelinePoint: React.FC<TimelinePointProps> = ({
  time,
  color = '#4a9eff',
  label,
  zoom
}) => {
  const { timeToPixels } = useTimelineViewport();

  return (
    <div 
      className="timeline-point"
      style={{
        left: timeToPixels(time),
        backgroundColor: color
      }}
      role="presentation"
      aria-label={label || `Timeline point at ${time.toFixed(2)} seconds`}
    >
      {label && (
        <div className="timeline-point-label">
          {label}
        </div>
      )}
    </div>
  );
};
